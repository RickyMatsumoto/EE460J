Optimal Densiﬁcation for Fast and Accurate Minwise Hashing

Anshumali Shrivastava 1

Abstract
Minwise hashing is a fundamental and one of
the most successful hashing algorithm in the lit-
erature. Recent advances based on the idea of
densiﬁcation (Shrivastava & Li, 2014a;c) have
shown that it is possible to compute k min-
wise hashes, of a vector with d nonzeros, in
mere (d + k) computations, a signiﬁcant im-
provement over the classical O(dk). These ad-
vances have led to an algorithmic improvement
in the query complexity of traditional indexing
algorithms based on minwise hashing. Unfortu-
nately, the variance of the current densiﬁcation
techniques is unnecessarily high, which leads to
signiﬁcantly poor accuracy compared to vanilla
minwise hashing, especially when the data is
sparse. In this paper, we provide a novel densiﬁ-
cation scheme which relies on carefully tailored
2-universal hashes. We show that the proposed
scheme is variance-optimal, and without losing
the runtime efﬁciency, it is signiﬁcantly more ac-
curate than existing densiﬁcation techniques. As
a result, we obtain a signiﬁcantly efﬁcient hash-
ing scheme which has the same variance and
collision probability as minwise hashing. Ex-
perimental evaluations on real sparse and high-
dimensional datasets validate our claims. We be-
lieve that given the signiﬁcant advantages, our
method will replace minwise hashing implemen-
tations in practice.

1. Introduction and Motivation

Recent years have witnessed a dramatic increase in the di-
mensionality of modern datasets. (Weinberger et al., 2009)
show dataset with 16 trillion (1013) unique features. Many
studies have shown that the accuracy of models keeps
climbing slowly with exponential increase in dimension-
ality. Large dictionary based representation for images,

1Rice University, Houston, TX, USA. Correspondence to: An-

shumali Shrivastava <anshumali@rice.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

speech, and text are quite popular (Broder, 1997; Fetterly
et al., 2003). Enriching features with co-occurrence infor-
mation leads to blow up in the dimensionality. 5-grams
are common for text representations. With vocabulary
size of 106, 5-grams representation requires dimensional-
ity of 1030. Representing genome sequences with features
consisting of 32-contiguous characters (or higher) (Ondov
et al., 2016) leads to around 432 = 264 dimensions.

To deal with the overwhelming dimensionality, there is an
increased emphasis on the use of hashing algorithms, such
as minwise hashing. Minwise hashing provides a conve-
nient way to obtain a compact representation of the data,
without worrying about the actual dimensionality. These
compact representations are directly used in large scale
data processing systems for a variety of tasks.

Minwise hashing is deﬁned for binary vectors. Binary vec-
tors can also be equivalently viewed as sets, over the uni-
verse of all the features, containing only attributes corre-
sponding to the non-zero entries. Minwise hashing belongs
to the Locality Sensitive Hashing (LSH) family (Broder
et al., 1998; Charikar, 2002). The method applies a ran-
dom permutation (or random hash function) π : Ω → Ω,
on the given set S ⊂ Ω, and stores the minimum value after
the permutation mapping. Formally,

hπ(S) = min(π(S)).

(1)

Given sets S1 and S2, it can be shown by elementary prob-
ability arguments that

P r(hπ(S1) = hπ(S2)) =

= R.

(2)

|S1 ∩ S2|
|S1 ∪ S2|

The quantity

R =

|S1 ∩ S2|
|S1 ∪ S2|

=

a
f1 + f2 − a

,

(3)

is the well known Jaccard Similarity (or resemblance) R
which is the most popular similarity measure in informa-
tion retrieval applications (Broder, 1997).

The probability of collision (equality of hash values), un-
der minwise hashing, is equal to the similarity of interest
R. This particular property, also known as the LSH prop-
erty (Indyk & Motwani, 1998; Charikar, 2002), makes min-
wise hash functions hπ suitable for creating hash buckets,

Optimal Densiﬁcation for Fast and Accurate Minwise Hashing

which leads to sublinear algorithms for similarity search.
Because of this same LSH property, minwise hashing is
a popular indexing technique for a variety of large-scale
data processing applications, which include duplicate de-
tection (Broder, 1997; Henzinger, 2006), all-pair similar-
temporal correlation (Chien
ity (Bayardo et al., 2007),
& Immorlica, 2005), graph algorithms (Buehrer & Chel-
lapilla, 2008; Chierichetti et al., 2009; Najork et al., 2009),
hashing time series (Luo & Shrivastava, 2017), and more.
It was recently shown that the LSH property of minwise
hashes can be used to generate kernel features for large-
scale learning (Li et al., 2011).

Minwise hashing is known to be theoretical optimal in
many scenarios (Bavarian et al., 2016). Furthermore, it was
recently shown to be provably superior LSH for angular
similarity (or cosine similarity) compared to widely popu-
lar Signed Random Projections (Shrivastava & Li, 2014b).
These unique advantages make minwise hashing arguably
the strongest hashing algorithm both in theory and practice.

Hashing Cost is Bottleneck: The ﬁrst step of algorithms
relying on minwise hashing is to generate, some large
enough, k minwise hashes (or ﬁngerprints) of the data vec-
In particular, for every data vector x, hi(x) ∀i ∈
tors.
{1, 2, ..., k} is repeatedly computed with independent per-
mutations (or hash functions). These k hashes are used for
a variety of data mining tasks such as cheap similarity es-
timation, indexing for sub-linear search, kernel features for
large scale learning, etc. Computing k hashes of a vector
x with traditional minwise hashing requires O(dk) com-
putation, where d is the number of non-zeros in vector x.
This computation of the multiple hashes requires multiple
passes over the data. The number of hashes required by
the famous LSH algorithm is O(nρ) which grows with the
size of the data. (Li, 2015) showed the necessity of around
4000 hashes per data vector in large-scale learning. Note,
advances in efﬁcient weighted minwise hashing by (Shri-
vastava, 2016) is not applicable for very sparse unweighed
minwise hashing.

Other Related Fast Sketches are not LSH: Two no-
table techniques for estimating Jaccard Similarity are: 1)
bottom-k sketches and 2) one permutation hashing (Li
et al., 2012). Although these two sketches are cheap
they do not satisfy the key LSH property
to compute,
and therefore are unsuitable for replacing minwise hash-
ing (Shrivastava & Li, 2014a;c). There are also substantial
empirical evidence that using these (non-LSH) sketches for
indexing leads to a drastic bias in the expected behavior,
leading to poor accuracy.

The Idea of “Densiﬁed” One Permutation Hashing: Re-
cently, (Shrivastava & Li, 2014a) showed a technique for
densifying sparse sketches from one permutation hashing
which provably removes the bias associated with one per-

mutation hashing. Please see Section 3.3 for details. The
scheme is much cheaper than the later discovered alterna-
tives which rely on continued sampling (or multiple hashes)
until no empty bins are left (Haeupler et al., 2014; Dahl-
gaard et al., 2017).
(Shrivastava & Li, 2014a) was the
ﬁrst success in creating efﬁcient hashing scheme which
satisﬁes the LSH property analogous to minwise hashing
and at the same time the complete process only requires
O(d + k) computations instead of the traditional bottleneck
of O(dk), and only one hash function.

Current Densiﬁcation is Inaccurate For Very Sparse
Datasets: The densiﬁcation process although efﬁcient and
unbiased was shown to have unnecessarily higher variance.
It was shown in (Shrivastava & Li, 2014c) that the tradi-
tional “densiﬁcation” lacks sufﬁcient randomness. It was
further revealed that densiﬁcation could be provably im-
proved by using k extra random bits. An improved vari-
ance was associated with a signiﬁcant performance gain in
the task of near-neighbor search. In this work, we show
that even the improved densiﬁcation scheme is far from
optimal. The ﬁndings of (Shrivastava & Li, 2014c) leaves
an open curiosity: What is the best variance that can be
achieved with “densiﬁcation” without sacriﬁcing the run-
ning time? We close this by providing a variance-optimal
scheme.

Our Contributions: We show that the existing densiﬁca-
tion schemes, for fast minwise hashing, are not only sub-
optimal but, worse, their variances do not go to zero with
increasing number of hashes. The variance with an increase
in the number of hashes converges to a positive constant.
This behavior implies that increasing the number of hashes
after a point will lead to no improvement, which is against
the popular belief that accuracy of randomized algorithms
keeps improving with an increase in the number of hashes.

To circumvent these issues we present a novel densiﬁcation
scheme which has provably superior variance compared to
existing schemes. We show that our proposal has the opti-
mal variance that can be achieved by densiﬁcation. Further-
more, the variance of new methodology converges to zero
with an increase in the number of hashes, a desirable behav-
ior absent in prior works. Our proposal makes novel use of
2-universal hashing which could be of independent interest
in itself. The beneﬁts of improved accuracy come with no
loss in computational requirements, and our scheme retains
the running time efﬁciency of the densiﬁcation.

We provide rigorous experimental evaluations of existing
solutions concerning both accuracy and running time efﬁ-
ciency, on real high-dimensional datasets. Our experiments
validate all our theoretical claims and show signiﬁcant im-
provement in accuracy, comparable to minwise hashing,
with a signiﬁcant gain in computational efﬁciency.

Optimal Densiﬁcation for Fast and Accurate Minwise Hashing

2. Important Notations and Concepts

Equation 2 (i.e. the LSH Property) leads to an estimator of
Jacard Similarity R, using k hashes, deﬁned by:

ˆR =

1
k

k
(cid:88)

i=1

1(hi(S1) = hi(S2)).

(4)

Here 1 is the indicator function. In the paper, by variance,
we mean the variance of the above estimator. Notations like
V ar(h+), will mean the variance of the above estimator
when the h+ is used as the hash function.

[k] will denote the set of integers {1, 2, ..., k}. n denotes
the number of points (samples) in the dataset. D will be
used for dimensionality. We will use min{S} to denote the
minimum element of the set S. A permutation π : Ω → Ω
applied to a set S is another set π(S), where x ∈ S if and
only if π(x) ∈ π(S). Our hashing will generate k hashes
hi i ∈ {1, 2, ..., k}, generally from different bins. Since
they all have same distribution and properties we will drop
subscripts. We will use h and h+ to denote the hashing
schemes of (Shrivastava & Li, 2014a) and (Shrivastava &
Li, 2014c) respectively.

3. Background: Fast Minwise Hashing via

Densiﬁcation

3.1. 2-Universal Hashing

Deﬁnitions: A randomized function huniv : [l] → [k] is
2-universal if for all, i, j ∈ [l] with i (cid:54)= j, we have the
following property for any z1, z2 ∈ [k] P r(huniv(i) =
z1 and huniv(j) = z2) = 1
k2

(Carter & Wegman, 1977) showed that the simplest way to
create a 2-universal hashing scheme is to pick a prime num-
ber p ≥ k, sample two random numbers a, b and compute
huniv(x) = ((ax + b) mod p) mod k

3.2. One Permutation Hashing and Empty Bins

It was shown in (Li et al., 2012; Dahlgaard et al., 2015)
that instead of computing the global minimum in Equa-
tion 2, i.e., h(S) = min(π(S)), an efﬁcient way to gen-
erate k sketches, using one permutation, is to ﬁrst bin the
range space of π, i.e. Ω, into k disjoint and equal partitions
followed by computing minimum in each bin (or partition).

Let Ωi denote the ith partition of the range space of π, i.e.
Ω. Formally, the ith one permutation hashes (OPH) of a set
S is deﬁned as

(cid:40)

hOP H
i

(S) =

min{π(S) ∩ Ωi},
E,

if {π(S) ∩ Ωi} (cid:54)= φ
otherwise.

An obvious computational advantage of this scheme is that
it is likely to generate many hash values, at most k, and only
requires one permutation π and only pass over the sets (or
binary vectors) S. It was shown that for any two sets S1
and S2 we have a conditional collision probability similar
to minwise hashing.

Let Ei = 1(cid:8)hOP H

i

(S2) = hOP H

i

P r(cid:0)hOP H

i

(S1) = hOP H

i

(S2) (cid:12)

However, P r(cid:0)hOP H

i

(S1) = hOP H

i

(S2) (cid:12)

(S2) = E(cid:9)
(6)
(cid:12) Ei = 0(cid:1) = R
(7)
(cid:12) Ei = 1(cid:1) (cid:54)= R
(8)

Here Ei is an indicator random variable of the event that
the ith partition corresponding to both S1 and S2 are empty.
See Figure 1

Any bin has a constant chance of being empty. Thus, there
is a positive probability of the event {Ei = 1}, for any
given pair S1 and S2 and hence for large datasets (big n)
a constant fraction of data will consist of simultaneously
empty bins (there are n2 × k trials for the bad event {Ei =
1} to happen). This fraction further increases signiﬁcantly
with the sparsity of the data and k, as both sparsity and k
increases the probability of the bad event {Ei = 1}. See
Table 4 for statistics of empty bins on real scenarios.

Unfortunately, whenever the outcome of the random per-
mutation leads to simultaneous empty bins, i.e.
event
Ei = 1, the LSH Property is not valid. In fact, there is not
sufﬁcient information present in the simultaneous empty
partitions for any meaningful statistics. Hence, one permu-
tation hashing cannot be used as an LSH. Simple heuristics
of handling empty bins as suggested in (Shrivastava & Li,
2014a) leads to a signiﬁcant bias and it was shown both the-
oretically and empirically that this bias leads to signiﬁcant
deviation from the expected behavior of one permutation
hashing when compared with minwise hashing. Thus, one
permutation hashing although computationally lucrative is
not a suitable replacement for minwise hashing.

3.3. The Idea of Densiﬁcation

In (Shrivastava & Li, 2014a), the authors proposed “den-
siﬁcation” or reassignment of values to empty bins by
reusing the information in the non-empty bins to ﬁx the
bias of one permutation hashing. The overall procedure is
quite simple. Any empty bin borrows the values of the clos-
est non-empty bins towards the circular right (or left)1. See
Figure 1 for an illustration. Since the positions of empty

1In (Shrivastava & Li, 2014a) they also needed an offset be-
cause the value of a hash in any bin was always reset between
[0,k]. We do not need the offset if we use the actual values of
π(S).

(5)

Optimal Densiﬁcation for Fast and Accurate Minwise Hashing

3.4. Lack of Randomness in Densiﬁcation

It was pointed out in (Shrivastava & Li, 2014c) that the
densiﬁcation scheme of (Shrivastava & Li, 2014a) has un-
necessarily high variance. In particular, the probability of
two empty bins borrowing the information of the same non-
empty bin was signiﬁcantly higher. This probability was
due to poor randomization (load balancing) which hurts the
variance.
(Shrivastava & Li, 2014c) showed that infusing
more randomness in the reassignment process by utilizing
k extra random bits provably improves the variance. See
Figure 1 for an example illustration of the method. The run-
ning time of the improved scheme was again O(d + k) for
computing k hashes. This improvement retains the required
LSH property, however this time with improved variance.
An improved variance led to signiﬁcant savings in the task
of near-neighbor search on real sparse datasets.

4. Issues with Current Densiﬁcation

Our careful analysis reveals that the variance, even with the
improved scheme, is still signiﬁcantly higher. Worse, even
in the extreme case when we take k → ∞ the variance
converges to a positive constant rather than zero, which im-
plies that even with inﬁnite samples, the variance will not
be zero. This positive limit further increases with the spar-
sity of the dataset. In particular, we have the following the-
orem about the limiting variances of existing techniques:

Theorem 1 Give any two ﬁnite sets S1, S2 ∈ Ω, with A =
|S1 ∪ S2| > a = |S1 ∩ S2| > 0 and |Ω| = D → ∞. The
limiting variance of the estimators from densiﬁcation and
improved densiﬁcation when k = D → ∞ is given by:

V ar(h+) =

lim
k→∞

(cid:21)

lim
k→∞

V ar(h) =

(cid:20) A − a
a
A
A(A + 1)
(cid:20) 3(A − 1) + (2A − 1)(a − 1)
2(A + 1)(A − 1)

a
A

> 0

(9)

−

(cid:21)

a
A

> 0

(10)

This convergence of variance to a constant value, despite
inﬁnite samples, of the existing densiﬁcation is also evi-
dent in our experimental ﬁndings (see Figure 3) where we
observe that the MSE (Mean Square Error) curves go ﬂat
with increasing k. Similar phenomenon was also reported
in (Shrivastava & Li, 2014c). It should be noted that for
classical minwise hashing the variance is R(1−R)
k → 0 for
any pair S1 and S2. Thus, current densiﬁcation, although
fast, loses signiﬁcantly in terms of accuracy. We remove
this issue with densiﬁcation. In particular, we show in The-
orem 2 that the limiting variance of the proposed optimal
densiﬁcation goes to 0. Our experimental ﬁndings suggests
that the new variance is very close to the classical min-
wise hashing. In addition, the new densiﬁcation retains the
speed of existing densiﬁed hashing thereby achieving the
best of the both worlds.

Figure 1. Illustration of One Permutaion Hashing (OPH) and
the two existing Densiﬁcation Schemes of (Shrivastava & Li,
2014a;c). Densiﬁcation simply borrows the value from near-
by empty bins. Different sets Si with have different pattern of
empty/nonempty bins. Since the pattern is random, the process is
similar to random re-use of unbiased values, which satisﬁes LSH
property in each bin (Shrivastava & Li, 2014c).

and non-empty bins were random, it was shown that den-
siﬁcation (or reassignment) was equivalent to a stochastic
reselection of one hash from a set of existing informative
(coming from non-empty bins) hashes which have the LSH
property. This kind of reassignment restores the LSH prop-
erty and collision probability for any two hashes, after re-
assignment, is exactly same as that of minwise hashing.

The densiﬁcation generates k hashes with the required LSH
Property and only requires two passes over the one permu-
tation sketches making the total cost of one permutation
hashing plus densiﬁcation O(d + k). This was a signiﬁcant
improvement over O(dk) with classical minwise hashing.
O(d + k) led to an algorithmic improvement over random-
ized algorithms relying on minwise hashing, as hash com-
putation cost is bottleneck step in all of them.

𝑺𝟏={𝟏𝟎,𝟑,𝟏𝟖,𝟏,𝟐𝟏,𝟐,𝟏𝟐,𝟐𝟐} ,   𝑺𝟐={𝟏𝟎,𝟏𝟓,𝟑,𝟔,𝟏𝟖,𝟐𝟏,𝟕}     𝑺𝟏,𝑺𝟐 ∈   𝛀={𝟏,𝟐,𝟑,…,𝟐𝟑}.  𝑳𝒆𝒕 𝑹𝒂𝒏𝒅𝒐𝒎  𝝅: 𝛀→𝛀 leads to 𝛑(𝟏𝟎)=𝟓,𝝅(𝟏𝟓)= 6,  𝝅(𝟑)=𝟕,𝝅(𝟔)=𝟏𝟐,𝝅(𝟏𝟖)=𝟏𝟒,𝝅(𝟏)=𝟏𝟓,𝝅(𝟐𝟏)=𝟏𝟔,𝝅(𝟕)=17,  𝝅(𝟐)=𝟏𝟖,   𝝅(𝟏𝟐)=𝟐𝟏,   𝝅(𝟐𝟐)=𝟐𝟐   𝝅(𝑺𝟏)={𝟓,𝟕,𝟏𝟒,𝟏𝟓,𝟏𝟔,𝟏𝟖,𝟐𝟏,𝟐𝟐}     𝒎𝒊𝒏(𝝅(𝑺𝟏))=𝟓   𝝅(𝑺𝟐)={𝟓,𝟔,𝟕,𝟏𝟐,𝟏𝟒,𝟏𝟔,𝟏𝟕}               𝒎𝒊𝒏(𝝅(𝑺𝟐))=𝟓    Partition Range 𝛀 into 6 Bins: [0,3],[4,7], [8,11],[12,15],[16,19],[20,23]  One Permutation Hashing: GET MIN IN BIN (E if EMPTY BIN)  𝒉𝑶𝑷𝑯(𝑺𝟏)=          𝑬,     𝟓,      𝑬,     𝟏𝟒,     𝟏𝟔,      𝟐𝟏    𝒉𝑶𝑷𝑯(𝑺𝟐)=           𝑬,      𝟓,      𝑬,     𝟏𝟐,     𝟏𝟔,      𝑬    Densification:  REASSIGN FROM RIGHT (CIRCULAR) 𝒉(𝑺𝟏)=                  𝟓,     𝟓,      𝟏𝟒,     𝟏𝟒,     𝟏𝟔,      𝟐𝟏    𝒉(𝑺𝟐)=                  𝟓,     𝟓,      𝟏𝟐,     𝟏𝟐,     𝟏𝟔,      𝟓     Improved Densification:  REASSIGN FROM LEFT OR RIGHT  (CIRCULAR) DEPENDING ON RANDOM BITS 0/1.  randbits =             0       1          1          0        1        0 𝒉+(𝑺𝟏)=          𝟐𝟏,     𝟓,      𝟏𝟒,       𝟏𝟒,     𝟏𝟔,     𝟐𝟏    𝒉+(𝑺𝟐)=          𝟏𝟔,     𝟓,      𝟏𝟐,       𝟏𝟐,     𝟏𝟔,     𝟏𝟔    Optimal Densiﬁcation for Fast and Accurate Minwise Hashing

allowing load sharing between the two ends instead of one
(Bins 1 and 5 instead of just 5). However, the load balanc-
ing is far from optimal. The locality of information shar-
ing is the main culprit with current densiﬁcation schemes.
Note, the poor load balancing does not change the expecta-
tion but affects the variance signiﬁcantly.

For any given pairs of vectors S1 and S2, let m be the
number of simultaneous non-empty bins (out of k), i.e.
(cid:80)k
i=1 Ei = k − m. Note, m is a random variable whose
value is different for every pair and depends on the outcome
of random π. Formally, the variance analysis of (Shrivas-
tava & Li, 2014c) reveals that the probability that any two
simultaneous empty bin p and q (Ep = Eq = 1) reuses the
m+1 with the densiﬁcation scheme h.
same information is
This probability was reduced down to 1.5
m+1 with h+ by uti-
lizing k extra random bits to promote load balancing.

2

m+1 is not quite perfect load balancing.

p = 1.5
In a per-
fect load balancing with m simultaneous non-empty bins,
the probability of two empty bins hitting the same non-
empty bins is at best p = 1
m . Can we design a densiﬁcation
scheme which achieves this p while maintaining the consis-
tency of densiﬁcation and at the same time does not hurt the
running time? It is not clear if such a scheme even exists.
We answer this question positively by constructing a densi-
ﬁcation method with precisely all the above requirements.
Furthermore we show that achieving p = 1
m is sufﬁcient
for having the limiting variance of zero.

5.2. Simple 2-Universal Hashing Doesn’t Help

To break the locality of the information reuse and allow a
non-empty bin to borrow information from any other far
off bin consistently, it seems natural to use universal hash-
ing. The hope is to have a 2-universal hash function (Sec-
tion 3.1) huniv : [k] → [k]. Whenever a bin i is empty,
instead of borrowing information from neighbors, borrow
information from bin huniv(i). The hash function allows
consistency across any two S1 and S2 hence preserves LSH
property. The value of huniv(i) is uniformly distributed, so
any bin is equally likely. Thus, it seems to break the local-
ity on the ﬁrst thought. If huniv(i) is also empty then we
continue using huniv(huniv(i)) until we reach a non-empty
bins whose value we re-use.

If i = huniv(i) (which
One issue is that of cycles.
has 1
k chance), then this creates a cycle and the assign-
ment will go into inﬁnite loop. A cycle can even occur if
huniv(huniv(i)) = i with both i and huniv(i) being empty.
Note, the process runs until it ﬁnds a non-empty bin. How-
ever, cycles are not just our concern. Even if we manage
to get away with cycles, this scheme does not provide the
required load balancing.

A careful inspection reveals that there is a very signiﬁcant

Figure 2. Illustration of Poor Load Balancing in the existing Den-
siﬁcation strategies. The re-assignment of bins is very local and
its not uniformly distributed. Thus, we do not use the information
in far off non-empty bins while densiﬁcation.

5. Optimal Densiﬁcation

We argue that even with the improved densiﬁcation there
is not enough randomness (or load balancing) in the re-
assignment process which leads to reduced variance.

For given set S, the densiﬁcation process reassigns every
empty bin with a value from one of the existing non-empty
bins. Note, the identity of empty and non-empty bins are
different for different sets. To ensure the LSH property,
the re-assignment should be consistent for any given pair
of sets S1 and S2. In particular, as noted in (Shrivastava
& Li, 2014a), given any arbitrary pair S1 and S2, when-
ever any given bin i is simultaneously empty, i.e. Ei = 1,
the reassignment of this bin i should mimic the collision
probability of one of the simultaneously non-empty bin j
with Ej = 0. An arbitrary reassignment (or borrow) of
values will not ensure this consistency across all pairs. We
would like to point out that the reassignment of S1 has no
idea about S2 or any other object in the dataset. Thus, en-
suring the consistency is non-trivial. Although the current
densiﬁcation schemes achieve this consistency by selecting
the nearest non-empty bin (as shown in (Shrivastava & Li,
2014c)), they lack sufﬁcient randomness.

5.1. Intuition: Load Balancing

In Figure 2, observe that if there are many contiguous
non-empty bins (Bins 2, 3 and 4), then with densiﬁcation
schemes h, all of them are forced to borrow values from the
same non-empty bin (Bin 5 in the example). Even though
there are other informative bins (Bins 1, 6 and 7), their in-
formation is never used. This local bias increases the prob-
ability (p) that two empty bins get tied to the same infor-
mation, even if there are many other informative non-empty
bins. Adding k random bits improves this to some extent by

Example of Poor Load Balancing  𝒉𝑶𝑷𝑯(𝑺𝟏)=          𝟓,     𝑬,      𝑬,     𝑬,     𝟏𝟔,      𝟐𝟏,     𝟐𝟓    𝒉𝑶𝑷𝑯(𝑺𝟐)=           𝟓,     𝑬,      𝑬,     𝑬,     𝟏𝟕,      𝟐𝟏,     𝟐𝟓    Densification:  ONLY 1 INFORMATIVE VALUE USED 𝒉(𝑺𝟏)=          𝟓,    𝟏𝟔,    𝟏𝟔,    𝟏𝟔,     𝟏𝟔,     𝟐𝟏,     𝟐𝟓  𝒉(𝑺𝟐)=         𝟓,    𝟏𝟕,    𝟏𝟕,    𝟏𝟕,     𝟏𝟕,     𝟐𝟏,     𝟐𝟓    Improved Densification:  ONLY 2 INFORMATIVE VALUES USED randbits =             0       0      1       0         1         0         1   𝒉(𝑺𝟏)=               𝟓,    𝟏𝟔,    𝟓,    𝟏𝟔,     𝟏𝟔,     𝟐𝟏,     𝟐𝟓  𝒉(𝑺𝟐)=              𝟓,    𝟏𝟕,    𝟓,    𝟏𝟕,     𝟏𝟕,     𝟐𝟏,     𝟐𝟓     Optimal Densiﬁcation for Fast and Accurate Minwise Hashing

chance that both i and huniv(i) to be empty for any given
set S. Observe that if i and huniv(i) are both empty, then
we are bound to reuse the information of the same non-
empty bin for both empty bins i and huniv(i). We should
note that we have no control over the positions of empty
and non-empty bins. In fact, if no cycles happen then it
is not difﬁcult to show that the simple assignment using
universal hashing is equivalent to the original densiﬁcation
h with the order of bins reshufﬂed using huniv(.). It has
worse variance than h+.

5.3. The Fix: Carefully Tailored 2-Universal Hashing

Algorithm 1 Optimal Densiﬁcation
input k One Permutation Hashes hOP H [ ] of S.
input huniv(., .)

Initialize h∗[ ] = 0
for i = 1 to k do

if OP H[i] (cid:54)= E then
h∗[i] = hOP H [i]

else

attempt = 1
next = huniv(i, attempt)
while hOP H [next] (cid:54)= E do

attempt + +
next = huniv(i, attempt)

end while
h∗[i] = hOP H [next]

end if
end for
RETURN h∗[ ]

It turns out that there is a way to use universal hashing that
ensures no cycles as well as optimal load balancing. We
describe the complete process in Algorithm 1. The key is
to use a 2-universal hashing huniv : [k] × N → [k] which
takes two arguments: 1) The current bin id that needs to be
reassigned and 2) the number of failed attempt made so far
to reach a non-empty bin. This second argument ensures
no inﬁnite loops as it changes with every attempt. So even
if we reach the same non-empty bin back (cycle), the next
time we will visit a new set of bins. Also, even if both i and
j = huniv(i, attempti) are empty, i and j are not bound
to end to the same non-empty bin. This is because in the
next attempt we seek bin value huniv(i, attempti + 1) for
i which is independent of the huniv(j, attemptj) due to
2-universality of the hash function huniv. Thus, the proba-
bility that any two empty bins reuse the information of the
same non-empty bin is 1
m

5.4. Analysis and Optimality

We denote the ﬁnal k hashes generated by the proposed
densiﬁcation scheme of Algorithm 1 using h∗ (* for opti-

mality). Formally, with the optimal densiﬁcation h∗, we
have the following:

Theorem 2

P r(cid:0)h∗(S1) = h∗(S2)(cid:1) =

V ar(h∗) =

R
k
V ar(h∗) = 0

+ A

lim
k→∞

= R

|S1 ∩ S2|
|S1 ∩ S2|
R ¯R
k2 − R2

R
k2 + B

(11)

(12)

(13)

where Nemp is the number of simultaneous empty bins be-
tween S1 and S2 and the quantities A and B are given by

A = E

2Nemp +

Nemp(Nemp − 1)
k − Nemp

(cid:21)

(cid:20)

(cid:20)

B = E

(k − Nemp)(k − Nemp − 1) + 2Nemp(k − Nemp − 1)

+

Nemp(Nemp − 1)(k − Nemp − 1)
k − Nemp

(cid:21)

Using the formula for P r(Nemp = i) from (Li et al., 2012),
we can precisely compute the theoretical variance. The in-
teresting part is that we can formally show that the variance
of the proposed scheme is strictly superior compared to the
densiﬁcation scheme with random bits improvements.

Theorem 3

V ar(h∗) ≤ V ar(h+) ≤ V ar(h)

(14)

Theorem 4 Among all densiﬁcation schemes, where the
reassignment process for bin i is independent of the reas-
signment process of any other bin j, Algorithm 1 achieves
the best possible variance.

Note: The variance can be reduced if we allow correlations
in the assignment process, for example if we force bin i and
bin j to not pick the same bin during reassignments, this
will reduce p beyond the perfectly random load balancing
value of 1
m . However, such tied reassignment will require
more memory and computations for generating structured
hash functions. Also, we use only one hash function (or
permutation). If we allow multiple independent hash func-
tion then with additional computational and memory cost
the variance can be further reduced.

5.5. Running Time

We show that the expected running time of our proposal,
including all constants, is very similar to the running time
of the existing densiﬁcation schemes.

Given set S with |S| = d, we are interested in computing
k hash values. The ﬁrst step involves computing k one per-
mutation hashes (or sketches) which only requires a single

Optimal Densiﬁcation for Fast and Accurate Minwise Hashing

Figure 3. Average MSE in Jaccard Similarity Estimation with the Number of Hash Values (k). Estimates are averaged over 5000
repetitions. With Optimal densiﬁcation the variance is very close to costly minwise hashing, which is signiﬁcantly superior to existing
densiﬁcation schemes. Note the log scale of y-axis.

Sim R |S1|
208
0.94
47
0.87
91
0.74
15
0.61
419
0.54
76
0.47
264
0.20
655
0.02

|S2|
196
41
67
14
232
36
182
423

Pair 1
Pair 2
Pair 3
Pair 4
Pair 5
Pair 6
Pair 7
Pair 8

Table 1. Statistics of Pairs vectors (binary) with their Similarity
and Sparsity (non-zeros).

pass over the elements of S. This takes max{d, k} ≤ d + k
time. Now the densiﬁcation Algorithm 1 requires a for loop
of size k and within each for loop, if the bin is empty, it
requires an additional while loop. Let Nemp be the num-
ber of empty bins, and therefore k−Nemp
is the probability
that the while loop will terminate in one iteration (next is
not empty). Therefore, the expected number of iteration
that each while loop will run is a binomial random variable
. Thus, the expected running time
with expectation
of the algorithm is given by

k
k−Nemp

k

E[Running Time] = d + 2k − Nemp + Nemp

≤ d + (r + 2)k where r =

k
k − Nemp
Nemp
Nnot−emp

The quantity r, which is the ratio of number of empty bins
to the number of non-empty bins, is generally very small.
It is rarely more than 2 to 3 in practice. Observe that ran-
domly throwing d items into k bins, the expected number
of empty bins is E[Nemp] ≈ k(1 − 1
k . Which

k )d ≈ ke− d

makes r ≈ e−d/k
1−e−d/k . The number of sketches is usually of
the order of non-zeros. Even for very good concentration,
the size of the sketches k is rarely much larger than the size
of the set d. Even when k is 4 times d the value of r is
approximately 3.5. Thus, the quantity r is negligible.

It should be further noted that the implementation cost of
densiﬁcation scheme h+ is d + 4k which in not very differ-
ent from the cost of our proposal.

6. Evaluations
Our aim is to verify the theoretical claims of these papers
empirically. We show that our proposal can replace min-
wise hashing for all practical purposes. To establish that,
we focus on experiments with the following objectives:
1. Verify that our proposed scheme has a signiﬁcantly
better accuracy (variance) than the existing densiﬁcation
schemes. Validate our variance formulas.
2. Empirically quantify the impact of optimal variance in
practice. How does this quantiﬁcation change with simi-
larity and sparsity? Verify that the proposal has accuracy
close to vanilla minwise hashing.
3. Verify that there is no impact on running time of the pro-
posed scheme over existing densiﬁcation schemes, and our
proposal is signiﬁcantly faster than vanilla minwise hash-
ing. Understand how the running time changes with change
in sparsity and k?

6.1. Accuracy

For objectives 1 and 2, we selected 9 different word pairs
embedding, generated from new20 corpus, with varying
level of similarity and sparsity. We use the popular term-
document vector representation for each word. The statis-

Num of Hashes (k)100101102103104105MSE10-610-510-410-310-210-1100Pair 1:  R=0.94VanillaImprovedProposedProp-TheoryMinHash-TheoryNum of Hashes (k)100101102103104105MSE10-610-510-410-310-210-1100Pair 2:  R=0.87VanillaImprovedProposedProp-TheoryMinHash-TheoryNum of Hashes (k)100101102103104105MSE10-610-510-410-310-210-1100Pair 3:  R=0.74VanillaImprovedProposedProp-TheoryMinHash-TheoryNum of Hashes (k)100101102103104105MSE10-610-510-410-310-210-1100Pair 4:  R=0.61VanillaImprovedProposedProp-TheoryMinHash-TheoryNum of Hashes (k)100101102103104105MSE10-610-510-410-310-210-1100Pair 5:  R=0.54VanillaImprovedProposedProp-TheoryMinHash-TheoryNum of Hashes (k)100101102103104105MSE10-610-510-410-310-210-1100Pair 6:  R=0.47VanillaImprovedProposedProp-TheoryMinHash-TheoryNum of Hashes (k)100101102103104105MSE10-610-510-410-310-210-1100Pair 7:  R=0.2VanillaImprovedProposedProp-TheoryMinHash-TheoryNum of Hashes (k)100101102103104105MSE10-610-510-410-310-210-1100Pair 8:  R=0.08VanillaImprovedProposedProp-TheoryMinHash-TheoryOptimal Densiﬁcation for Fast and Accurate Minwise Hashing

Existing h+
200
86
584
179

100
62
373
154

300
104
624
205

This Paper h∗
200
90
459
158

100
56
287
139

300
116
631
174

Vanilla MinHash
300
200
1098
733
8158
6247
3650
2404

100
376
2760
1201

RCV1
URL
NEWS20

Table 2. Time (in milliseconds) requires to compute 100, 200 and 300 hashes of the full data using the existing densiﬁcation, proposed
densiﬁcation and vanilla minwise hashing. Minhash can be 10-18x slower for computing 300 hashes on these datasets.

RCV1
URL
News20

Avg. non-zeros (d)
73
115
402

Dim (D)
47,236
3,231,961
1,355,191

Samples
20,242
100,000
19,996

Table 3. Basic Statistics of Datasets.

tics of these word vector pairs are summarized in Table 1

For each word pairs, we generated k hashes using three
different schemes: 1) Densiﬁcation h, 2) Improved Den-
siﬁcation h+ and the proposed densiﬁcation h∗ (Algo-
rithm 1). Using these hashes, we estimate the Jaccard sim-
ilarity (Equation 4). We plot the mean square error (MSE)
with varying the number of hashes. Since the process is
randomized, we repeat the process 5000 times, for every k,
and report the average over independent runs. We report all
integer values of k in the interval [1, 214].

It should be noted that since all three schemes have the
LSH Property, the bias is zero and hence the MSE is the
theoretical variance. To validate our variance formula, we
also compute and plot the theoretical value of the variance
(Equation 12) of the optimal scheme. Also, to understand
how all these fast methodologies compare with the accu-
racy of vanilla minwise hashing we also plot the theoretical
variance of minwise hashing which is R(1−R)

.

k

From the results in Figure 3, we can conclude.
Conclusion 1: The proposed densiﬁcation is signiﬁcantly
more accurate, irrespective of the choice of sparsity and
similarity, than the existing densiﬁcation schemes espe-
cially for large k. Note the y-axis of plots is on log scale,
so the accuracy gains are drastic.
Conclusion 2: The gains with optimal densiﬁcation is
more for sparse data.
Conclusion 3: The accuracy of optimal densiﬁcation is
very close the accuracy of costly minwise hashing.
Conclusion 4: The theoretical variance of our proposal
overlaps with the empirical estimates, and it seems to go
to zero validating Theorem 12.
Conclusion 5: The variances (or the MSE) of existing den-
siﬁcation seems to converge to constant and do not go to
zero conﬁrming Theorem 1.

6.2. Speed

RCV1
URL
News20

100 Bins
53
33
14

200 Bins
143
112
58

300 Bins
238
202
120

Table 4. Avg. Number of Empty Bins per vector (rounded) gener-
ated with One Permutation Hashing (Li et al., 2012). For sparse
datasets, a signiﬁcant (80% with 300 hashes) of the bins can be
empty and have no information. They cannot be used for indexing
and kernel learning. Fortunately, we can efﬁciently densify them
with optimal densiﬁcation, such that, all the generated k hashes
have variance similar to minwise hashing. The overall computa-
tional cost is signiﬁcantly less compared to minwise hashing

mensionality and sparsity of these datasets are an excel-
lent representative of the scale and the size frequently en-
countered in large-scale data processing systems, such as
Google’s SIBYL (Chandra et al., 2010). The statistics of
these datasets are summarized in Table 3.

We implemented three methodologies for computing
hashes: 1) Densiﬁcation Scheme h+, 2) The Proposed h∗
(Algorithm 1 and 3) Vanilla Minwise Hashing. The meth-
ods were implemented in C++. Cheap hash function re-
placed costly permutations. Clever alternatives to avoid
mod operations were employed. These tricks ensured that
our implementations2 are as efﬁcient as the possible. We
compute the wall clock time required to calculate 100,
200 and 300 hashes of all the three datasets. The time
include the end-to-end hash computation of the complete
data. Data loading time is not included. The results are
presented in Table 2. All the experiments were done on
Intel i7-6500U processor laptop with 16GB RAM.

Also, to get an estimate of the importance of densiﬁcation,
we also show the average number of empty bins generated
by only using one permutation hashing and report the num-
bers in Table 4. We can clearly see that the number of
empty bins is signiﬁcantly larger and the hashes are un-
usable without densiﬁcation. From Table 2, we conclude:
Conclusion 1: Optimal densiﬁcation is as fast as tradi-
tional densiﬁcation irrespective of k and the sparsity. How-
ever, optimal densiﬁcation is signiﬁcantly more accurate.
Conclusion 2: Both the densiﬁcation scheme is signiﬁ-
cantly faster than minwise hashing. They are 10-18x faster
for computing 300 hashes on the selected datasets.

To compute the runtime, we use three publicly available
text datasets: 1) RCV1, 2) URL and 3) News20. The di-

2Codes

are
fastest-minwise.html

available

at http://rush.rice.edu/

Optimal Densiﬁcation for Fast and Accurate Minwise Hashing

Acknowledgements
This work was supported by NSF IIS-1652131 Grant.

References

Bavarian, Mohammad, Ghazi, Badih, Haramaty, Elad,
Kamath, Pritish, Rivest, Ronald L.,
and Sudan,
Madhu. The optimality of correlated sampling. CoRR,
abs/1612.01041, 2016. URL http://arxiv.org/
abs/1612.01041.

Bayardo, Roberto J., Ma, Yiming, and Srikant, Ramakrish-
nan. Scaling up all pairs similarity search. In WWW, pp.
131–140, 2007.

Broder, Andrei Z. On the resemblance and containment
In the Compression and Complexity of

of documents.
Sequences, pp. 21–29, Positano, Italy, 1997.

Broder, Andrei Z., Charikar, Moses, Frieze, Alan M., and
Mitzenmacher, Michael. Min-wise independent permu-
tations. In STOC, pp. 327–336, Dallas, TX, 1998.

Buehrer, Gregory and Chellapilla, Kumar. A scalable pat-
tern mining approach to web graph compression with
In WSDM, pp. 95–106, Stanford, CA,
communities.
2008.

Carter, J. Lawrence and Wegman, Mark N. Universal
classes of hash functions. In STOC, pp. 106–112, 1977.

Chandra, Tushar, Ie, Eugene, Goldman, Kenneth, Llinares,
Tomas Lloret, McFadden, Jim, Pereira, Fernando, Red-
stone, Joshua, Shaked, Tal, and Singer, Yoram. Sibyl: a
system for large scale machine learning. Technical re-
port, 2010.

Charikar, Moses S. Similarity estimation techniques from
rounding algorithms. In STOC, pp. 380–388, Montreal,
Quebec, Canada, 2002.

Chien, Steve and Immorlica, Nicole. Semantic similarity
between search engine queries using temporal correla-
tion. In WWW, pp. 2–11, 2005.

Chierichetti, Flavio, Kumar, Ravi, Lattanzi, Silvio, Mitzen-
macher, Michael, Panconesi, Alessandro, and Raghavan,
Prabhakar. On compressing social networks. In KDD,
pp. 219–228, Paris, France, 2009.

Dahlgaard, Søren, Knudsen, Mathias Bæk Tejs, Rotenberg,
Eva, and Thorup, Mikkel. Hashing for statistics over k-
partitions. In Foundations of Computer Science (FOCS),
2015 IEEE 56th Annual Symposium on, pp. 1292–1310.
IEEE, 2015.

Fetterly, Dennis, Manasse, Mark, Najork, Marc, and
Wiener, Janet L. A large-scale study of the evolution of
web pages. In WWW, pp. 669–678, Budapest, Hungary,
2003.

Haeupler, Bernhard, Manasse, Mark, and Talwar, Kunal.
Consistent weighted sampling made fast, small, and
easy. arXiv preprint arXiv:1410.4266, 2014.

Henzinger, Monika Rauch. Finding near-duplicate web
pages: a large-scale evaluation of algorithms. In SIGIR,
pp. 284–291, 2006.

Indyk, Piotr and Motwani, Rajeev. Approximate nearest
neighbors: Towards removing the curse of dimensional-
ity. In STOC, pp. 604–613, Dallas, TX, 1998.

Li, Ping. 0-bit consistent weighted sampling.

In KDD,

2015.

Li, Ping, Shrivastava, Anshumali, Moore, Joshua, and
K¨onig, Arnd Christian. Hashing algorithms for large-
scale learning. In NIPS, Granada, Spain, 2011.

Li, Ping, Owen, Art B, and Zhang, Cun-Hui. One permu-

tation hashing. In NIPS, Lake Tahoe, NV, 2012.

Luo, Chen and Shrivastava, Anshumali. Ssh (sketch, shin-
gle, & hash) for indexing massive-scale time series. In
NIPS 2016 Time Series Workshop, pp. 38–58, 2017.

Najork, Marc, Gollapudi, Sreenivas, and Panigrahy, Rina.
Less is more: sampling the neighborhood graph makes
In WSDM, pp. 242–251,
salsa better and faster.
Barcelona, Spain, 2009.

Ondov, Brian D, Treangen, Todd J, Melsted, P´all,
Mallonee, Adam B, Bergman, Nicholas H, Koren,
Sergey, and Phillippy, Adam M. Mash: fast genome
and metagenome distance estimation using minhash.
Genome Biology, 17(1):132, 2016.

Shrivastava, Anshumali. Simple and efﬁcient weighted
In Advances in Neural Information

minwise hashing.
Processing Systems, pp. 1498–1506, 2016.

Shrivastava, Anshumali and Li, Ping. Densifying one
permutation hashing via rotation for fast near neighbor
search. In ICML, Beijing, China, 2014a.

Shrivastava, Anshumali and Li, Ping. In defense of min-
In Proceedings of the Seventeenth
hash over simhash.
International Conference on Artiﬁcial Intelligence and
Statistics, pp. 886–894, 2014b.

Dahlgaard, Søren, Knudsen, Mathias Bæk Tejs, and Tho-
rup, Mikkel. Fast similarity sketching. arXiv preprint
arXiv:1704.04370, 2017.

Shrivastava, Anshumali and Li, Ping. Improved densiﬁca-
tion of one permutation hashing. In UAI, Quebec, CA,
2014c.

Optimal Densiﬁcation for Fast and Accurate Minwise Hashing

Weinberger, Kilian, Dasgupta, Anirban, Langford, John,
Smola, Alex, and Attenberg, Josh. Feature hashing for
large scale multitask learning. In ICML, pp. 1113–1120,
2009.

