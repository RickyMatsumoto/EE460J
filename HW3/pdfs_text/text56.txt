Improving Viterbi is Hard: Better Runtimes Imply Faster Clique Algorithms

A. Hardness of VITERBI PATH with small alphabet: Proof

Throughout the proof, we set p = (cid:100) C

ε (cid:101) and α = C

p ≤ ε.

We will perform a reduction from the MIN-WEIGHT k-CLIQUE problem for k = p + 2 to the VITERBI PATH problem. In
the instance of the MIN-WEIGHT k-CLIQUE problem, we are given a k-partite graph G = (V1 ∪ V2 ∪ U1 . . . ∪ Up, E) such
that |V1| = |V2| = n and |U1| = . . . = |Up| = m = Θ(nα). We want to ﬁnd a clique of minimum weight in the graph G.
Before describing our ﬁnal VITERBI PATH instance, we ﬁrst deﬁne a weighted directed graph G(cid:48) = ({1, 2, 3}∪V1∪V2, E(cid:48))
similar to the graph in the proof of Theorem 1. E(cid:48) contains all the edges of G between V1 and V2, directed from V1 towards
V2, edges from node 1 towards all nodes in V1 of weight 0 and edges from all nodes in V2 towards node 2 of weight 0. We
also add a self-loop at nodes 1 and 3 of weight 0 as well as an edge of weight 0 from node 2 towards node 3. We obtain the
ﬁnal graph G(cid:48)(cid:48) as follows:

• For every node v ∈ V1, we replace the directed edge (1, v) with a path 1 → av,1 → ... → av,p → v by adding p

intermediate nodes. All edges on the path have weight 0.

• For every node v ∈ V2, we replace the directed edge (v, 2) with a path v → bv,1 → ... → bv,p → 2 by adding p

intermediate nodes. All edges on the path have weight 0.

• Finally, we replace the directed edge (2, 3) with a path 2 → c1 → ... → cZ → 3 by adding Z intermediate nodes,

where 2Z is a strict upper bound on the weight of any k-clique6. All edges on the path have weight 0.

We create an instance of the VITERBI PATH problem (A, B, S) as described below. Figure 2 illustrates the construction of
the instance.

• Matrix A is the weighted adjacency matrix of G(cid:48)(cid:48) that takes value +∞ (or a sufﬁciently large integer) for non-existent

edges and non-existent self-loops.

• The alphabet of the HMM is U1 ∪ ... ∪ Up ∪ {⊥, ⊥0, ⊥1, ⊥F } and thus matrix B has O(n) rows and σ = p · m + 4 =

O(nα) columns.
For all v ∈ V1, every i ∈ [p] and every u ∈ Ui, B(av,i, u) is equal to the weight of the edge (v, u) in graph G.
Similarly, for all v ∈ V2, every j ∈ [p] and every u ∈ Uj, B(bv,j, u) is equal to the weight of the edge (v, u) in graph
G.
Moreover, for all i ∈ {1, ..., Z}, B(ci, ⊥1) = 2i−1 and B(ci, ⊥0) = 0. Finally, B(v, ⊥) = +∞ for all nodes
v (cid:54)∈ {1, 3} while B(v, ⊥F ) = +∞ for all nodes v (cid:54)= 3. All remaining entries of matrix B are 0.

• Sequence S is generated by appending for every tuple (u1, ..., up) ∈ U1 × ... × Up the following observations in this
order: Initially we add the observations (u1, ..., up, ⊥0, ⊥0, u1, ..., up, ⊥0). Moreover, let W be the total weight of
the clique (u1, ..., up) in the graph G. We add Z observations encoding W in binary7 starting with the least signiﬁcant
bit. For example, if W = 11 and Z = 5, the binary representation is 010112 and the observations we add are
⊥1, ⊥1, ⊥0, ⊥1, ⊥0 in that order. Finally, we append a ⊥ observation at the end.
Notice, that for each tuple, we append exactly Z + 2p + 4 = Z + 2k observations. Thus, the total number of
observations is mp(Z + 2k). We add a ﬁnal ⊥F observation at the end and set T = mp(Z + 2k) + 1.

Size of graph G(cid:48)(cid:48) Since the edge-weights in the k-Clique conjecture are upper bounded by nO(k), the length of the path
2 → c1 → ... → cZ → 3 can be upper bounded by Z + 2 ≤ O(k log n). The length of every path 1 → av,1 → ... →
av,p → v or v → bv,1 → ... → bv,p → 2 is p + 2 = k. The number of vertices of G(cid:48)(cid:48) can now be upper bounded by
O(k log n + kn) ≤ O(n) since k = O(1).

Correctness of the reduction Since the MIN-WEIGHT k-CLIQUE instance requires
Ω (|V1| · |V2| · (cid:81)p
stances require Ω(T n2)1−o(1) time. The alphabet size used is at most O(nα) and α ≤ ε and the theorem follows.

i=1 |Ui|)1−o(1) = Ω(T n2)1−o(1) time, the following claim implies that the above VITERBI PATH in-

6A trivial such upper bound is k2 times the weight of the maximum edge.
7Since 2Z is a strict upper-bound on the clique size at most Z digits are required.

Improving Viterbi is Hard: Better Runtimes Imply Faster Clique Algorithms
V2

V1

wv1,v2

nodes av,i

0

1

0

0

0

0

0

0

0

0

0

0

nodes bv,i

0

0

0

0

0

0

0

0

0

0

2

c1

c2

cZ

3

0

Node
1
av,i for v ∈ V1
v ∈ V1 ∪ V2
bv,i for v ∈ V2
2
ci
3

u ∈ Uj
0
wu,v1i=j
0
wu,v1i=j
0
0
0

⊥0
0
0
0
0
0
0
0

⊥ ⊥F
⊥1
0 ∞
0
0 ∞ ∞
0 ∞ ∞
0 ∞ ∞
0 ∞ ∞
2i−1 ∞ ∞
0
0

0

Figure 2: The construction of matrices A and B for the reduction in the proof of Theorem 2.

Claim 2. The weight of the solution to the VITERBI PATH instance is equal to the minimum weight of a k-clique in the
graph G.

Proof. The optimal path for the VITERBI PATH instance begins at node 1. It must end in node 3 since otherwise when
observation ⊥F arrives we collect cost +∞. Similarly, whenever an observation ⊥ arrives the path must be either on node
1 or 3. Thus, the path ﬁrst loops in node 1 and then goes from node 1 to node 3 during the sequence of Z + 2k consecutive
observations corresponding to some tuple (u1, ..., up) ∈ U1 × ... × Up and stays in node 3 until the end. Let v1 and v2 be
the nodes in V1 and V2, respectively, that are visited when moving from node 1 to node 3. The only steps of non-zero cost
happen during the subsequence of observations corresponding to the tuple (u1, ..., up):

1. When the subsequence begins with u1, the path jumps to node av1,1 which has a cost B(av1,1, u1) equal to the edge-
weight (v1, u1) in graph G. It then continues on to nodes av1,2, ..., av1,p when seeing observations u2, ..., up. The
total cost of these steps is (cid:80)p

i=1 B(av1,i, ui) which is the total weight of edges (v1, u1), ..., (v1, up) in graph G.

2. For the next two observations ⊥0, ⊥0, the path jumps to nodes v1 and v2. The ﬁrst jump has no cost while the latter

has cost A(v1, v2) equal to the weight of the edge (v1, v2) in G.

3. The subsequence continues with observations u1, ..., up and the path jumps to nodes bv2,1, ..., bv2,p which has a total

cost (cid:80)p

i=1 B(bv2,i, ui) which is equal to the total weight of edges (v2, u1), ..., (v2, up) in graph G.

4. The path then jumps to node 2 at no cost at observation ⊥0.

5. The path then moves on to the nodes c1, ..., cZ. The total cost of those moves is equal to the total weight of the clique

(u1, ..., up) since the observations ⊥0 and ⊥1 that follow encode that weight in binary.

The overall cost of the path is exactly equal to the weight of the k-clique (v1, v2, u1, ..., up) in G. Minimizing the cost of
the path in this instance is therefore the same as ﬁnding the minimum weight k-clique in G.

B. Reduction from MIN-WEIGHT k-CLIQUE to MIN-WEIGHT k-CLIQUE in k-partite graphs

In this section, we show the following lemma using standard techniques.

Improving Viterbi is Hard: Better Runtimes Imply Faster Clique Algorithms

Lemma 1. Consider the MIN-WEIGHT k-CLIQUE problem in k-partite graphs G = (V1 ∪ . . . ∪ Vk, E) with |Vi| = ni.
If for all i, j we have that ni = nΘ(1)
, then the MIN-WEIGHT k-CLIQUE problem for this class of instances requires

j

(cid:16)(cid:81)k

Ω

i=1 ni

(cid:17)1−o(1)

time assuming the k-Clique conjecture.

Proof. Without loss of generality assume that n1 ≥ ni for all i and let n = n1. Assume, that there is an O ((cid:81)
i ni)1−ε
algorithm that ﬁnds a minimum weight k-clique in k-partite graphs with |Vi| = ni for all i. We can use this faster algorithm
to ﬁnd a k-clique in a graph G = (V, E) where |V | = n, as follows: Let V i be a partition of V into n
sets of size ni. For
ni
all (V1, . . . , Vk) ∈ V 1 × · · · × V k, we create a k-partite graph G(cid:48) = (V1 ∪ . . . ∪ Vk, E(cid:48)) by adding edges corresponding
to the edges of graph G between nodes across partitions and ﬁnd the minimum weight k-clique in the graph G(cid:48) using
the faster algorithm. Computing the minimum weight k-clique out of all the graphs we consider gives the solution to the
MIN-WEIGHT k-CLIQUE instance on G. The total runtime is (cid:81)k
= nk−Ω(ε) which would violate
the k-Clique conjecture. The previous equality holds because of the assumption that ni = nΘ(1)

i=1 ni

(cid:16)(cid:81)k

(cid:17)1−ε

· O

n
ni

i=1

.

j

C. Sum of Probabilities

In the deﬁnition of the additive version of VITERBI PATH, we didn’t impose any constraint on the weights. In the mul-
tiplicative version where weights correspond to probabilities, we have the restriction that probabilities of transition from
each vertex sum to 1.

To convert an instance IAdd of the additive VITERBI PATH formulation to an equivalent instance IM ul in the multiplicative
setting, we add a shift of log n to all entries of A and a shift of log T to entries of matrix B. This doesn’t change the optimal
solution but only changes its value by an additive shift of T log n + T log T . This transformation makes all probabilities
in the IM ul instance small enough such that transition probabilities sum to less than 1 and similarly probabilities of
outputting observations sum to less than 1. To handle the remaining probability, we introduce an additional node α and
an additional symbol γ in the alphabet of observations. Every original transitions to node α with its remaining transition
probability and outputs observation γ with its remaining transition probability. We require that node α outputs observation
γ with 100% probability. As we never observe γ in the sequence of observations, the optimal solution must never go
through node α and thus the optimal solution remains the same.

The transformation above requires introducing an additional symbol
reduction of
ALL-PAIRS SHORTEST PATHS to VITERBI PATH when σ = 1, we don’t want the alphabet to increase. We describe
an alternative transformation for σ = 1 that doesn’t introduce additional symbols. This case corresponds to the
SHORTEST WALK instance and matrix B is irrelevant.

in the alphabet.

For our

We ﬁrst scale all weights in matrices A, by dividing by some large weight W , so that all values are between 0 and 1 and then
add a shift of log n to all of them. This doesn’t change the optimal solution but only changes its value by a multiplicative
factor W and an additive shift of T log n. After this transformation all values are between log n and 1 + log n and thus the
corresponding probabilities in the IM ul instance are at most 1/n. This causes transition probabilities to sum to less than 1.
To assign the remaining probability, we introduce a clique of 4n additional nodes. All nodes in the clique have probability
1
4n of transition to any other node in the clique and 0 probability of transition to any of the original node. For every original
node, we spread its remaining transition probability evenly to the 4n nodes of the clique. It is easy to see that the optimal
solution to the VITERBI PATH problem will not change, as it is never optimal to visit any of the nodes in the clique. This is
because all edges in the original graph have weight at most 1 + log n while if a node in the clique is visited the path must
stay in the clique at a cost of 2 + log n per edge.

