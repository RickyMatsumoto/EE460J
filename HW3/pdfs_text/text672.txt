Tensor-Train Recurrent Neural Networks for Video Classiﬁcation

Yinchong Yang 1 2 Denis Krompass 2 Volker Tresp 1 2

Abstract
The Recurrent Neural Networks and their vari-
ants have shown promising performances in se-
quence modeling tasks such as Natural Language
Processing. These models, however, turn out to
be impractical and difﬁcult to train when exposed
to very high-dimensional inputs due to the large
input-to-hidden weight matrix. This may have
prevented RNNs’ large-scale application in tasks
that involve very high input dimensions such as
video modeling; current approaches reduce the
input dimensions using various feature extrac-
tors. To address this challenge, we propose a
new, more general and efﬁcient approach by fac-
torizing the input-to-hidden weight matrix using
Tensor-Train decomposition which is trained si-
multaneously with the weights themselves. We
test our model on classiﬁcation tasks using mul-
tiple real-world video datasets and achieve com-
petitive performances with state-of-the-art mod-
els, even though our model architecture is or-
ders of magnitude less complex. We believe
that the proposed approach provides a novel and
fundamental building block for modeling high-
dimensional sequential data with RNN architec-
tures and opens up many possibilities to transfer
the expressive and advanced architectures from
other domains such as NLP to modeling high-
dimensional sequential data.

1. Introduction

Nowadays, the Recurrent Neural Network (RNN), espe-
cially its more advanced variants such as the LSTM and
the GRU, belong to the most successful machine learning
approaches when it comes to sequence modeling. Espe-
cially in Natural Language Processing (NLP), great im-
provements have been achieved by exploiting these Neu-

1Ludwig Maximilian University of Munich, Germany
2Siemens AG, Corporate Technology, Germany. Correspondence
to: Yinchong Yang <yinchong.yang@siemens.com>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

ral Network architectures. This success motivates efforts
to also apply these RNNs to video data, since a video clip
could be seen as a sequence of image frames. However,
plain RNN models turn out to be impractical and difﬁcult to
train directly on video data due to the fact that each image
frame typically forms a relatively high-dimensional input,
which makes the weight matrix mapping from the input to
the hidden layer in RNNs extremely large. For instance,
in case of an RGB video clip with a frame size of say
160×120×3, the input vector for the RNN would already
be 57, 600 at each time step. In this case, even a small hid-
den layer consisting of only 100 hidden nodes would lead
to 5,760,000 free parameters, only considering the input-
to-hidden mapping in the model.

In order to circumvent this problem, state-of-the-art ap-
proaches often involve pre-processing each frame using
Convolution Neural Networks (CNN), a Neural Network
model proven to be most successful in image modeling.
The CNNs do not only reduce the input dimension, but
can also generate more compact and informative represen-
tations that serve as input to the RNN. Intuitive and tempt-
ing as it is, training such a model from scratch in an end-
to-end fashion turns out to be impractical for large video
datasets. Thus, many current works following this concept
focus on the CNN part and reduce the size of RNN in term
of sequence length (Donahue et al., 2015; Srivastava et al.,
2015), while other works exploit pre-trained deep CNNs as
pre-processor to generate static features as input to RNNs
(Yue-Hei Ng et al., 2015; Donahue et al., 2015; Sharma
et al., 2015). The former approach neglects the capabil-
ity of RNNs to handle sequences of variable lengths and
therefore does not scale to larger, more realistic video data.
The second approach might suffer from suboptimal weight
parameters by not being trained end-to-end (Fernando &
Gould, 2016). Furthermore, since these CNNs are pre-
trained on existing image datasets, it remains unclear how
well the CNNs can generalize to video frames that could be
of totally different nature from the image training sets.

Alternative approaches were earlier applied to generate im-
age representations using dimension reductions such as
PCA (Zhang et al., 1997; Kambhatla & Leen, 1997; Ye
et al., 2004) and Random Projection (Bingham & Mannila,
2001). Classiﬁers were built on such features to perform
object and face recognition tasks. These models, however,

Tensor-Train Recurrent Neural Networks for Video Classiﬁcation

are often restricted to be linear and cannot be trained jointly
with the classiﬁer.

2. Related Works

In this work, we pursue a new direction where the RNN
is exposed to the raw pixels on each frame without any
CNN being involved. At each time step, the RNN ﬁrst
maps the large pixel input to a latent vector in a typically
much lower dimensional space. Recurrently, each latent
vector is then enriched by its predecessor at the last time
In this way, the
step with a hidden-to-hidden mapping.
RNN is expected to capture the inter-frame transition pat-
terns to extract the representation for the entire sequence of
frames, analogous to RNNs generating a sentence represen-
tation based on word embeddings in NLP (Sutskever et al.,
2014). In comparison with other mapping techniques, a di-
rect input-to-hidden mapping in an RNN has several advan-
tages. First it is much simpler to train than deep CNNs in an
end-to-end fashion. Secondly it is exposed to the complete
pixel input without the linear limitation as PCA and Ran-
dom Projection. Thirdly and most importantly, since the
input-to-hidden and hidden-to-hidden mappings are trained
jointly, the RNN is expected to capture the correlation be-
tween spatial and temporal patterns.

To address the issue of having too large of a weight ma-
trix for the input-to-hidden mapping in RNN models, we
propose to factorize the matrix with the Tensor-Train de-
composition (Oseledets, 2011). In (Novikov et al., 2015)
the Tensor-Train has been applied to factorize a fully-
connected feed-forward layer that can consume image pix-
els as well as latent features. We conducted experiments
on three large-scale video datasets that are popular bench-
marks in the community, and give empirical proof that the
proposed approach makes very simple RNN architectures
competitive with the state-of-the-art models, even though
they are of several orders of magnitude lower complexity.

The rest of the paper is organized as follows: In Section
2 we summarize the state-of-the-art works, especially in
video classiﬁcation using Neural Network models and the
tensorization of weight matrices. In Section 3 we ﬁrst in-
troduce the Tensor-Train model and then provide a detailed
derivation of our proposed Tensor-Train RNNs. In Section
4 we present our experimental results on three large scale
video datasets. Finally, Section 5 serves as a wrap-up of
our current contribution and provides an outlook of future
work.

Notation We index an entry in a d-dimensional ten-
sor A ∈ Rp1×p2×...×pd using round parentheses such as
A(l1, l2, ..., ld) ∈ R and A(l1) ∈ Rp2×p3×...×pd , when
we only write the ﬁrst index. Similarly, we also use
A(l1, l2) ∈ Rp3×p4×...×pd to refer to the sub-tensor speci-
ﬁed by two indices l1 and l2.

The current approaches to model video data are closely re-
lated to models for image data. A large majority of these
works use deep CNNs to process each frame as image,
(Karpathy et al., 2014)
and aggregate the CNN outputs.
proposes multiple fusion techniques such as Early, Late
and Slow Fusions, covering different aspects of the video.
This approach, however, does not fully take the order of
frames into account. (Yue-Hei Ng et al., 2015) and (Fer-
nando & Gould, 2016) apply global pooling of frame-wise
CNNs, before feeding the aggregated information to the ﬁ-
nal classiﬁer. An intuitive and appealing idea is to fuse
these frame-wise spatial representations learned by CNNs
using RNNs. The major challenge, however, is the com-
putation complexity; and for this reason multiple compro-
mises in the model design have to be made: (Srivastava
et al., 2015) restricts the length of the sequences to be 16,
while (Sharma et al., 2015) and (Donahue et al., 2015) use
pre-trained CNNs. (Shi et al., 2015) proposed a more com-
pact solution that applies convolutional layers as input-to-
hidden and hidden-to-hidden mapping in LSTM. However,
they did not show its performance on large-scale video
data. (Simonyan & Zisserman, 2014) applied two stacked
CNNs, one for spatial features and the other for temporal
ones, and fused the outcomes of both using averaging and a
Support-Vector Machine as classiﬁer. This approach is fur-
ther enhanced with Residual Networks in (Feichtenhofer
et al., 2016). To the best of our knowledge, there has been
no published work on applying pure RNN models to video
classiﬁcation or related tasks.

The Tensor-Train was ﬁrst introduced by (Oseledets, 2011)
as a tensor factorization model with the advantage of being
capable of scaling to an arbitrary number of dimensions.
(Novikov et al., 2015) showed that one could reshape a
fully connected layer into a high-dimensional tensor and
then factorize this tensor using Tensor-Train. This was ap-
plied to compress very large weight matrices in deep Neu-
ral Networks where the entire model was trained end-to-
end. In these experiments they compressed fully connected
layers on top of convolution layers, and also proved that a
Tensor-Train Layer can directly consume pixels of image
data such as CIFAR-10, achieving the best result among all
known non-convolutional models. Then in (Garipov et al.,
2016) it was shown that even the convolutional layers them-
selves can be compressed with Tensor-Train Layers. Actu-
ally, in an earlier work by (Lebedev et al., 2014) a similar
approach had also been introduced, but their CP factoriza-
tion is calculated in a pre-processing step and is only ﬁne
tuned with error back propagation as a post processing step.

(Koutnik et al., 2014) performed two sequence classiﬁca-
tion tasks using multiple RNN architectures of relatively
low dimensionality: The ﬁrst task was to classify spoken

Tensor-Train Recurrent Neural Networks for Video Classiﬁcation

words where the input sequence had a dimension of 13
channels. In the second task, RNNs were trained to clas-
sify handwriting based on the time-stamped 4D spatial fea-
tures. RNNs have been also applied to classify the sen-
timent of a sentence such as in the IMDB reviews dataset
(Maas et al., 2011). In this case, the word embeddings form
the input to RNN models and they may have a dimension of
a few hundreds. The sequence classiﬁcation model can be
seen as a special case of the Encoder-Decoder-Framework
(Sutskever et al., 2014) in the sense that a classiﬁer decodes
the learned representation for the entire sequence into a
probabilistic distribution over all classes.

3. Tensor-Train RNN

In this section, we ﬁrst give an introduction to the core in-
gredient of our proposed approach, i.e., the Tensor-Train
Factorization, and then use this to formulate a so-called
Tensor-Train Layer (Novikov et al., 2015) which replaces
the weight matrix mapping from the input vector to the hid-
den layer in RNN models. We emphasize that such a layer
is learned end-to-end, together with the rest of the RNN in
a very efﬁcient way.

3.1. Tensor-Train Factorization

A Tensor-Train Factorization (TTF) is a tensor factoriza-
tion model that can scale to an arbitrary number of dimen-
sions. Assuming a d-dimensional target tensor of the form
A ∈ Rp1×p2×...×pd , it can be factorized in form of:

(cid:98)A(l1, l2, ..., ld) T T F= G1(l1) G2(l2) ... Gd(ld)

(1)

where

Gk ∈ Rpk×rk−1×rk , lk ∈ [1, pk] ∀k ∈ [1, d]
and r0 = rd = 1.

(2)

As Eq. 1 suggests, each entry in the target tensor is rep-
resented as a sequence of matrix multiplications. The
set of tensors {Gk}d
k=1 are usually called core-tensors.
The complexity of the TTF is determined by the ranks
[r0, r1, ..., rd]. We demonstrate this calculation also in Fig.
1. Please note that the dimensions and core-tensors are in-
dexed from 1 to d while the rank index starts from 0; also
note that the ﬁrst and last ranks are both restricted to be 1,
which implies that the ﬁrst and last core tensors can be seen
as matrices so that the outcome of the chain of multiplica-
tions in Eq. 1 is always a scalar.

If one imposes the constraint that each integer pk as in Eq.
(1) can be factorized as pk = mk · nk ∀k ∈ [1, d], and con-
sequently reshapes each Gk into G∗
k ∈ Rmk×nk×rk−1×rk ,
then each index lk in Eq. (1) and (2) can be uniquely rep-

Figure 1: Tensor-Train Factorization Model: To reconstruct
one entry in the target tensor, one performs a sequence of
vector-matrix-vector multiplications, yielding a scalar.

resented with two indices (ik, jk), i.e.

ik = (cid:98)

(cid:99), jk = lk − nk(cid:98)

lk
nk

lk
nk

(cid:99),

so that Gk(lk) = G∗

k(ik, jk) ∈ Rrk−1×rk .

the factorization for the tensor A ∈
Correspondingly,
R(m1·n1)×(m2·n2)×...×(md·nd) can be rewritten equiva-
lently to Eq.(1):

(cid:98)A((i1, j1), (i2, j2), ..., (id, jd))

T T F= G∗

1(i1, j1) G∗

2(i2, j2) ... G∗

d(id, jd).

This double index trick (Novikov et al., 2015) enables the
factorizing of weight matrices in a feed-forward layer as
described next.

3.2. Tensor-Train Factorization of a Feed-Forward

Layer

Here we factorize the weight matrix W of a fully-
connected feed-forward layer denoted in ˆy = W x + b.

First we rewrite this layer in an equivalent way with scalars
as:

ˆy(j) =

W (i, j) · x(i) + b(j)

M
(cid:88)

i=1

∀j ∈ [1, N ] and with x ∈ RM , y ∈ RN .

Then,
(cid:81)d

k=1 nk i.e.

if we assume that M = (cid:81)d

k=1 mk, N =
both M and N can be factorized into
two integer arrays of the same length, then we can re-
shape the input vector x and the output vector ˆy into
two tensors with the same number of dimensions: X ∈
Rm1×m2×...×md , Y ∈ Rn1×n2×...×nd , and the mapping
function Rm1×m2×...×md → Rn1×n2×...×nd can be writ-
ten as:

(cid:98)Y(j1, j2, ..., jd)
m1(cid:88)

m2(cid:88)

=

md(cid:88)

...

W((i1, j1), (i2, j2), ..., (id, jd))·

i2=1

i1=1
X (i1, i2, ..., id) + B(j1, j2, ..., jd).

id=1

(3)

(4)

(5)

(6)

(7)

rk-1 pk rk    ...      l1 l2 l3 ld-1 ld Tensor-Train Recurrent Neural Networks for Video Classiﬁcation

Note that Eq. (6) can be seen as a special case of Eq. (7)
with d = 1. The d-dimensional double-indexed tensor of
weights W in Eq.(7) can be replaced by its TTF represen-
tation:

(cid:99)W((i1, j1), (i2, j2), ..., (id, jd))
T T F= G∗
2(i2, j2) ... G∗

1(i1, j1) G∗

d(id, jd).

(8)

Now instead of explicitly storing the full tensor W of size
(cid:81)d
k=1 mk·nk = M ·N , we only store its TT-format, i.e., the
k=1 mk ·

set of low-rank core tensors {Gk}d
nk · rk−1 · rk, which can approximately reconstruct W.

k=1 of size (cid:80)d

The forward pass complexity (Novikov et al., 2015) for one
scalar in the output vector indexed by (j1, j2, ..., jd) turns
out to be O(d· ˜m· ˜r2). Since one needs an iteration through
all such tuples, yielding O(˜nd), the total complexity for
one Feed-Forward-Pass can be expressed as O(d · ˜m · ˜r2 ·
˜nd), where ˜m = maxk∈[1,d] mk, ˜n = maxk∈[1,d] nk, ˜r =
maxk∈[1,d] rk. This, however, would be O(M · N ) for a
fully-connected layer.

One could also compute the compression rate as the ratio
between the number of weights in a fully connected layer
and that in its compressed form as:

(cid:80)d

r =

k=1 mknkrk−1rk
(cid:81)d
k=1 mknk

.

(9)

For instance, an RGB frame of size 160 × 120 × 3 implies
an input vector of length 57,600. With a hidden layer of
size, say, 256 one would need a weight matrix consisting
of 14,745,600 free parameters. On the other hand, a TTL
that factorizes the input dimension with 8×20×20×18 is
able to represent this matrix using 2,976 parameters with
a TT-rank of 4, or 4,520 parameters with a TT-rank of 5
(Tab. 1), yielding compression rates of 2.0e-4 and 3.1e-4,
respectively.

For the rest of the paper, we term a fully-connected layer
in form of ˆy = W x + b, whose weight matrix W is fac-
torized with TTF, a Tensor-Train Layer (TTL) and use the
notation

ˆy = T T L(W , b, x), or T T L(W , x)

(10)

where in the second case no bias is required. Please also
note that, in contrast to (Lebedev et al., 2014) where the
weight tensor is ﬁrstly factorized using non-linear Least-
Square method and then ﬁne-tuned with Back-Propagation,
the TTL is always trained end-to-end. For details on the
gradients calculations please refer to Section 5 in (Novikov
et al., 2015).

3.3. Tensor-Train RNN

In this work we investigate the challenge of modeling high-
dimensional sequential data with RNNs. For this reason,

we factorize the matrix mapping from the input to the hid-
den layer with a TTL. For an Simple RNN (SRNN), which
is also known as the Elman Network, this mapping is re-
alized as a vector-matrix multiplication, whilst in case of
LSTM and GRU, we consider the matrices that map from
the input vector to the gating units:

r[t] = σ(T T L(W r, x[t]) + U rh[t−1] + br)
z[t] = σ(T T L(W z, x[t]) + U zh[t−1] + bz)
d[t] = tanh(T T L(W d, x[t]) + U d(r[t] ◦ h[t−1]))
h[t] = (1 − z[t]) ◦ h[t−1] + z[t] ◦ d[t],

(11)

TT-GRU:

TT-LSTM:

k[t] = σ(T T L(W k, x[t]) + U kh[t−1] + bk)
f [t] = σ(T T L(W f , x[t]) + U f h[t−1] + bf )
o[t] = σ(T T L(W o, x[t]) + U oh[t−1] + bo)
g[t] = tanh(T T L(W g, x[t]) + U gh[t−1] + bg)
c[t] = f [t] ◦ c[t−1] + k[t] ◦ g[t]
h[t] = o[t] ◦ tanh(c[t]).

(12)

One can see that LSTM and GRU require 4 and 3 TTLs,
respectively, one for each of the gating units. Instead of
calculating these TTLs successively (which we call vanilla
TT-LSTM and vanilla TT-GRU), we increase n1 —the ﬁrst
1 of the factors that form the output size N = (cid:81)d
k=1 nk
in a TTL— by a factor of 4 or 3, and concatenate all the
gates as one output tensor, thus parallelizing the computa-
tion. This trick, inspired by the implementation of standard
LSTM and GRU in (Chollet, 2015), can further reduce the
number of parameters, where the concatenation is actually
participating in the tensorization. The compression rate for
the input-to-hidden weight matrix W now becomes

(cid:80)d

r∗ =

k=1 mknkrk−1rk + (c − 1)(m1n1r0r1)
k=1 mknk

c · (cid:81)d

(13)

where c = 4 in case of LSTM and 3 in case of GRU,

and one can show that r∗ is always smaller than r as in Eq.
9. For the former numerical example of a input frame size
160×120×3, a vanilla TT-LSTM would simply require 4
times as many parameters as a TTL, which would be 11,904
for rank 4 and 18,080 for rank 5. Applying this trick would,
however, yield only 3,360 and 5,000 parameters for both
ranks, respectively. We cover other possible settings of this
numerical example in Tab. 1.

Finally to construct the classiﬁcation model, we denote
the i-th sequence of variable length Ti as a set of vectors

1Though in theory one could of course choose any nk.

Tensor-Train Recurrent Neural Networks for Video Classiﬁcation

Table 1: A numerical example of compressing with TT-RNNs. Assuming that an input dimension of 160×120×3 is
factorized as 8 × 20 × 20 × 18 and the hidden layer as 4 × 4 × 4 × 4 = 256, depending on the TT-ranks we calculate the
number of parameters necessary for a Fully-Connected (FC) layer, a TTL which is equivalent to TT-SRNN , TT-LSTM and
TT-GRU in their respective vanilla and parallelized form. For comparison, typical CNNs for preprocessing images such as
AlexNet (Krizhevsky et al., 2012; Han et al., 2015) or GoogLeNet (Szegedy et al., 2015) consist of over 61 and 6 million
parameters, respectively.

FC

14,745,600

TT-ranks
3
4
5

TTL
1,752
2,976
4,520

vanilla TT-LSTM TT-LSTM vanilla TT-GRU TT-GRU
1,944
3,232
4,840

5,256
8,928
13,560

7,008
11,904
18,080

2,040
3,360
5,000

i }Ti

t=1 with x[t]

i ∈ RM ∀t. For video data each x[t]
{x[t]
would be an RGB frame of 3 dimensions. For the sake of
simplicity we denote an RNN model, either with or without
TTL, with a function f (·):

i

i = f ({x[t]
h[Ti]

i }Ti

t=1), where h[Ti]

i ∈ RN ,

(14)

which outputs the last hidden layer vector h[Ti]
out of a
sequential input of variable length. This vector can be in-
terpreted as a latent representation of the whole sequence,
on top of which a parameterized classiﬁer φ(·) with either
softmax or logistic activation produces the distribution over
all J classes:

i

i }Ti

P(yi = 1|{x[t]

t=1) = φ(h[Ti]
)
i
= φ(f (x[t]
i }Ti
The model is also illustrated in Fig. 2:

t=1)) ∈ [0, 1]J ,

(15)

4. Experiments

In the following, we present our experiments conducted on
three large video datasets. These empirical results demon-
strate that the integration of the Tensor-Train Layer in plain
RNN architectures such as a tensorized LSTM or GRU
boosts the classiﬁcation quality of these models tremen-
dously when directly exposed to high-dimensional input
data, such as video data. In addition, even though the plain
architectures are of very simple nature and very low com-
plexity opposed to the state-of-the-art solutions on these
datasets, it turns out that the integration of the Tensor-Train
Layer alone makes these simple networks very competitive
to the state-of-the-art, reaching second best results in all
cases.

UCF11 Data (Liu et al., 2009)
We ﬁrst conduct experiments on the UCF11 – earlier
known as the YouTube Action Dataset. It contains in to-
tal 1600 video clips belonging to 11 classes that summa-
rize the human action visible in each video clip such as
basketball shooting, biking, diving etc.. These videos orig-
inate from YouTube and have natural background (’in the

wild’) and a resolution of 320 × 240. We generate a se-
quence of RGB frames of size 160 × 120 from each clip at
an fps(frame per second) of 24, corresponding to the stan-
dard value in ﬁlm and television production. The lengths of
frame sequences vary therefore between 204 to 1492 with
an average of 483.7.

Figure 3: Two samples of frame sequences from the UCF11
dataset. The two rows belong to the classes of basketball
shooting and volleyball spiking, respectively.

For both the TT-GRUs and TT-LSTMs the input dimension
at each time step is 160 × 120 × 3 = 57600 which is fac-
torized as 8 × 20 × 20 × 18, the hidden layer is chosen to
be 4 × 4 × 4 × 4 = 256 and the Tensor-Train ranks are
[1, 4, 4, 4, 1]. A fully-connected layer for such a mapping
would have required 14,745,600 parameters to learn, while
the input-to-hidden layer in TT-GRU and TT-LSTM consist
of only 3,360 and 3,232, respectively.

As the ﬁrst baseline model we sample 6 random frames in
ascending order. The model is a simple Multilayer Percep-
tron (MLP) with two layers of weight matrices, the ﬁrst of
which being a TTL. The input is the concatenation of all
6 ﬂattened frames and the hidden layer is of the same size
as the hidden layer in TT-RNNs. We term this model as
Tensor-Train Multilayer Perceptron (TT-MLP) for the rest
of the paper. As the second baseline model we use plain
GRUs and LSTMs that have the same size of hidden layer
as their TT pendants. We follow (Liu et al., 2013) and per-
form for each experimental setting a 5-fold cross validation
with mutual exclusive data splits. The mean and standard
deviation of the prediction accuracy scores are reported in
Tab. 2.

Tensor-Train Recurrent Neural Networks for Video Classiﬁcation

Figure 2: Architecture of the proposed model based on TT-RNN (For illustrative purposes we only show 6 frames): A
softmax or sigmoid classiﬁer built on the last hidden layer of a TT-RNN. We hypothesize that the RNN can be encouraged
to aggregate the representations of different shots together and produce a global representation for the whole sequence.

Table 2: Experimental Results on UCF11 Dataset. We re-
port i) the accuracy score, ii) the number of parameters in-
volved in the input-to-hidden mapping in respective models
and iii) the average runtime of each training epoch. The
models were trained on a Quad core Intel R(cid:13)Xeon R(cid:13)E7-
4850 v2 2.30GHz Processor to a maximum of 100 epochs

Accuracy
0.427 ± 0.045
TT-MLP
0.488 ± 0.033
GRU
0.492 ± 0.026
LSTM
0.813 ± 0.011
TT-GRU
TT-LSTM 0.796 ± 0.035

# Parameters Runtime
902s
7,056s
8,892s
1,872s
2,160s

7,680
44,236,800
58,982,400
3,232
3,360

The standard LSTM and GRU do not show large improve-
ments compared with the TT-MLP model. The TT-LSTM
and TT-GRU, however, do not only compress the weight
matrix from over 40 millions to 3 thousands, but also sig-
niﬁcantly improve the classiﬁcation accuracy.
It seems
that plain LSTM and GRU are not adequate to model
such high-dimensional sequential data because of the large
weight matrix from input to hidden layer. Compared to
some latest state-of-the-art performances in Tab. 3, our
model —simple as it is— shows accuracy scores second to
(Sharma et al., 2015), which uses pre-trained GoogLeNet
CNNs plus 3-fold stacked LSTM with attention mecha-
nism. Please note that a GoogLeNet CNN alone consists of
over 6 million parameters (Szegedy et al., 2015). In term of
runtime, the plain GRU and LSTM took on average more
than 8 and 10 days to train, respectively; while the TT-
GRU and TT-LSTM both approximately 2 days. Therefore
please note the TTL reduces the training time by a factor of
4 to 5 on these commodity hardwares.

Table 3: State-of-the-art results on the UCF11 Dataset, in
comparison with our best model. Please note that there was
an update of the data set on 31th December 2011. We there-
fore only consider works posterior to this date.

Original: (Liu et al., 2009)
(Liu et al., 2013)
(Hasan & Roy-Chowdhury, 2014)
(Sharma et al., 2015)
Our best model (TT-GRU)

0.712
0.761
0.690
0.850
0.813

Hollywood2 Data (Marszałek et al., 2009)
The Hollywood2 dataset contains video clips from 69
movies, from which 33 movies serve as training set and
36 movies as test set. From these movies 823 training clips
and 884 test clips are generated and each clip is assigned
one or multiple of 12 action labels such as answering the
phone, driving a car, eating or ﬁghting a person. This data
set is much more realistic and challenging since the same
action could be performed in totally different style in front
of different background in different movies. Furthermore,
there are often montages, camera movements and zooming
within a single clip.

The original frame sizes of the videos vary, but based on
the majority of the clips we generate frames of size 234
× 100, which corresponds to the Anamorphic Format, at
fps of 12. The length of training sequences varies from 29
to 1079 with an average of 134.8; while the length of test
sequences varies from 30 to 1496 frames with an average
of 143.3.

The input dimension at each time step, being 234 × 100 ×
3 = 70200, is factorized as 10 × 18 × 13 × 30. The hidden
layer is still 4 × 4 × 4 × 4 = 256 and the Tensor-Train
ranks are [1, 4, 4, 4, 1]. Since each clip might have more

               Fully-Connected Weights                TTL-Weights  x[0] x[1] x[2] x[3] x[4] x[5] Softmax/Sigmoid Classifier for y h[0] h[1] h[2] h[3] h[4] h[5]                    Representation for the car  Representation for the getting-out action   Tensor-Train Recurrent Neural Networks for Video Classiﬁcation

LSTM/GRU, which highlights the signiﬁcant performance
improvements the Tensor-Train Layer contributes to the
RNN models.

It is also to note that, although the plain LSTM and GRU
consist of up to approximately 23K as many parameters as
their TT modiﬁcations do, the training time does not reﬂect
such discrepancy due to the good parallelization power of
GPUs. However, the obvious difference in their training
qualities conﬁrms that training larger models may require
larger amounts of data. In such cases, powerful hardwares
are no guarantee for successful training.

Table 5: State-of-the-art Results on Hollywood2 Dataset,
in comparison with our best model.

Original: (Marszałek et al., 2009)
(Le et al., 2011)
(Jain et al., 2013)
(Sharma et al., 2015)
(Fernando et al., 2015)
(Fernando & Gould, 2016)
Our best model (TT-LSTM)

0.326
0.533
0.542
0.439
0.720
0.406
0.546

Youtube Celebrities Face Data (Kim et al., 2008)
This dataset consists of 1910 Youtube video clips of 47
prominent individuals such as movie stars and politicians.
In the simplest cases, where the face of the subject is visi-
ble as a long take, a mere frame level classiﬁcation would
sufﬁce. The major challenge, however, is posed by the fact
that some videos involve zooming and/or changing the an-
gle of view. In such cases a single frame may not provide
enough information for the classiﬁcation task and we be-
lieve it is advantageous to apply RNN models that can ag-
gregate frame level information over time.

Figure 4: Two samples of frame sequences from the Holly-
wood2 dataset. The ﬁrst sequence (row 1 and 2) belongs to
the class of sitting down; the second sequence (row 3 and
4) has two labels: running and ﬁghting person.

than one label (multi-class multi-label problem) we imple-
ment a logistic activated classiﬁer for each class on top of
the last hidden layer. Following (Marszałek et al., 2009) we
measure the performances using Mean Average Precision
across all classes, which corresponds to the Area-Under-
Precision-Recall-Curve.

As before we conduct experiments on this dataset using the
plain LSTM, GRU and their respective TT modiﬁcations.
The results are presented in in Tab. 4 and state-of-the-art in
Tab. 5.

Table 4: Experimental Results on Hollywood2 Dataset. We
report i) the Mean Average Precision score, ii) the num-
ber of parameters involved in the input-to-hidden mapping
in respective models and iii) the average runtime of each
training epoch. The models were trained on an NVIDIA
Tesla K40c Processor to a maximum of 500 epochs.

MAP
0.103
TT-MLP
0.249
GRU
0.108
LSTM
TT-GRU
0.537
TT-LSTM 0.546

# Parameters Runtime
16s
106s
179s
96s
102s

4,352
53,913,600
71,884,800
2,944
3,104

(Fernando et al., 2015) and (Jain et al., 2013) use im-
proved trajectory features with Fisher encoding (Wang &
Schmid, 2013) and Histogram of Optical Flow (HOF) fea-
tures (Laptev et al., 2008), respectively, and achieve so
(Sharma et al., 2015) and (Fernando
far the best score.
& Gould, 2016) provide best scores achieved with Neu-
ral Network models but only the latter applies end-to-
end training. To this end, the TT-LSTM model provides
the second best score in general and the best score with
Neural Network models, even though it merely replaces
the input-to-hidden mapping with a TTL. Please note the
large difference between the plain LSTM/GRU and the TT-

Figure 5: Two samples of frame sequences from the
Youtube Celebrities Face dataset. The two rows belong to
the classes of Al Pacino and Emma Thompson.

The original frame sizes of the videos vary but based on
the majority of the clips we generate frames of size 160
× 120 at fps of 12. The retrieved sequences have lengths
varying from 2 to 85 with an average of 39.9. The input
dimension at each time step is 160 × 120 × 3 = 57600
which is factorized as 4 × 20 × 20 × 36, the hidden layer is
again 4 × 4 × 4 × 4 = 256 and the Tensor-Train ranks are

Tensor-Train Recurrent Neural Networks for Video Classiﬁcation

[1, 4, 4, 4, 1].

Table 6: Experimental Results on Youtube Celebrities Face
Dataset. We report i) the Accuracy score, ii) the number of
parameters involved in the input-to-hidden mapping in re-
spective models and iii) the average runtime of each train-
ing epoch. The models were trained on an NVIDIA Tesla
K40c Processor to a maximum of 100 epochs.

Accuracy
0.512 ± 0.057
TT-MLP
0.342 ± 0.023
GRU
0.332 ± 0.033
LSTM
0.800 ± 0.018
TT-GRU
TT-LSTM 0.755 ± 0.033

# Parameters Runtime
14s
212s
253s
72s
81s

3,520
38,880,000
51,840,000
3,328
3,392

As expected, the baseline of TT-MLP model tends to per-
form well on the simpler video clips where the position
of the face remains less changed over time, and can even
outperform the plain GRU and LSTM. The TT-GRU and
TT-LSTM, on the other hand, provide accuracy very close
to the best state-of-the-art model (Tab. 7) using Mean Se-
quence Sparse Representation-based Classiﬁcation (Ortiz
et al., 2013) as feature extraction.

Table 7: State-of-the-art Results on Youtube Celebrities
Face Dataset, in comparison with our best model.

Original: (Kim et al., 2008)
(Harandi et al., 2013)
(Ortiz et al., 2013)
(Faraki et al., 2016)
Our best model (TT-GRU)

0.712
0.739
0.808
0.728
0.800

Experimental Settings
We applied 0.25 Dropout (Srivastava et al., 2014) for both
input-to-hidden and hidden-to-hidden mappings in plain
GRU and LSTM as well as their respective TT modiﬁca-
tions; and 0.01 ridge regularization for the single-layered
classiﬁer.
The models were implemented in Theano
(Bastien et al., 2012) and deployed in Keras (Chollet,
2015). We used the Adam (Kingma & Ba, 2014) step rule
for the updates with an initial learning rate 0.001.

5. Conclusions and Future Work

We proposed to integrate Tensor-Train Layers into Recur-
rent Neural Network models including LSTM and GRU,
which enables them to be trained end-to-end on high-
dimensional sequential data. We tested such integration
on three large-scale realistic video datasets. In comparison
to the plain RNNs, which performed very poorly on these
video datasets, we could empirically show that the integra-
tion of the Tensor-Train Layer alone signiﬁcantly improves

the modeling performances. In contrast to related works
that heavily rely on deep and large CNNs, one advantage of
our classiﬁcation model is that it is simple and lightweight,
reducing the number of free parameters from tens of mil-
lions to thousands. This would make it possible to train
and deploy such models on commodity hardware and mo-
bile devices. On the other hand, with signiﬁcantly less free
parameters, such tensorized models can be expected to be
trained with much less labeled data, which are quite expen-
sive in the video domain.

More importantly, we believe that our approach opens up
a large number of possibilities to model high-dimensional
sequential data such as videos using RNNs directly. In spite
of its success in modeling other sequential data such as nat-
ural language, music data etc., RNNs have not been applied
to video data in a fully end-to-end fashion, presumably due
to the large input-to-hidden weight mapping. With TT-
RNNs that can directly consume video clips on the pixel
level, many RNN-based architectures that are successful in
other applications, such as NLP, can be transferred to mod-
eling video data: one could implement an RNN autoen-
coder that can learn video representations similar to (Sri-
vastava et al., 2015), an Encoder-Decoder Network (Cho
et al., 2014) that can generate captions for videos similar
to (Donahue et al., 2015), or an attention-based model that
can learn on which frame to allocate the attention in order
to improve the classiﬁcation.

We believe that the TT-RNN provides a fundamental build-
ing block that would enable the transfer of techniques from
ﬁelds, where RNNs have been very successful, to ﬁelds
that deal with very high-dimensional sequence data –where
RNNs have failed in the past.

The source codes of our TT-RNN implementations and all
the experiments in Sec. 4 are publicly available at https:
//github.com/Tuyki/TT_RNN. In addition, we also
provide codes of unit tests, simulation studies as well as
experiments performed on the HMDB51 dataset (Kuehne
et al., 2011).

References

Bastien, Fr´ed´eric, Lamblin, Pascal, Pascanu, Razvan,
Bergstra, James, Goodfellow, Ian J., Bergeron, Arnaud,
Bouchard, Nicolas, and Bengio, Yoshua. Theano: new
features and speed improvements. Deep Learning and
Unsupervised Feature Learning NIPS 2012 Workshop,
2012.

Bingham, Ella and Mannila, Heikki. Random projection in
dimensionality reduction: applications to image and text
data. In Proceedings of the seventh ACM SIGKDD inter-
national conference on Knowledge discovery and data
mining, pp. 245–250. ACM, 2001.

Tensor-Train Recurrent Neural Networks for Video Classiﬁcation

Cho, Kyunghyun, Van Merri¨enboer, Bart, Bahdanau,
Dzmitry, and Bengio, Yoshua. On the properties of neu-
ral machine translation: Encoder-decoder approaches.
arXiv preprint arXiv:1409.1259, 2014.

Chollet, Franc¸ois. Keras: Deep learning library for
https://github.com/

theano and tensorﬂow.
fchollet/keras, 2015.

Donahue, Jeffrey, Anne Hendricks, Lisa, Guadarrama,
Sergio, Rohrbach, Marcus, Venugopalan, Subhashini,
Saenko, Kate, and Darrell, Trevor. Long-term recur-
rent convolutional networks for visual recognition and
In Proceedings of the IEEE Conference
description.
on Computer Vision and Pattern Recognition, pp. 2625–
2634, 2015.

Faraki, Masoud, Harandi, Mehrtash T, and Porikli, Fatih.
Image set classiﬁcation by symmetric positive semi-
In Applications of Computer Vision
deﬁnite matrices.
(WACV), 2016 IEEE Winter Conference on, pp. 1–8.
IEEE, 2016.

Feichtenhofer, Christoph, Pinz, Axel, and Wildes, Richard.
Spatiotemporal residual networks for video action recog-
In Advances in Neural Information Processing
nition.
Systems, pp. 3468–3476, 2016.

Fernando, Basura and Gould, Stephen. Learning end-to-
In Proc.
end video classiﬁcation with rank-pooling.
of the International Conference on Machine Learning
(ICML), 2016.

Fernando, Basura, Gavves, Efstratios, Oramas, Jose M,
Ghodrati, Amir, and Tuytelaars, Tinne. Modeling video
In Proceedings of
evolution for action recognition.
the IEEE Conference on Computer Vision and Pattern
Recognition, pp. 5378–5387, 2015.

Garipov, Timur, Podoprikhin, Dmitry, Novikov, Alexander,
and Vetrov, Dmitry. Ultimate tensorization: compress-
ing convolutional and fc layers alike. arXiv preprint
arXiv:1611.03214, 2016.

Han, Song, Pool, Jeff, Tran, John, and Dally, William.
Learning both weights and connections for efﬁcient neu-
ral network. In Advances in Neural Information Process-
ing Systems, pp. 1135–1143, 2015.

Harandi, Mehrtash, Sanderson, Conrad, Shen, Chunhua,
and Lovell, Brian C. Dictionary learning and sparse
coding on grassmann manifolds: An extrinsic solution.
In Proceedings of the IEEE International Conference on
Computer Vision, pp. 3120–3127, 2013.

Hasan, Mahmudul and Roy-Chowdhury, Amit K.

Incre-
mental activity modeling and recognition in streaming
In Proceedings of the IEEE Conference on
videos.

Computer Vision and Pattern Recognition, pp. 796–803,
2014.

Jain, Mihir, Jegou, Herve, and Bouthemy, Patrick. Better
exploiting motion for better action recognition. In Pro-
ceedings of the IEEE Conference on Computer Vision
and Pattern Recognition, pp. 2555–2562, 2013.

Kambhatla, Nandakishore and Leen, Todd K. Dimension
reduction by local principal component analysis. Neural
computation, 9(7):1493–1516, 1997.

Karpathy, Andrej, Toderici, George, Shetty, Sanketh, Le-
ung, Thomas, Sukthankar, Rahul, and Fei-Fei, Li. Large-
scale video classiﬁcation with convolutional neural net-
works. In Proceedings of the IEEE conference on Com-
puter Vision and Pattern Recognition, pp. 1725–1732,
2014.

Kim, Minyoung, Kumar, Sanjiv, Pavlovic, Vladimir, and
Face tracking and recognition with
Rowley, Henry.
In Computer
visual constraints in real-world videos.
Vision and Pattern Recognition, 2008. CVPR 2008.
IEEE Conference on, pp. 1–8. IEEE, 2008. URL
http://seqam.rutgers.edu/site/index.
php?option=com_content&view=article&
id=64&Itemid=80.

Kingma, Diederik and Ba,

Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam:

A
arXiv preprint

Koutnik, Jan, Greff, Klaus, Gomez, Faustino, and Schmid-
arXiv preprint

huber, Juergen. A clockwork rnn.
arXiv:1402.3511, 2014.

Krizhevsky, Alex, Sutskever, Ilya, and Hinton, Geoffrey E.
Imagenet classiﬁcation with deep convolutional neural
networks. In Advances in neural information processing
systems, pp. 1097–1105, 2012.

Kuehne, H., Jhuang, H., Garrote, E., Poggio, T., and Serre,
T. HMDB: a large video database for human motion
recognition. In Proceedings of the International Confer-
ence on Computer Vision (ICCV), 2011.

Laptev, Ivan, Marszalek, Marcin, Schmid, Cordelia, and
Rozenfeld, Benjamin. Learning realistic human actions
from movies. In Computer Vision and Pattern Recogni-
tion, 2008. CVPR 2008. IEEE Conference on, pp. 1–8.
IEEE, 2008.

Le, Quoc V, Zou, Will Y, Yeung, Serena Y, and Ng, An-
drew Y. Learning hierarchical invariant spatio-temporal
features for action recognition with independent sub-
space analysis. In Computer Vision and Pattern Recogni-
tion (CVPR), 2011 IEEE Conference on, pp. 3361–3368.
IEEE, 2011.

Tensor-Train Recurrent Neural Networks for Video Classiﬁcation

Lebedev, Vadim, Ganin, Yaroslav, Rakhuba, Maksim,
Speeding-
Oseledets, Ivan, and Lempitsky, Victor.
up convolutional neural networks using ﬁne-tuned cp-
decomposition. arXiv preprint arXiv:1412.6553, 2014.

Liu, Dianting, Shyu, Mei-Ling, and Zhao, Guiru. Spatial-
temporal motion information integration for action de-
tection and recognition in non-static background. In In-
formation Reuse and Integration (IRI), 2013 IEEE 14th
International Conference on, pp. 626–633. IEEE, 2013.

Liu, Jingen, Luo, Jiebo, and Shah, Mubarak. Recog-
nizing realistic actions from videos “in the wild”.
In
Computer Vision and Pattern Recognition, 2009. CVPR
2009. IEEE Conference on, pp. 1996–2003. IEEE,
2009. URL http://crcv.ucf.edu/data/UCF_
YouTube_Action.php.

Maas, Andrew L, Daly, Raymond E, Pham, Peter T, Huang,
Dan, Ng, Andrew Y, and Potts, Christopher. Learning
word vectors for sentiment analysis. In Proceedings of
the 49th Annual Meeting of the Association for Com-
putational Linguistics: Human Language Technologies-
Volume 1, pp. 142–150. Association for Computational
Linguistics, 2011.

Marszałek, Marcin, Laptev, Ivan, and Schmid, Cordelia.
Actions in context. In IEEE Conference on Computer Vi-
sion & Pattern Recognition, 2009. URL http://www.
di.ens.fr/˜laptev/actions/hollywood2/.

Novikov, Alexander, Podoprikhin, Dmitrii, Osokin, Anton,
and Vetrov, Dmitry P. Tensorizing neural networks. In
Advances in Neural Information Processing Systems, pp.
442–450, 2015.

Ortiz, Enrique G, Wright, Alan, and Shah, Mubarak. Face
recognition in movie trailers via mean sequence sparse
In Proceedings of
representation-based classiﬁcation.
the IEEE Conference on Computer Vision and Pattern
Recognition, pp. 3531–3538, 2013.

Oseledets, Ivan V. Tensor-train decomposition. SIAM Jour-
nal on Scientiﬁc Computing, 33(5):2295–2317, 2011.

Sharma, Shikhar, Kiros, Ryan, and Salakhutdinov, Ruslan.
Action recognition using visual attention. arXiv preprint
arXiv:1511.04119, 2015.

Shi, Xingjian, Chen, Zhourong, Wang, Hao, Yeung,
Dityan, Wong, Waikin, and Woo, Wangchun. Convo-
lutional lstm network: a machine learning approach for
precipitation nowcasting. pp. 802–810, 2015.

Simonyan, Karen and Zisserman, Andrew. Two-stream
convolutional networks for action recognition in videos.
In Advances in Neural Information Processing Systems,
pp. 568–576, 2014.

Srivastava, Nitish, Hinton, Geoffrey E, Krizhevsky, Alex,
Sutskever, Ilya, and Salakhutdinov, Ruslan. Dropout:
a simple way to prevent neural networks from overﬁt-
Journal of Machine Learning Research, 15(1):
ting.
1929–1958, 2014.

Srivastava, Nitish, Mansimov, Elman, and Salakhutdinov,
Ruslan. Unsupervised learning of video representations
using lstms. CoRR, abs/1502.04681, 2, 2015.

Sutskever, Ilya, Vinyals, Oriol, and Le, Quoc V.

Se-
quence to sequence learning with neural networks.
In
Advances in neural information processing systems, pp.
3104–3112, 2014.

Szegedy, Christian, Liu, Wei, Jia, Yangqing, Sermanet,
Pierre, Reed, Scott, Anguelov, Dragomir, Erhan, Du-
mitru, Vanhoucke, Vincent, and Rabinovich, Andrew.
In Proceedings of
Going deeper with convolutions.
the IEEE Conference on Computer Vision and Pattern
Recognition, pp. 1–9, 2015.

Wang, Heng and Schmid, Cordelia. Action recognition
with improved trajectories. In Proceedings of the IEEE
International Conference on Computer Vision, pp. 3551–
3558, 2013.

Ye, Jieping, Janardan, Ravi, and Li, Qi. Gpca: an efﬁcient
dimension reduction scheme for image compression and
In Proceedings of the tenth ACM SIGKDD
retrieval.
international conference on Knowledge discovery and
data mining, pp. 354–363. ACM, 2004.

Yue-Hei Ng,

Joe, Hausknecht, Matthew, Vijaya-
narasimhan, Sudheendra, Vinyals, Oriol, Monga,
Rajat, and Toderici, George. Beyond short snippets:
Deep networks for video classiﬁcation. In Proceedings
of the IEEE Conference on Computer Vision and Pattern
Recognition, pp. 4694–4702, 2015.

Zhang, Jun, Yan, Yong, and Lades, Martin. Face recogni-
tion: eigenface, elastic matching, and neural nets. Pro-
ceedings of the IEEE, 85(9):1423–1435, 1997.

