Input Convex Neural Networks

Brandon Amos 1 Lei Xu 2 * J. Zico Kolter 1

Abstract

This paper presents the input convex neural net-
work architecture. These are scalar-valued (po-
tentially deep) neural networks with constraints
on the network parameters such that the output
of the network is a convex function of (some
of) the inputs. The networks allow for efﬁcient
inference via optimization over some inputs to
the network given others, and can be applied to
settings including structured prediction, data im-
putation, reinforcement learning, and others. In
this paper we lay the basic groundwork for these
models, proposing methods for inference, opti-
mization and learning, and analyze their repre-
sentational power. We show that many existing
neural network architectures can be made input-
convex with a minor modiﬁcation, and develop
specialized optimization algorithms tailored to
this setting. Finally, we highlight the perfor-
mance of the methods on multi-label prediction,
image completion, and reinforcement learning
problems, where we show improvement over the
existing state of the art in many cases.

1. Introduction

In this paper, we propose a new neural network architecture
that we call the input convex neural network (ICNN).These
are scalar-valued neural networks f (x, y; θ) where x and
y denotes inputs to the function and θ denotes the param-
eters, built in such a way that the network is convex in (a
subset of) inputs y.3 The fundamental beneﬁt to these IC-
NNs is that we can optimize over the convex inputs to the
network given some ﬁxed value for other inputs. That is,
given some ﬁxed x (and possibly some ﬁxed elements of

*Work done while author was at Carnegie Mellon Univer-
1School of Computer Science, Carnegie Mellon Univer-
sity.
sity. Pittsburgh, PA, USA 2Department of Computer Science and
Technology, Tsinghua University. Beijing, China. Correspon-
dence to: Brandon Amos <bamos@cs.cmu.edu>, J. Zico Kolter
<zkolter@cs.cmu.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

y) we can globally and efﬁciently (because the problem is
convex) solve the optimization problem

argmin
y

f (x, y; θ).

(1)

Fundamentally, this formalism lets us perform inference
in the network via optimization. That is, instead of mak-
ing predictions in a neural network via a purely feedfor-
ward process, we can make predictions by optimizing a
scalar function (which effectively plays the role of an en-
ergy function) over some inputs to the function given oth-
ers. There are a number of potential use cases for these
networks.

Structured prediction As is perhaps apparent from our
notation above, a key application of this work is in struc-
tured prediction. Given (typically high-dimensional) struc-
tured input and output spaces X × Y, we can build a net-
work over (x, y) pairs that encodes the energy function
for this pair, following typical energy-based learning for-
malisms (LeCun et al., 2006). Prediction involves ﬁnding
the y ∈ Y that minimizes the energy for a given x, which
is exactly the argmin problem in (1).
In our setting, as-
suming that Y is a convex space (a common assumption in
structured prediction), this optimization problem is convex.
This is similar in nature to the structured prediction energy
networks (SPENs) (Belanger & McCallum, 2016), which
also use deep networks over the input and output spaces,
with the difference being that in our setting f is convex in
y, so the optimization can be performed globally.

Data imputation Similar to structured prediction but
slightly more generic, if we are given some space Y we
can learn a network f (y; θ) (removing the additional x in-
puts, though these can be added as well) that, given an ex-
ample with some subset I missing, imputes the likely val-
ues of these variables by solving the optimization problem
as above ˆyI = argminyI f (yI, y ¯I; θ) This could be used

3We emphasize the term “input convex” since convexity in
machine learning typically refers to convexity (of the loss min-
imization learning problem) in the parameters, which is not the
case here. Note that in our notation, f needs only be a convex
function in y, and may still be non-convex in the remaining inputs
x. Training these neural networks remains a nonconvex problem,
and the convexity is only being exploited at inference time.

Input Convex Neural Networks

e.g., in image inpainting where the goal is to ﬁll in some
arbitrary set of missing pixels given observed ones.

Continuous action reinforcement learning Given a re-
inforcement learning problem with potentially continuous
state and action spaces S × A, we can model the (neg-
ative) Q function, −Q(s, a; θ) as an input convex neural
network.
In this case the action selection procedure can
be formulated as a convex optimization problem a(cid:63)(s) =
argmina −Q(s, a; θ).

This paper lays the foundation for optimization, inference,
and learning in these input convex models, and explores
their performance in the applications above. Our main con-
tributions are: we propose the ICNN architecture and a par-
tially convex variant; we develop efﬁcient optimization and
inference procedures that are well-suited to the complexity
of these speciﬁc models; we propose techniques for train-
ing these models, based upon either max-margin structured
prediction or direct differentiation of the argmin operation;
and we evaluate the system on multi-label prediction, im-
age completion, and reinforcement learning domains; in
many of these settings we show performance that improves
upon the state of the art.

2. Background and related work

Energy-based learning The interplay between infer-
ence, optimization, and structured prediction has a long
history in neural networks. Several early incarnations of
neural networks were explicitly trained to produce struc-
tured sequences (e.g. (Simard & LeCun, 1991)), and there
was an early appreciation that structured models like hid-
den Markov models could be combined with the outputs of
neural networks (Bengio et al., 1994). Much of this earlier
work is surveyed and synthesized by (LeCun et al., 2006),
who give a tutorial on these energy based learning meth-
ods. In recent years, there has been a strong push to fur-
ther incorporate structured prediction methods like condi-
tional random ﬁelds as the “last layer” of a deep network
architecture (Peng et al., 2009; Zheng et al., 2015; Chen
et al., 2015). Several methods have proposed to build gen-
eral neural networks over joint input and output spaces,
and perform inference over outputs using generic optimiza-
tion techniques such as Generative Adversarial Networks
(GANs) (Goodfellow et al., 2014) and Structured Predic-
tion Energy Networks (SPENs) (Belanger & McCallum,
2016). SPENs provide a deep structure over input and
output spaces that performs the inference in (1) as a non-
convex optimization problem.

The current work is highly related to these past approaches,
but also differs in a very particular way. To the best of
our knowledge, each of these structured prediction meth-
ods based upon energy-based models operates in one of two

ways, either: 1) the architecture is built in a very particular
way such that optimization over the output is guaranteed to
be “easy” (e.g. convex, or the result of running some infer-
ence procedure), usually by introducing a structured linear
objective at the last layer of the network; or 2) no attempt is
made to make the architecture “easy” to run inference over,
and instead a general model is built over the output space.
In contrast, our approach lies somewhere in between: by
ensuring convexity of the resulting decision space, we are
constraining the inference problem to be easy in some re-
spect, but we specify very little about the architecture other
than the constraints required to make it convex. In particu-
lar, as we will show, the network architecture over the vari-
ables to be optimized over can be deep and involve multiple
non-linearities. The goal of the proposed work is to allow
for complex functions over the output without needing to
specify them manually (exactly analogous to how current
deep neural networks treat their input space).

Structured prediction and MAP inference Our work
also draws some connection to MAP-inference-based
learning and approximate inference. There are two broad
classes of learning approaches in structured prediction:
method that use probabilistic inference techniques (typi-
cally exploiting the fact that the gradient of log likelihood is
given by the actual feature expectations minus their expec-
tation under the learned model (Koller & Friedman, 2009,
Ch 20)), and methods that rely solely upon MAP inference
(such as max-margin structured prediction (Taskar et al.,
2005; Tsochantaridis et al., 2005)). MAP inference in par-
ticular also has close connections to optimization, as vari-
ous convex relaxations of the general MAP inference prob-
lem often perform well in theory and practice. The pro-
posed methods can be viewed as an extreme case of this
second class of algorithm, where inference is based solely
upon a convex optimization problem that may not have any
probabilistic semantics at all. Finally, although it is more
abstract, we feel there is a philosophical similarity between
our proposed approach and sum-product networks (Poon &
Domingos, 2011); both settings deﬁne networks where in-
ference is accomplished “easily” either by a sum-product
message passing algorithm (by construction) or via convex
optimization.

Fitting convex functions Finally, the proposed work re-
lates to a topic less considered in the machine learning lit-
erature, that of ﬁtting convex functions to data (Boyd &
Vandenberghe, 2004, pg. 338). Indeed our learning prob-
lem can be viewed as parameter estimation under a model
that is guaranteed to be convex by its construction. The
most similar work of which we are aware speciﬁcally ﬁts
sums of rectiﬁed half-planes to data (Magnani & Boyd,
2009), which is similar to one layer of our rectiﬁed linear
units. However, the actual training scheme is much differ-

Input Convex Neural Networks

Figure 1. A fully input convex neural network (FICNN).

ent, and our deep network architecture allows for a much
richer class of representations, while still maintaining con-
vexity.

3. Convex neural network architectures

Here we more formally present different ICNN architec-
tures and prove their convexity properties given certain
constraints on the parameter space. Our chief claim is that
the class of (full and partial) input convex models is rich
and lets us capture complex joint models over the input to
a network.

3.1. Fully input convex neural networks

To begin, we consider a fully convex, k-layer, fully con-
nected ICNN that we call a FICNN and is shown in Figure
1. This model deﬁnes a neural network over the input y
(i.e., omitting any x term in this function) using the archi-
tecture for i = 0, . . . , k − 1
(cid:16)
W (z)
i

, f (y; θ) = zk

zi + W (y)

i y + bi

zi+1 = gi

(2)

(cid:17)

0:k−1, W (z)

where zi denotes the layer activations (with z0, W (z)
0 ≡ 0),
θ = {W (y)
1:k−1, b0:k−1} are the parameters, and gi
are non-linear activation functions. The central result on
convexity of the network is the following:
Proposition 1. The function f is convex in y provided that
all W (z)
1:k−1 are non-negative, and all functions gi are con-
vex and non-decreasing.

The proof is simple and follows from the fact that non-
negative sums of convex functions are also convex and that
the composition of a convex and convex non-decreasing
function is also convex (see e.g. Boyd & Vandenberghe
(2004, 3.2.4)). The constraint that the gi be convex non-
decreasing is not particularly restrictive, as current non-
linear activation units like the rectiﬁed linear unit or max-
pooling unit already satisfy this constraint. The constraint
that the W (z) terms be non-negative is somewhat restric-
tive, but because the bias terms and W (y) terms can be neg-
ative, the network still has substantial representation power,
as we will shortly demonstrate empirically.

One notable addition in the ICNN are the “passthrough”
layers that directly connect the input y to hidden units in

Figure 2. A partially input convex neural network (PICNN).

deeper layers. Such layers are unnecessary in traditional
feedforward networks because previous hidden units can
always be mapped to subsequent hidden units with the
identity mapping; however, for ICNNs, the non-negativity
constraint subsequent W (z) weights restricts the allowable
use of hidden units that mirror the identity mapping, and
so we explicitly include this additional passthrough. Some
passthrough layers have been recently explored in the deep
residual networks (He et al., 2015) and densely connected
convolutional networks (Huang et al., 2016), though these
differ from those of an ICNN as they pass through hidden
layers deeper in the network, whereas to maintain convex-
ity our passthrough layers can only apply to the input di-
rectly.

Other linear operators like convolutions can be included
in ICNNs without changing the convexity properties. In-
deed, modern feedforward architectures such as AlexNet
(Krizhevsky et al., 2012), VGG (Simonyan & Zisserman,
2014), and GoogLeNet (Szegedy et al., 2015) with Re-
LUs (Nair & Hinton, 2010) can be made input convex with
Proposition 1. In the experiment that follow, we will ex-
plore ICNNs with both fully connected and convolutional
layers, and we provide more detail about these additional
architectures in Section A of the supplement.

3.2. Partially input convex architectures

The FICNN provides joint convexity over the entire input
to the function, which indeed may be a restriction on the
allowable class of models. Furthermore, this full joint con-
vexity is unnecessary in settings like structured prediction
where the neural network is used to build a joint model over
an input and output example space and only convexity over
the outputs is necessary.

In this section we propose an extension to the pure FICNN,
the partially input convex neural network (PICNN), that is
convex over only some inputs to the network (in general
ICNNs will refer to this new class). As we will show, these
networks generalize both traditional feedforward networks
and FICNNs, and thus provide substantial representational
beneﬁts. We deﬁne a PICNN to be a network over (x, y)
pairs f (x, y; θ) where f is convex in y but not convex in x.
Figure 2 illustrates one potential k-layer PICNN architec-

Input Convex Neural Networks

ture deﬁned by the recurrences

ui+1 = ˜gi( ˜Wiui + ˜bi)
(cid:16)

(cid:16)

zi+1 = gi

zi ◦ [W (zu)

i

W (z)
i
(cid:16)

(cid:17)

]+

+

i

ui + b(z)
(cid:17)
)

W (y)
i

y ◦ (W (yu)

i

ui + b(y)

i

+ W (u)

i ui + bi

f (x, y; θ) = zk, u0 = x

(cid:17)

(3)

where ui ∈ Rni and zi ∈ Rmi denote the hidden units
for the “x-path” and “y-path”, where y ∈ Rp, and where
◦ denotes the Hadamard product, the elementwise product
between two vectors. The crucial element here is that un-
like the FICNN, we only need the W (z) terms to be non-
negative, and we can introduce arbitrary products between
the ui hidden units and the zi hidden units. The follow-
ing proposition highlights the representational power of the
PICNN.

Proposition 2. A PICNN network with k layers can repre-
sent any FICNN with k layers and any purely feedforward
network with k layers.

Proof. To recover a FICNN we simply set the weights over
the entire x path to be zero and set b(z) = b(y) = 1. We
can recover a feedforward network by noting that a tradi-
tional feedforward network ˆf (x; θ) where f : X → Y, can
be viewed as a network with an inner product f (x; θ)T y in
its last layer (see e.g. (LeCun et al., 2006) for more de-
tails). Thus, a feedforward network can be represented as
a PICNN by setting the x path to be exactly the feedfor-
ward component, then having the y path be all zero except
W (yu)

k−1 = I and W (y)

k−1 = 1T .

4. Inference in ICNNs

Prediction in ICNNs (which we also refer to as inference),
requires solving the convex optimization problem

Exact inference in ICNNs Although it is not a practical
approach for solving the optimization tasks, the inference
problem for the networks presented above (where the non-
linear are either ReLU or linear units) can be posed as as
linear program. We show how to do this in Section B.

4.1. Approximate inference in ICNNs

Because of the impracticality of exact inference, we focus
on approximate approaches to optimizing over the inputs to
these networks, but ideally ones that still exploit the con-
vexity of the resulting problem. We speciﬁcally focus on
gradient-based approaches, which use the fact that we can
easily compute the gradient of an ICNN with respect to its
inputs, ∇yf (x, y; θ), using backpropagation.

Gradient descent. The simplest gradient-based methods
for solving (4) is just (projected sub-) gradient descent,
or modiﬁcations such as those that use a momentum term
(Polyak, 1964; Rumelhart et al., 1988), or spectral step
size modiﬁcations (Barzilai & Borwein, 1988; Birgin et al.,
2000). That is, we start with some initial ˆy and repeat the
update

ˆy ← PY (ˆy − α∇yf (x, ˆy; θ))

(5)

This method is appealing in its simplicity, but suffers from
the typical problems of gradient descent on non-smooth ob-
jectives: we need to pick a step size and possibly use a
sequence of decreasing step sizes, and don’t have an ob-
vious method to assess how accurate of a current solution
we have obtained (since an ICNN with ReLUs is piece-
wise linear, it will not have zero gradient at the solution).
The method is also more challenging to integrate with
some learning procedures, as we often need to differentiate
through an entire chain of the gradient descent algorithm
(Domke, 2012). Thus, while the method can sometimes
work in practice, we have found that other approaches typ-
ically far outperform this method, and we will focus on al-
ternative approximate approaches for the remainder of this
section.

minimize
y∈Y

f (x, y; θ)

(4)

4.2. Approximate inference via the bundle entropy

method

While the resulting tasks are convex optimization problems
(and thus “easy” to solve in some sense), in practice this
still involves the solution of a potentially very complex op-
timization problem. We discuss here several approaches for
approximately solving these optimization problems. We
can usually obtain reasonably accurate solutions in many
settings using a procedure that only involves a small num-
ber of forward and backward passes through the network,
and which thus has a complexity that is at most a constant
factor worse than that for feedforward networks. The same
consideration will apply to training such networks, which
we will discuss in Section 5.

An alternative approach to gradient descent is the bundle
method (Smola et al., 2008), also known as the epigraph
cutting plane approach, which iteratively optimizes a piece-
wise lower bound on the function given by the maximum
over a set of ﬁrst-order approximations. However, as, the
traditional bundle method is not well suited to our setting
(we need to evaluate a number of gradients equal to the di-
mension of x, and solve a complex optimization problem at
each step) we have developed a new optimization algorithm
for this domain that we term the bundle entropy method.
This algorithm speciﬁcally applies to the (common) case
where Y is bounded, which we assume to be Y = [0, 1]n

Input Convex Neural Networks

(other upper or lower bounds can be attained through scal-
ing). The method is also easily extensible to the setting
where elements of Y belong to a higher-dimensional prob-
ability simplex as well.

For this approach, we consider adding an additional “bar-
rier” function to the optimization in the form of the negative
entropy −H(y), where

H(y) = −

(yi log yi + (1 − yi) log(1 − yi)).

(6)

n
(cid:88)

i=1

In other words, we instead want to solve the optimization
problem argminy f (x, y; θ)−H(y) (with a possible addi-
tional scaling term). The negative entropy is a convex func-
tion, with the limits of limy→0 H(y) = limy→1 H(y) = 0,
and negative values in the interior of this range. The func-
tion acts as a barrier because, although it does not approach
inﬁnity as it reaches the barrier of the feasible set, its gra-
dient does approach inﬁnity as it reaches the barrier, and
thus the optimal solution will always lie in the interior of
the unit hypercube Y.

An appealing feature of the entropy regularization comes
from its close connection with sigmoid units in typical neu-
ral networks. It follows easily from ﬁrst-order optimality
conditions that the optimization problem

and differentiating with respect to y and t gives the opti-
mality conditions

∇yL(y, t, λ) = 0 =⇒ y =

∇tL(y, t, λ) = 0 =⇒ 1T λ = 1

1
1 + exp(GT λ)

which in turn leads to the dual problem

maximize
λ

(G1 + h)T λ − 1T log(1 + exp(GT λ))

subject to λ ≥ 0, 1T λ = 1.

(12)

(13)

This is a smooth optimization problem over the unit sim-
plex, and can be solved using a method like the Projected
Newton method of (Bertsekas, 1982, pg. 241, eq. 97). A
complete description of the bundle entropy method is given
in Section D. For lower dimensional problems, the bundle
entropy method often attains an exact solution after a rela-
tively small number of iterations. And even for larger prob-
lems, we ﬁnd that the approximate solutions generated by
a very small number of iterations (we typically use 5 iter-
ations), still substantially outperform gradient descent ap-
proaches. Further, because we maintain an explicit lower
bound on the function, we can compute an optimality gap
of our solution, though in practice just using a ﬁxed number
of iterations performs well.

minimize
y

cT y − H(y)

(7)

5. Learning ICNNs

is given by y(cid:63) = 1/(1 + exp(c)). Thus if we con-
sider the “trivial” PICNN mentioned in Section 3.2, which
simply consists of the function f (x, y; θ) = yT ˜f (x; θ)
for some purely feedforward network ˜f (x; θ), then the
entropy-regularized minimization problem gives a solution
that is equivalent to simply taking the sigmoid of the neural
network outputs. Thus, the move to ICNNs can be inter-
preted as providing a more structured joint energy func-
tional over the linear function implicitly used by sigmoid
layers.

At each iteration of the bundle entropy method, we solve
the optimization problem

yk+1, tk+1 := argmin

{t − H(y) | Gy + h ≤ t1} (8)

y,t

where G ∈ Rk×n has rows equal to

i = ∇yf (x, yi; θ)T
gT

(9)

and h ∈ Rk has entries equal to

Generally speaking, ICNN learning shapes the objective’s
energy function to produce the desired values when opti-
mizing over the relevant inputs. That is, for a given input
output pair (x, y(cid:63)), our goal is to ﬁnd ICNN parameters θ
such that

y(cid:63) ≈ argmin

˜f (x, y; θ)

y

(14)

where for the entirely of this section, we use the notation
˜f to denote the combination of the neural network func-
tion plus the regularization term such as −H(y), if it is
included, i.e.

˜f (x, y; θ) = f (x, y; θ) − H(y).

(15)

Although we only discuss the entropy regularization in this
work, we emphasize that other regularizers are also possi-
ble. Depending on the setting, there are several different
approaches we can use to ensure that the ICNN achieves
the desired targets, and we consider three approaches be-
low: direct functional ﬁtting, max-margin structured pre-
diction, and argmin differentiation.

hi = f (x, yi; θ) − ∇yf (x, yi; θ)T yi.

(10)

The Lagrangian of the optimization problem is

L(y, t, λ) = t − H(y) + λT (Gy + h − t1)

(11)

Direct functional ﬁtting. We ﬁrst note that in some do-
mains, we do not need a specialized procedure for ﬁtting
ICNNs, but can use existing approaches that directly ﬁt the
ICNN. An example of this is the Q-learning setting. Given

Input Convex Neural Networks

some observed tuple (s, a, r, s(cid:48)), Q learning updates the pa-
rameters θ with the gradient

(cid:16)

Q(s, a) − r − γ max

Q(s(cid:48), a(cid:48))

∇θQ(s, a),

(16)

a(cid:48)

(cid:17)

where the maximization step is carried out with gradient
descent or the bundle entropy method. These updates can
be applied to ICNNs with the only additional requirement
that we project the weights onto their feasible sets after this
update (i.e., clip or project any W terms that are required
to be positive). Section E gives a complete description of
deep Q-learning with ICNNs.

Max-margin structured prediction. Although max-
margin structured prediction is a simple and well-studied
approach (Tsochantaridis et al., 2005; Taskar et al., 2005),
in our experiences using these methods within an ICNN,
we had substantial difﬁculty choosing the proper mar-
gin scaling term (especially for domains with continuous-
valued outputs), or allowing for losses other than the hinge
loss. For this reason, Section F discusses max-margin
structured prediction in more detail, but the majority of our
experiments here focus on the next approach, which more
directly encodes the loss suffered by the full structured-
prediction pipeline.

5.1. Argmin differentiation

In our ﬁnal proposed approach, that of argmin differentia-
tion, we propose to directly minimize a loss function be-
tween true outputs and the outputs predicted by our model,
where these predictions themselves are the result of an op-
timization problem. We explicitly consider the case where
the approximate solution to the inference problem is at-
tained via the previously-described bundle entropy method,
typically run for some ﬁxed (usually small) number of iter-
ations. To simplify notation, in the following we will let

ˆy(x; θ) = argmin

{t − H(y) | Gy + h ≤ t1}

min
t

(17)

≈ argmin

˜f (x, y; θ)

y

y

refer to the approximate minimization over y that results
from running the bundle entropy method, speciﬁcally at the
last iteration of the method.

Given some example (x, y(cid:63)), our goal is to compute the
gradient, with respect to the ICNN parameters, of the loss
between y(cid:63) and ˆy(x; θ): (cid:96)(ˆy(x; θ), y(cid:63)). This is in some
sense the most direct analogue to traditional neural net-
work learning, since we typically optimize networks by
minimizing some loss between the network’s (feedforward)
predictions and the true desired labels. Doing this in the
predictions-via-optimization setting requires that we differ-
entiate “through” the argmin operator, which can be ac-

complished via implicit differentiation of the KKT opti-
mality conditions. Although the derivation is somewhat in-
volved, the ﬁnal result is fairly compact, and is given by the
following proposition (for simplicity, we will write ˆy below
instead of ˆy(x; θ) when the notation should be clear):

Proposition 3. The gradient of the neural network loss for
predictions generated through the minimization process is

∇θ(cid:96)(ˆy(x; θ), y(cid:63)) =

(cλ

i ∇θf (x, yi; θ)+

(18)

∇θ

(cid:0)∇yf (x, yi; θ)T (cid:0)λicy + cλ

(cid:0)ˆy(x; θ) − yi(cid:1)(cid:1)(cid:1))

i

k
(cid:88)

i=1

where yi denotes the solution returned by the ith iteration
of the entropy bundle method, λ denotes the dual variable
solution of the entropy bundle method, and where the c
variables are determined by the solution to the linear sys-
tem





H GT
G
0
0 −1T

0
−1
0









cy
cλ
ct





 =



−∇ˆy(cid:96)(ˆy, y(cid:63))
0
0



 .

(19)

where H = diag

(cid:16) 1
ˆy + 1

1−ˆy

(cid:17)

.

The proof of this proposition is given in Section G, but we
highlight a few key points here. The complexity of com-
puting this gradient will be linear in k, which is the number
of active constraints at the solution of the bundle entropy
method. The inverse of this matrix can also be computed
efﬁciently by just inverting the k × k matrix GH −1GT via
a variable elimination procedure, instead of by inverting
the full matrix. The gradients ∇θf (x, yi; θ) are standard
neural network gradients, and further, can be computed in
the same forward/backward pass as we use to compute the
gradients for the bundle entropy method. The main chal-
lenge of the method is to compute the terms of the form
∇θ(∇yf (x, yi; θ)T v) for some vector v. This quantity can
be computed by most autodifferentiation tools (the gradient
inner product ∇yf (x, yi; θ)T v itself just becomes a graph
computation than can be differentiated itself), or it can be
computed by a ﬁnite difference approximation. The com-
plexity of computing this entire gradient is a small constant
multiple of computing k gradients with respect to θ.

Given this ability to compute gradients with respect to an
arbitrary loss function, we can ﬁt the parameter using tra-
ditional stochastic gradient methods examples. Speciﬁ-
cally, given an example (or a minibatch of examples) xi, yi,
we compute gradients ∇θ(cid:96)(ˆy(xi; θ), yi) and update the pa-
rameters using e.g. the ADAM optimizer (Kingma & Ba,
2014).

Input Convex Neural Networks

Method
Feedforward net
ICNN
SPEN (Belanger & McCallum, 2016)

Test Macro-F1
0.396
0.415
0.422

Table 1. Comparison of approaches on BibTeX multi-label classi-
ﬁcation task. (Higher is better.)

6. Experiments

Our experiments study the representational power of IC-
NNs to better understand the interplay between the model’s
restrictiveness and accuracy.
Speciﬁcally, we evaluate
the method on multi-label classiﬁcation on the BibTeX
dataset (Katakis et al., 2008),
image completion using
the Olivetti face dataset (Samaria & Harter, 1994), and
continuous action reinforcement learning in the OpenAI
Gym (Brockman et al., 2016). We show that the meth-
ods compare favorably to the state of the art in many situa-
tions. The full source code for all experiments is available
in the icml2017 branch at https://github.com/
locuslab/icnn and our implementation is built using
Python (Van Rossum & Drake Jr, 1995) with the numpy
(Oliphant, 2006) and TensorFlow (Abadi et al., 2016) pack-
ages.

6.1. Synthetic 2D example

Though we do not discuss it here, Section I presents a sim-
ple synthetic classiﬁcation experiment comparing FICNN
and PICNN decision boundaries.

6.2. Multi-Label Classiﬁcation

We ﬁrst study how ICNNs perform on multi-label classiﬁ-
cation with the BibTeX dataset and benchmark presented in
(Katakis et al., 2008). This benchmark maps text classiﬁca-
tion from an input space X of 1836 bag-of-works indicator
(binary) features to an output space Y of 159 binary labels.
We use the train/test split of 4880/2515 from (Katakis et al.,
2008) and evaluate with the macro-F1 score (higher is bet-
ter). We use the ARFF version of this dataset from Mu-
lan (Tsoumakas et al., 2011). Our PICNN architecture for
multi-label classiﬁcation uses fully-connected layers with
ReLU activation functions and batch normalization (Ioffe
& Szegedy, 2015) along the input path. As a baseline, we
use a fully-connected neural network with batch normal-
ization and ReLU activation functions. Both architectures
have the same structure (600 fully connected, 159 (#labels)
fully connected). We optimize our PICNN with 30 itera-
tions of gradient descent with a learning rate of 0.1 and a
momentum of 0.3.

Table 1 compares several different methods for this prob-
lem. Our PICNN’s ﬁnal macro-F1 score of 0.415 outper-

Figure 3. Example test set image completions of the ICNN with
bundle entropy.

forms our baseline feedforward network’s score of 0.396,
which indicates PICNNs have the power to learn a robust
structure over the output space. SPENs obtain a macro-F1
score of 0.422 on this task (Belanger & McCallum, 2016)
and pose an interesting comparison point to ICNNs as they
have a similar (but not identical) deep structure that is non-
convex over the input space. The difference of 0.007 be-
tween ICNNs and SPENs could be due to differences in
our experimental setups, architectures, and random experi-
mental noise. More details are included in Section J.

6.3. Image completion on the Olivetti faces

As a test of the system on a structured prediction task over
a much more complex output space Y, we apply a convo-
lutional PICNN to face completion on the sklearn version
(Pedregosa et al., 2011) of the Olivetti data set (Samaria &
Harter, 1994), which contains 400 64x64 grayscale images.
ICNNs for face completion should be invariant to trans-
lations and other transformations in the input space. To
achieve this invariance, our PICNN is inspired by the DQN
architecture in Mnih et al. (2015), which preserves this in-
variance in the different context of reinforcement learn-
ing. Speciﬁcally, our network is over (x, y) pairs where
x (32x64) is the left half and y (32x64) is the right half of
the image. The input and output paths are: 32x8x8 conv
(stride 4x2), 64x4x4 conv (stride 2x2), 64x3x3 conv, 512
fully connected.

This experiment uses the same training/test splits and min-
imizes the mean squared error (MSE) as in Poon & Domin-
gos (2011) so that our results can be directly compared to
(a non-exhaustive list of) other techniques. We also explore
the tradeoffs between the bundle entropy method and gra-
dient descent and use a non-convex baseline to better un-
derstand the impacts of convexity. We use a learning rate
of 0.01 and momentum of 0.9 with gradient descent for the
inner optimization in the ICNN.

Input Convex Neural Networks

Method
ICNN - Bundle Entropy
ICNN - Gradient Decent
ICNN - Nonconvex
Sum-product (Poon & Domingos, 2011)

MSE
833.0
872.0
850.9
942

Table 2. Comparisons of reconstruction error on image comple-
tion.

Table 2 shows the test MSEs for the different approaches.
Example image completions are shown in Figure 3. These
results show that the bundle entropy method can leverage
more information from these ﬁve iterations than gradient
descent, even when the convexity constraint is relaxed.
The PICNN trained with back-optimization with the re-
laxed convexity constraint slightly outperforms the network
with the convexity constraint, but not the network trained
with the bundle-entropy method. This shows that for im-
age completion with PICNNs, convexity does not seem to
inhibit the representational power. Furthermore, this exper-
iment suggests that a small number of inner optimization
iterations (ﬁve in this case) is sufﬁcient for good perfor-
mance.

6.4. Continuous Action Reinforcement Learning

Finally, we present standard benchmarks in continuous ac-
tion reinforcement learning from the OpenAI Gym (Brock-
man et al., 2016) that use the MuJoCo physics simulator
(Todorov et al., 2012). We model the (negative) Q function,
−Q(s, a; θ) as an ICNN and select actions with the convex
optimization problem a(cid:63)(s) = argmina −Q(s, a; θ). We
use Q-learning to optimize the ICNN as described in Sec-
tion 5 and Section E. At test time, the policy is selected by
optimizing Q(s, a; θ). All of our experiments use a PICNN
with two fully-connected layers that each have 200 hidden
units. We compare to Deep Deterministic Policy Gradient
(DDPG) (Lillicrap et al., 2015) and Normalized Advantage
Functions (NAF) (Gu et al., 2016) as state-of-the-art off-
policy learning baselines.4

Table 3 shows the maximum test reward achieved by the
different algorithms on these tasks. Although no method
strictly dominates the others, the ICNN approach has some
clear advantages on tasks like HalfCheetah, Reacher, and
HumanoidStandup, and performs comparably on many
other tasks, though with also a few notable poor perfor-
mances in Hopper and Walker2D. Nonetheless, given the
strong baseline, and the fact that the method is literally
just a drop-in replacement for a function approximator in

4Because there are not ofﬁcial DDPG or NAF implementa-
tions or results on the OpenAI gym tasks, we use the Simon Ram-
stedt’s DDPG implementation from https://github.com/
SimonRamstedt/ddpg and have re-implemented NAF.

Task
Ant
HalfCheetah
Hopper
Humanoid
HumanoidStandup
InvDoubPend
InvPend
Reacher
Swimmer
Walker2d

DDPG
1000.00
2909.77
1501.33
524.09
134265.96
9358.81
1000.00
-6.10
49.79
1604.18

NAF
999.03
2575.16
1100.43
5000.68
116399.05
9359.59
1000.00
-6.31
69.71
1007.25

ICNN
1056.29
3822.99
831.00
433.38
141217.38
9359.41
1000.00
-5.08
64.89
298.21

Table 3. Maximum test reward for ICNN algorithm versus alter-
natives on several OpenAI Gym tasks. (All tasks are v1.)

Q-learning, these results are overall positive. NAF poses
a particularly interesting comparison point to ICNNs. In
particular, NAF decomposes the Q function in terms of
the value function an an advantage function Q(s, a) =
V (s) + A(s, a) where the advantage function is restricted
to be concave quadratic in the actions, and thus always
In a sense, this closely mir-
has a closed-form solution.
rors the setup of the PICNN architecture:
like NAF, we
have a separate non-convex path for the s variables, and an
overall function that is convex in a; however, the distinc-
tion is that while NAF requires that the convex portion be
quadratic, the ICNN architecture allows any convex func-
tional form. As our experiments show, this representational
power does allow for better performance of the resulting
system, though the trade-off, of course, is that determining
the optimal action in an ICNN is substantially more com-
putationally complex than for a quadratic.

7. Conclusion and future work

This paper laid the groundwork for the input convex neural
network model. By incorporating relatively simple con-
straints into existing network architectures, we can ﬁt very
general convex functions and the apply optimization as an
inference procedure. Since many existing models already
ﬁt into this overall framework (e.g., CRF models perform
an optimization over an output space where parameters are
given by the output of a neural network), the proposed
method presents an extension where the entire inference
procedure is “learned” along with the network itself, with-
out the need for explicitly building typical structured pre-
diction architectures. This work explored only a small sub-
set of the possible applications of these network, and the
networks offer promising directions for many additional
domains.

Input Convex Neural Networks

Acknowledgments

BA is supported by the National Science Foundation
Graduate Research Fellowship Program under Grant No.
DGE1252522. We also thank David Belanger for helpful
discussions.

References

Abadi, Martın, Agarwal, Ashish, Barham, Paul, Brevdo,
Eugene, Chen, Zhifeng, Citro, Craig, Corrado, Greg S,
Davis, Andy, Dean, Jeffrey, Devin, Matthieu, et al. Ten-
sorﬂow: Large-scale machine learning on heterogeneous
distributed systems. arXiv preprint arXiv:1603.04467,
2016.

Barzilai, Jonathan and Borwein, Jonathan M. Two-point
step size gradient methods. IMA Journal of Numerical
Analysis, 8(1):141–148, 1988.

Belanger, David and McCallum, Andrew. Structured pre-
diction energy networks. In Proceedings of the Interna-
tional Conference on Machine Learning, 2016.

Bengio, Yoshua, LeCun, Yann, and Henderson, Donnie.
Globally trained handwritten word recognizer using spa-
tial representation, convolutional neural networks, and
hidden markov models. Advances in neural information
processing systems, pp. 937–937, 1994.

Bertsekas, Dimitri P. Projected newton methods for opti-
mization problems with simple constraints. SIAM Jour-
nal on control and Optimization, 20(2):221–246, 1982.

Birgin, Ernesto G, Mart´ınez, Jos´e Mario, and Raydan, Mar-
cos. Nonmonotone spectral projected gradient methods
on convex sets. SIAM Journal on Optimization, 10(4):
1196–1211, 2000.

Boyd, Stephen and Vandenberghe, Lieven. Convex opti-

mization. Cambridge university press, 2004.

Boyd, Stephen, Parikh, Neal, Chu, Eric, Peleato, Borja, and
Eckstein, Jonathan. Distributed optimization and statisti-
cal learning via the alternating direction method of mul-
tipliers. Foundations and Trends R(cid:13) in Machine Learn-
ing, 3(1):1–122, 2011.

Brockman, Greg, Cheung, Vicki, Pettersson, Ludwig,
Schneider, Jonas, Schulman, John, Tang, Jie, and
arXiv preprint
Zaremba, Wojciech. Openai gym.
arXiv:1606.01540, 2016.

Chen, Liang-Chieh, Schwing, Alexander G, Yuille, Alan L,
and Urtasun, Raquel. Learning deep structured models.
In Proceedings of the International Conference on Ma-
chine Learning, 2015.

Domke, Justin. Generic methods for optimization-based
modeling. In Proceedings of the Conference on AI and
Statistics, pp. 318–326, 2012.

Duchi, John, Hazan, Elad, and Singer, Yoram. Adaptive
subgradient methods for online learning and stochastic
optimization. The Journal of Machine Learning Re-
search, 12:2121–2159, 2011.

Goodfellow, Ian, Pouget-Abadie, Jean, Mirza, Mehdi, Xu,
Bing, Warde-Farley, David, Ozair, Sherjil, Courville,
Aaron, and Bengio, Yoshua. Generative adversarial nets.
In Advances in Neural Information Processing Systems,
pp. 2672–2680, 2014.

Gu, Shixiang, Lillicrap, Timothy, Sutskever, Ilya, and
Levine, Sergey. Continuous deep q-learning with model-
based acceleration. In Proceedings of the International
Conference on Machine Learning, 2016.

He, Kaiming, Zhang, Xiangyu, Ren, Shaoqing, and Sun,
Jian. Deep residual learning for image recognition. arXiv
preprint arXiv:1512.03385, 2015.

Huang, Gao, Liu, Zhuang, and Weinberger, Kilian Q.
arXiv

Densely connected convolutional networks.
preprint arXiv:1608.06993, 2016.

Ioffe, Sergey and Szegedy, Christian. Batch normalization:
Accelerating deep network training by reducing internal
covariate shift. In Proceedings of The 32nd International
Conference on Machine Learning, pp. 448–456, 2015.

Katakis, Ioannis, Tsoumakas, Grigorios, and Vlahavas,
Ioannis. Multilabel text classiﬁcation for automated
tag suggestion. ECML PKDD discovery challenge, 75,
2008.

Kingma, Diederik and Ba,

Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam:

A
arXiv preprint

Koller, Daphne and Friedman, Nir. Probabilistic graphical
models: principles and techniques. MIT press, 2009.

Krizhevsky, Alex, Sutskever, Ilya, and Hinton, Geoffrey E.
Imagenet classiﬁcation with deep convolutional neural
networks. In Advances in neural information processing
systems, pp. 1097–1105, 2012.

LeCun, Yann, Chopra, Sumit, Hadsell, Raia, Ranzato, M,
and Huang, F. A tutorial on energy-based learning. Pre-
dicting structured data, 1:0, 2006.

Lillicrap, Timothy P, Hunt, Jonathan J, Pritzel, Alexander,
Heess, Nicolas, Erez, Tom, Tassa, Yuval, Silver, David,
and Wierstra, Daan. Continuous control with deep re-
inforcement learning. arXiv preprint arXiv:1509.02971,
2015.

Input Convex Neural Networks

Magnani, Alessandro and Boyd, Stephen P.

Convex
piecewise-linear ﬁtting. Optimization and Engineering,
10(1):1–17, 2009.

Simonyan, Karen and Zisserman, Andrew. Very deep con-
volutional networks for large-scale image recognition.
arXiv preprint arXiv:1409.1556, 2014.

Mnih, Volodymyr, Kavukcuoglu, Koray, Silver, David,
Rusu, Andrei A, Veness, Joel, Bellemare, Marc G,
Graves, Alex, Riedmiller, Martin, Fidjeland, Andreas K,
Ostrovski, Georg, et al. Human-level control through
deep reinforcement learning. Nature, 518(7540):529–
533, 2015.

Nair, Vinod and Hinton, Geoffrey E. Rectiﬁed linear units
improve restricted boltzmann machines. In Proceedings
of the 27th International Conference on Machine Learn-
ing (ICML-10), pp. 807–814, 2010.

Oliphant, Travis E. A guide to NumPy, volume 1. Trelgol

Publishing USA, 2006.

Pedregosa, Fabian, Varoquaux, Ga¨el, Gramfort, Alexan-
dre, Michel, Vincent, Thirion, Bertrand, Grisel, Olivier,
Blondel, Mathieu, Prettenhofer, Peter, Weiss, Ron,
Dubourg, Vincent, et al. Scikit-learn: Machine learning
in python. The Journal of Machine Learning Research,
12:2825–2830, 2011.

Peng, Jian, Bo, Liefeng, and Xu, Jinbo. Conditional neu-
ral ﬁelds. In Advances in neural information processing
systems, pp. 1419–1427, 2009.

Polyak, Boris T. Some methods of speeding up the conver-
gence of iteration methods. USSR Computational Math-
ematics and Mathematical Physics, 4(5):1–17, 1964.

Poon, Hoifung and Domingos, Pedro. Sum-product net-
works: A new deep architecture. In UAI 2011, Proceed-
ings of the Twenty-Seventh Conference on Uncertainty
in Artiﬁcial Intelligence, Barcelona, Spain, July 14-17,
2011, pp. 337–346, 2011.

Ratliff, Nathan D, Bagnell, J Andrew, and Zinkevich, Mar-
tin. (Approximate) subgradient methods for structured
prediction. In International Conference on Artiﬁcial In-
telligence and Statistics, pp. 380–387, 2007.

Rumelhart, David E, Hinton, Geoffrey E, and Williams,
Ronald J. Learning representations by back-propagating
errors. Cognitive modeling, 5(3):1, 1988.

Samaria, Ferdinando S and Harter, Andy C. Parameterisa-
tion of a stochastic model for human face identiﬁcation.
In Applications of Computer Vision, 1994., Proceedings
of the Second IEEE Workshop on, pp. 138–142. IEEE,
1994.

Simard, Patrice and LeCun, Yann. Reverse tdnn: an archi-
tecture for trajectory generation. In Advances in Neural
Information Processing Systems, pp. 579–588. Citeseer,
1991.

Smola, Alex J., Vishwanathan, S.v.n., and Le, Quoc V.
In Platt, J. C.,
Bundle methods for machine learning.
Koller, D., Singer, Y., and Roweis, S. T. (eds.), Advances
in Neural Information Processing Systems 20, pp. 1377–
1384. Curran Associates, Inc., 2008.

Szegedy, Christian, Liu, Wei, Jia, Yangqing, Sermanet,
Pierre, Reed, Scott, Anguelov, Dragomir, Erhan, Du-
mitru, Vanhoucke, Vincent, and Rabinovich, Andrew.
In Proceedings of
Going deeper with convolutions.
the IEEE Conference on Computer Vision and Pattern
Recognition, pp. 1–9, 2015.

Taskar, Ben, Chatalbashev, Vassil, Koller, Daphne, and
Guestrin, Carlos. Learning structured prediction models:
A large margin approach. In Proceedings of the 22nd In-
ternational Conference on Machine Learning, pp. 896–
903. ACM, 2005.

Todorov, Emanuel, Erez, Tom, and Tassa, Yuval. Mu-
joco: A physics engine for model-based control.
In
2012 IEEE/RSJ International Conference on Intelligent
Robots and Systems, pp. 5026–5033. IEEE, 2012.

Tsochantaridis, Ioannis, Joachims, Thorsten, Hofmann,
Thomas, and Altun, Yasemin. Large margin methods for
structured and interdependent output variables. Journal
of Machine Learning Research, 6:1453–1484, 2005.

Tsoumakas, Grigorios, Spyromitros-Xiouﬁs, Eleftherios,
Vilcek, Jozef, and Vlahavas, Ioannis. Mulan: A java
Journal of Machine
library for multi-label learning.
Learning Research, 12(Jul):2411–2414, 2011.

Van Rossum, Guido and Drake Jr, Fred L. Python refer-
ence manual. Centrum voor Wiskunde en Informatica
Amsterdam, 1995.

Wright, Stephen J. Primal-dual interior-point methods.

Siam, 1997.

Zheng, Shuai, Jayasumana, Sadeep, Romera-Paredes,
Bernardino, Vineet, Vibhav, Su, Zhizhong, Du, Dalong,
Huang, Chang, and Torr, Philip HS. Conditional random
In Proceedings of
ﬁelds as recurrent neural networks.
the IEEE International Conference on Computer Vision,
pp. 1529–1537, 2015.

