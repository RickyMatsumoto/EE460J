Adapting Kernel Representations Online Using Submodular Maximization

Matthew Schlegel 1 Yangchen Pan 1 Jiecao Chen 1 Martha White 1

Abstract

Kernel representations provide a nonlinear repre-
sentation, through similarities to prototypes, but
require only simple linear learning algorithms
given those prototypes. In a continual learning
setting, with a constant stream of observations,
it is critical to have an efﬁcient mechanism for
sub-selecting prototypes amongst observations.
In this work, we develop an approximately sub-
modular criterion for this setting, and an efﬁ-
cient online greedy submodular maximization al-
gorithm for optimizing the criterion. We extend
streaming submodular maximization algorithms
to continual learning, by removing the need for
multiple passes—which is infeasible—and in-
stead introducing the idea of coverage time. We
propose a general block-diagonal approximation
for the greedy update with our criterion, that en-
ables updates linear in the number of prototypes.
We empirically demonstrate the effectiveness of
this approximation, in terms of approximation
quality, signiﬁcant runtime improvements, and
effective prediction performance.

1. Introduction

Kernel representations provide an attractive approach to
representation learning, by facilitating simple linear pre-
diction algorithms and providing an interpretable represen-
tation. A kernel representation consists of mapping an in-
put observation into similarity features, with similarities to
a set of prototypes. Consequently, for an input observa-
tion, a prediction can be attributed to those prototypes that
are most similar to the observation. Further, the transfor-
mation to similarity features is non-linear, enabling non-
linear function approximation while using linear learning
algorithms that simply optimize for weights on these trans-
formed features. Kernel representations are universal func-

1Department of Computer Science,

sity, Bloomington. Correspondence
<martha@indiana.edu>.

Indiana Univer-
to: Martha White

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by
the author(s).

tion approximators1 and the ﬂexibility in choosing the ker-
nel (similarity function) has enabled impressive predic-
tion performance for a range of settings, including speech
(Huang et al., 2014), computer vision (Mairal et al., 2014),
and object recognition (Lu et al., 2014).

In a continual learning setting, such as in online learning or
reinforcement learning, there is a constant, effectively un-
ending stream of data, necessitating some care when using
kernel representations. The issue arises from the choice of
prototypes. Before the advent of huge increases in dataset
sizes, a common choice was to use all of the training data
as prototypes. This choice comes from the representer the-
orem, which states that for a broad class of functions, the
empirical risk minimizer is a linear weighting of similarity
features, to a set of prototypes that consists of the training
data. For continual learning, however, the update should be
independent of the the total number of samples— which is
not clearly deﬁned for continual learning. Conversely, we
want to permit selection of a sufﬁciently large number of
prototypes, to maintain sufﬁcient modeling power. For ef-
ﬁcient, continual updating, therefore, we require per-step
prototype selection strategies that are approximately linear
in the number of prototypes.

Currently, most algorithms do not satisfy the criteria for a
continual learning setting. Incremental selection of proto-
types has been tackled in a wide range of areas, due to the
fundamental nature of this problem. Within the streaming
community, approaches typically assume that the batch of
data, though large, is accessible and ﬁxed. The most re-
lated of these areas2 include active set selection for Gaus-
sian process regression (Seeger et al., 2003), with stream-
ing submodular maximization approaches (Krause et al.,
2008b;a; Badanidiyuru et al., 2014); incremental Nys-
trom methods within kernel recursive least-squares (KRLS)

1Radial basis function networks are an example of a kernel
representation, that have been shown to be universal function ap-
proximators (Park & Sandberg, 1991). Further, the representer
theorem further characterizes the approximation capabilities un-
der empirical risk minimization for a broad class of functions.

2Facility location, k-medians and k-centers are three problems
that focus on selecting representative instances from a set (c.f.
(Guha et al., 2003)). The criteria and algorithms are not designed
with the intention to use the instances for prediction and so we do
not consider them further here.

Adapting Kernel Representations Online Using Submodular Maximization

(Rudi et al., 2015)3; and functional gradients that sample
random bases which avoid storing prototypes but require
storing n scalars, for n training samples (Dai et al., 2014).

Kernel representation algorithms designed speciﬁcally for
the online setting, on the other hand, are typically too
computationally expensive in terms of the number of pro-
totypes. Kernel least-mean squares (KLMS) algorithms
use stochastic updates, maintaining the most recent pro-
totypes and truncating coefﬁcients on the oldest (Kivinen
et al., 2010; Schraudolph et al., 2006; Cheng et al., 2007);
though efﬁcient given sufﬁcient truncation, this truncation
can introduce signiﬁcant errors (Van Vaerenbergh & Santa-
maria, 2013). Random feature approximations (Rahimi &
Recht, 2007) can be used online, but require a signiﬁcant
number of random features. Gaussian process regression
approaches have online variants (Csat´o & Opper, 2006;
Cheng & Boots, 2016), however, they inherently require
at least quadratic computation to update the variance pa-
rameters. KRLS can be applied online, but has a thresh-
old parameter that makes it difﬁcult to control the num-
ber of prototypes and requires quadratic computation and
space (Engel et al., 2004). More efﬁcient coherence heuris-
tic have been proposed (Richard et al., 2009; Van Vaeren-
bergh et al., 2010; Chen et al., 2013; Van Vaerenbergh &
Santamaria, 2013), but provide no approximation quality
guarantees.

In this work, we provide a simple and efﬁcient greedy al-
gorithm for selecting prototypes for continual learning, by
extending recent work in prototype selection with submod-
ular maximization. We introduce a generalized coherence
criterion for selecting prototypes, which uniﬁes two previ-
ously proposed criteria: the coherence criterion and the log
determinant. Because this criterion is (approximately) sub-
modular, we pursue a generalization to streaming submod-
ular maximization algorithms. We avoid the need for multi-
ple passes over the data—which is not possible in continual
learning— by introducing the idea of coverage time, which
reﬂects that areas of the observation space are repeatedly
visited under sufﬁcient mixing. We prove that our online
submodular maximization achieves an approximation-ratio
of 1/2, with a small additional approximation introduced
due to coverage time and from using an estimate of the sub-
modular function. We then provide a linear-time algorithm
for approximating one instance of our submodular crite-
rion, by exploiting the block-diagonal form of the kernel
matrix. We empirically demonstrate that this approxima-
tion closely matches the true value, despite using signiﬁ-
cantly less computation, and show effective prediction per-
formance using the corresponding kernel representation.

3There is a large literature on fast Nystrom methods using re-
lated approaches, such as determinant point processes for sam-
pling landmark points (Li et al., 2016). The primary goal for these
methods, however, is to approximate the full kernel matrix.

2. Using kernel representations

2X

A kernel representation is a transformation of observations
into similarity features, consisting of similarities to proto-
types. A canonical example of such a representation is a ra-
dial basis function network, with radial basis kernels such
as the Gaussian kernel; however, more generally any kernel
similarity can be chosen. More formally, for observations
x
, the kernel representation consists of similarities to
z1, . . . , zb}⇢X
a set of prototypes S =
{
[k(x, z1), . . . , k(x, zb)]

2
for kernel k :
R. The observations need not be
numerical; as long as a similarity k can be deﬁned between
two observations, kernel representations can be used and
conveniently provide a numeric feature vector in Rb. We
use the term prototype, instead of center, to emphasize that
the chosen observations are representative instances, that
are sub-selected from observed data.

X⇥X!

!

b.

R

x

A fundamental result for kernel representations is the repre-
senter theorem, with signiﬁcant recent generalizations (Ar-
gyriou & Dinuzzo, 2014), which states that for a broad
class of function spaces
, the empirical risk minimizer
f

n
i=1 has the simple form

on a training set

2H

H
(xi, yi}

{

n

f (

) =

·

↵ik(

, xi).

·

i=1
X

This result makes use of a key property: the kernel func-
tion can be expressed as an inner product, k(xi, xj) =
for some implicit expansion  . The func-
 (xi),  (xj)
h
n
i=1 ↵i (xj), with
tion f can be written f =

i

f (x) =

 (x),

h

=

i

↵ih

 (x),  (xj)

.

i

n

P
↵i (xj)

i=1
X

n

i=1
X

⇥

Rb

It is typically impractical to use all xi as prototypes, and
a subset needs to be chosen. Recently, there has been sev-
eral papers (Krause et al., 2008b;a; Krause & Gomes, 2010;
Badanidiyuru et al., 2014) showing that prototypes can be
effectively selected in the streaming setting using greedy
submodular maximization on the log-determinant of the
b where (KS)ij = k(zi, zj).
kernel matrix, KS 2
Given some ground set ⌦ and its powerset
(⌦), submod-
P
ular functions g :
R are set functions, with a
!
diminishing returns property: the addition of a point to a
given set increases the value less or equal than adding a
point to a subset of that set. For prototype selection, the
ground set considered are sets of all observations
, so
S
. The log-determinant of the resulting kernel
matrix, log det KS, is a submodular function of S. Though
maximizing submodular functions is NP-hard, greedy ap-
proximation algorithms have been shown to obtain reason-
able approximation ratios, even for the streaming setting

⌦=

(⌦)

⇢

X

X

P

Adapting Kernel Representations Online Using Submodular Maximization

(Krause & Gomes, 2010; Badanidiyuru et al., 2014), and
the resulting algorithms are elegantly simple and theoreti-
cally sound.

In the following sections, we derive a novel criterion for
prototype selection, that includes the log-determinant as a
special case. Then, we provide an efﬁcient prototype se-
lection algorithm for the continual learning setting, using
submodular maximization.

3. Selecting kernel prototypes

Many prototype selection strategies are derived based on
diversity measures. The coherence criterion (Engel et al.,
2004) approximates how effectively the set of prototypes
spans the set of given observations. The log-determinant
measures the spread of eigenvalues for the kernel matrix,
and is related to information gain (Seeger, 2004). These
selection criteria are designed for a ﬁnite set of observed
points; here, we step back and reconsider a suitable objec-
tive for prototype selection for continual learning.

Our goal is to select prototypes that minimize distance to
the optimal function. In this section, we begin from this
objective and demonstrate that the coherence criterion and
log-determinant are actually upper bounds on this objec-
tive, and special cases of a more general such upper bound.
The analysis justiﬁes that the log-determinant is a more
suitable criteria for continual learning, which we then pur-
sue in the remainder of this work.

3.1. Criteria to select prototypes from a ﬁnite set

X

=

x1, . . . , xn}
{

Let
be a set of points, with corre-
sponding labels y1, . . . , yn. We will not assume that this
is a batch of data, but could rather consist of all possi-
ble observations for a ﬁnite observation space. Ideally, we
would learn S =
z1, . . . , zb}⇢X
and corresponding
{
b
, xi) according to the loss
i=1  jk(
) =
fS, (
·
f
min
2Rb k
 

fS, k

min
P
S
⇢X

(1)

 

2

·

where
k

f

fS, k

 

=

↵i (xi)

 j (zj)

n

i=1
X

 
 
 
 
 
 

b

 

j=1
X

 
 
 
 
 
 

for the optimal f for the set of points
. Because we do not
have f , we derive an upper bound on this value. Introducing
dummy variables  (i)

R such that  j =

i=1  (i)

X

n

,

j

j 2

n

↵i (xi)

 

(1)



S

min
, 

⇢X

= min
S
⇢X

n

i=1
X

2Rb

i=1
X

 
 
 
 
 
 
min
1 ,..., (i)
 (i)

b

 
 
 
 
 
 

2

b

P
 (i)
j  (zj)

 
 
 
 
 
 
 (i)
j  (zj)

j=1
X
b

 

j=1
X

2

 
 
 
 
 
 

↵i (xi)

(2)

.
= [k(xi, z1), . . . , k(xi, zb)], the interior minimiza-

For ki
tion can be re-written as

b

 (i)
j  (zj)

↵i (xi)

min
 (i)  
 
 
 
 
= min
 

 

 

j=1
X
 (i)>KS 

 

2

 
 
 
 
 
 

2↵i (i)>ki + ↵2

i k(xi, xi)

To provide more stable approximations, we regularize

(2)

min
S
⇢X



= min
S
⇢X

n

i=1
X
n

i=1
X

b

 

↵i (xi)

min
 (i)  
 
 
 
 
 (i)>(KS +  I) 
 

j=1
X

min
 (i)

2

 
 
 
 
 
 

 (i)
j  (zj)

+ 

 (i)
k

k

2
2

2↵i (i)>ki

 

+ ↵2

i k(xi, xi).

For   = 0, the inequality is equality. Otherwise adding reg-
ularization theoretically increases the upper bound, though
in practice will be key for stability.

Solving gives  (i) = ↵i(KS +  I) 

1ki, and so

 (i)>(KS +  I) 
= ↵2

 
i (KS +  I) 

i k>

2↵i (i)>ki + ↵2
2↵2
1ki  

i k(xi, xi)
i (KS +  I) 

i k>

1ki
i k(xi, xi)

+ ↵2

= ↵2

i k(xi, xi)

↵2

i k>

i (KS +  I) 

1ki

 

We can now simplify the above upper bound

(2)

min
S
⇢X



n

i=1
X

↵2

i k(xi, xi)

↵2

i k>

i (KS +  I) 

1ki

 

 
and obtain equivalent optimization

 

argmax

S

⇢X

n

i=1
X

↵2

i k>

i (KS +  I) 

1ki.

This criteria closely resembles the coherence criterion (En-
gel et al., 2004). The key idea for the coherence crite-
rion is to add a prototype xi, to kernel matrix KS if
1
⌫ for some threshold parameter ⌫. The
coherence criterion,

S ki 

kiK 

 

1

argmax

S

⇢X

n

i=1
X

k>

i (KS +  I) 

1ki

therefore, can be seen as an upper bound on the
distance
re-
laxation
1, . . . ,↵ 2
↵2
max
n}
{

n
i=1 k>i (KS +  I) 
P

optimal
n
i=1 ↵2

i k>i (KS +  I) 

the
because

function, with

further
1ki

1ki.



The relationship to another popular criterion—the log
determinant— arises when we consider the extension to an
inﬁnite state space.

P

Adapting Kernel Representations Online Using Submodular Maximization

3.2. Criteria to select prototypes from an inﬁnite set

The criterion above can be extended to an uncountably in-
. For this setting, the optimal
ﬁnite observation space
!(x) (x)dx, for a function ! : Rd
f =
R. Let
k(x, S) = [k(x, z1), . . . , k(x, zb)] Then, using a similar
analysis to above,

!

X

R

X

min
S
⇢X

f
min
2Rbk
 

 

!(x)2k(x, x)dx

2



min
fS, k
S
⇢X ZX
!(x)2k(x, S)>(KS +  I) 

1k(x, S)dx.

 

ZX

and so the resulting goal is to optimize

argmax

S

⇢X ZX

!(x)2k(x, S)>(KS +  I) 

1k(x, S)dx. (3)

This provides a nice relation to the log determinant cri-
terion, with normalized kernels4: k(z, z) = 1. If k(x, S)
[0, 1]b, and the function
maps to a unique kernel vector k
k(

, S) also maps onto [0, 1]b, then for !(x) = 1,

2

·

!(x)2k(x, S)>(KS +  I) 

1k(x, S)dx

ZX
=

Z

k>(KS +  I) 

1k dk

= det(KS +  I).

In general, it is unlikely to have a bijection k(
, S). More
generally, we can obtain the above criterion by setting the
coefﬁcient function ! so that each possible kernel vector
Rb has uniform weighting, or implicitly so the integra-
k
[0, 1]b. Because log is monoton-
tion is uniformly over k
ically increasing, maximizing det(KS +  I) with a ﬁxed b
is equivalent to maximizing log det(KS +  I).

2

2

·

This derivation of an upper bound on the distance to the op-
timal function provides new insights into the properties of
the log-determinant, clariﬁes the connection between the
coherence criterion and the log-determinant, and suggest-
ing potential routes for providing criteria based on the pre-
diction utility of a prototype. The choice of weighting ! to
obtain the log-determinant removes all information about
the utility of a prototype and essentially assumes a uni-
form distribution over the kernel vectors k. For more gen-
eral coefﬁcient functions !, let µ(S) = E[k(X, S)] and
⌃(S) = Cov(k(X, S)), where the expectations are ac-
cording to density !2/c for normalizer c =
!(x)dx.
By the quadratic expectations properties (Brookes, 2004)

X

R

(3) = argmax

tr((KS +  I) 

1⌃(S))

S

⇢X

+ µ(S)>(KS +  I) 

1µ(S).

(4)

4A kernel can be normalized by k(x, z)/

k(z, z)k(x, x).

p

This more general form in (4) enables prototypes to be
more highly weighted based on the magnitude of values
in !. We focus in this work ﬁrst on online prototype se-
lection for the popular log-determinant, and leave further
investigation into this more general criteria to future work.
We nonetheless introduce the form here to better motivate
the log-determinant, as well as demonstrate that the above
analysis is amenable to a host of potential directions for
more directed prototype selection.

4. Online submodular maximization

In this section, we introduce an OnlineGreedy algorithm
for submodular maximization, to enable optimization of the
prototype selection objective from an online stream of data.
Current submodular maximization algorithms are designed
for the streaming setting, which deals with incrementally
processing large but ﬁxed datasets. Consequently, the ob-
jectives are speciﬁed for a ﬁnite batch of observations and
the algorithms can do multiple passes over the dataset. For
the online setting, both of these conditions are restrictive.
We show that, with a minor modiﬁcation to StreamGreedy
(Krause & Gomes, 2010), we can obtain a comparable ap-
proximation guarantee that applies to the online setting.

We would like to note that there is one streaming algorithm,
called Sieve Streaming, designed to only do one pass of the
data and avoid too many calls to the submodular function
(Badanidiyuru et al., 2014); however, it requires keeping
parallel solutions, which introduces signiﬁcant complexity
and which we found prohibitively expensive. In our experi-
ments, we show it is signiﬁcantly slower than our approach
and found it typically maintained at least 500 parallel solu-
tions. For this reason, we opt to extend the simpler Stream-
Greedy algorithm, and focus on efﬁcient estimates of the
submodular function, since we will require more calls to
this function than Sieve Streaming.

Our goal is to solve the submodular maximization problem

max
S
:
|

⇢X

S

b

|

g(S)

(5)

X

is a general space of observations and g is a sub-
where
to be
modular function. The key modiﬁcation is to enable
a large, inﬁnite or even uncountable space. For such
, we
will be unable to see all observations, let alone make mul-
tiple passes. Instead, we will use a related notion to mixing
time, where we see a cover of the space.

X
X

The greedy algorithm consists of greedily adding in a new
prototype if it is an improvement on a previous prototype.
The resulting greedy algorithm—given in Algorithm 1— is
similar to StreamGreedy, and so we term it OnlineGreedy.
The algorithm queries the submodular function on each
set, with a previous prototype removed and the new ob-
servation added. To make this efﬁcient, we will rely on us-

Adapting Kernel Representations Online Using Submodular Maximization

Algorithm 1 OnlineGreedy

Input: threshold parameter ✏t, where a prototype is only
added if there is sufﬁcient improvement
S0   ;
xt}
for t = 1 : b do St  
while interacting, t = b + 1, . . . do

1 [{

St

 

)
xt}

1

 

St

z0 = argmax
z
2
St
St  
 
if ˆg(St)
 
St  

z0
1\{
ˆg(St
St
1

 

ˆg(St

z

 

}[{

1\{
xt}
}[{
1) <✏ t then
 

ing only an approximation to the submodular function g.
We will provide a linear-time algorithm—in the number of
prototypes— for querying replacement to all prototypes, as
opposed to a naive solution which would be cubic in the
number of prototypes. This will enable us to use this simple
greedy approach, rather than more complex streaming sub-
modular maximization approaches that attempt to reduce
the number of calls to the submodular function.

We bound approximation error, relative to the optimal so-
lution. We extend an algorithm that uses multiple passes;
our approach suggests more generally how algorithms from
the streaming setting can be extended to an online setting.
To focus the on this extension, we only consider submodu-
lar functions here; in Appendix B, we generalize the result
to approximately submodular functions. Many set func-
tions are approximately submodular, rather than submod-
ular, but still enjoy similar approximation properties. The
log-determinant is submodular, however, it is more likely
that, for the variety of choices for !, the generalized co-
herence criterion is only approximately submodular. For
this reason, we provide this generalization to approximate
submodularity, as it further justiﬁes the design of (approx-
imately) submodular criteria for prototype selection.

We compare our solution to the optimal solution

S⇤ = argmax
S

S

:

b

⇢X

|

|

g(S) =

z⇤1, . . . , z⇤b }
{

.

Assumption 1 (Submodularity). g is monotone increasing
and submodular.
Assumption 2 (Approximation error). We have access to
0 for
a set function ˆg that approximates g: for some ✏f  
all S

, with

b,

S

⇢X

|

|
ˆg(S)

|

g(S)

✏f

|

 

Assumption 3 (Submodular coverage time). For a ﬁxed
✏r > 0 and  > 0 there exists a ⇢

⇢
S⇤
X
an observation x is observed within ⇢ steps (starting from
) that is similar to z⇤ in that
any point in

N such that for all S
 , for any z⇤

b, with probability 1

where

|

 

2

2

S

|

X
g(S

|

x

)

}

 

[{

g(S

z⇤

)

}

|

[{

✏r.

This ﬁnal assumption characterizes that the environment is
sufﬁciently mixing, to see a cover of the space. We intro-
duce the term coverage, instead of cover time for ﬁnite-
state, to indicate a relaxed notion of observing a covering
of the space rather than observing all states.

For simplicity of the proof, we characterize the coverage
time in terms of the submodular function. We show that the
submodular function we consider—the log-determinant—
satisﬁes this assumption, given a more intuitive assumption
that instead requires that observations be similar according
to the kernel. The statement and proof are in Appendix A.

Now we prove our main result.
Theorem 1. Assume Assumptions 1-3 and that g(S⇤) is
ﬁnite and g(
0. Then, for t > ⇢g(S⇤)/✏t, all sets St
chosen by OnlineGreedy using ˆg satisfy, with probability
1

)
;

 

 ,

 

g(St)

g(S⇤)

(✏r + 2✏f + ✏t)

1
2

 

b
2

 

Proof: The proof follows closely to the proof of Krause
& Gomes (2010, Theorem 4). The key difference is that
we cannot do multiple passes through a ﬁxed dataset, and
instead use submodular coverage time.

Case 1: There have been t
⇢g(S⇤)/✏t iterations, and St
 
has always changed within ⇢ iterations (i.e., there has never
been ⇢ consecutive iterations where St remained the same).
This mean that for each ⇢ iterations, ˆg(St) must have been
improved by at least ✏t, which is the minimum threshold for
improvement. This means that over the t iterations, ˆg(S0)
has improved by at least ✏t each ⇢,

ˆg(S0) + ✏tt/⇢

✏tt/⇢ = ˆg(S⇤)

g(S⇤)

 

✏f

 

 

The solution is within ✏f of g(S⇤), and we are done.

Case 2: At some time t, St was not changed for ⇢ iterations,
i.e., St
1 = . . . St. Order the prototypes in the
⇢ = St
 
set as zi = argmaxz

z1, . . . , zi

z

 

 

⇢

 

1}[{
z1, . . . , zi
{

 

), with
}
).
1}

g(

 

2

St g(
{
z1, . . . , zi}
)
{
 i.
By Lemma 3,  i
1  

 i = g(

 

Because the point that was observed ri that was closest to
z⇤i was not added to S, we have the following inequalities

|

ˆg(S

ˆg(S

g(S

|

[{

[{

[{

)
ri}
ri}
)
)
ri}

 

 

 

g(S

ˆg(S

g(S

)
ri}
zb}
)
z⇤i }

|
)



|

[{

[{

[{

✏f
✏t
✏r

where the last inequality is true for all z⇤i with probability
 . Using these inequalities, as shown more explicitly in
1
the proof in the appendix, we get

 

g(S

)
z⇤i }

 

[{



g(S)

 b + ✏r + 2✏f + ✏t

Adapting Kernel Representations Online Using Submodular Maximization

Algorithm 2 BlockGreedy: OnlineGreedy for Prototype
Selection using a Block-Diagonal Approximation
r = block-size, with set of blocks
c, l book-keeping maps, with (c(B), l(B)) = (z, l) for z
leading to smallest utility loss l if removed from block B.
ge  

0 is the incremental estimate of log-determinant

, S0   ;

B

xt}
for t = 1 : b do, St  
while interacting, t = b + 1, . . . do

1 [{

St

 

if added b new prototypes since last clustering then

cluster St into
initialize with previous clustering; update c, l, ge

blocks with k-means,

b/r

c

b

BlockGreedy-Swap(xt)













By the deﬁnition of submodularity, g(S

S⇤)

g(S)

[

 



b
i=1 g(S

)
z⇤i }

g(S)).

 
Putting this all together, with probability 1
P

[{

 ,

 

g(S⇤)

g(S

S⇤)

[

b

g(S) +

g(S

)
z⇤i }

 

[{

g(S))

g(S) +

( b + ✏r + 2✏f + ✏t)

g(S) +

 i

+ b(✏r + 2✏f + ✏t)

i=1
X
b

i=1
X
b

i=1
X

!

 
i=1
X
b

= g(S) +

g(

)
s1, . . . , zi}

{

g(

z1, . . . , zi
{

1}

 

)

 

+ b(✏r + 2✏f + ✏t)
z1, . . . , zb}
{

g(S) + g(
2g(St) + b(✏r + 2✏f + ✏t)

) + b(✏r + 2✏f + ✏t)

where the last inequality uses g(S)
from monotonicity.



g(St) which follows
⌅

5. Block-diagonal approximation for efﬁcient
computation of the submodular function

The computation of the submodular function g is the criti-
cal bottleneck in OnlineGreedy and other incremental sub-
modular maximization techniques. In this section, we pro-
pose a time and memory efﬁcient greedy approach to com-
puting a submodular function on KS, enabling each step
of OnlineGreedy to cost O(db), where d is the feature di-
mension and b is the budget size. The key insight is to take
advantage of the block-diagonal structure of the kernel ma-
trix, particularly due to the fact that the greedy algorithm
intentionally selects diverse prototypes. Consequently, we
can approximately cluster prototypes into small groups of

Algorithm 3 BlockGreedy-Swap(x)

B1  
(z1, g1)

z

z

 

. returns the nearest block to x

get-block(x)
argmax
B1
= 0 and g1 
ge
return with no update if low percentage improvement
x

g(B1\{
<✏ t then

g(B1)

l(B)

}[{

)
}

 

x

ge

)

2

if ge 6

(B2, g2)

 

argmax
B1
B

2B\

g(B1 [{

}

 

}

else

z1}[{

. using Appendix E.3

. remove point from same block
x

if g1 < g2 then
B1\{
B1  
update c(B1)
ge  
ge + g1
. remove point from a different block
x
B1 [{
B1  
}
B2  
c(B2)
B2 \ {
}
update c(B1), c(B2)
ge + g2
ge  

. using Appendix E.3

size r, and perform updates on only these blocks.

Approximations to the kernel matrix have been extensively
explored, but towards the aim of highly accurate approxi-
mations for use within prediction. These methods include
low-rank approximations (Bach & Jordan, 2005), Nystrom
methods (Drineas & Mahoney, 2005; Gittens & Mahoney,
2013) and a block-diagonal method for dense kernel matri-
ces, focused on storage efﬁciency (Si et al., 2014). Because
these approximations are used for prediction and because
they are designed for a ﬁxed batch of data and so do not
take advantage of incrementally updating values, they are
not sufﬁciently efﬁcient for use on each step, and require at
least O(b2) computation. For OnlineGreedy, however, we
only need a more coarse approximation to KS to enable
effective prototype selection. By taking advantage of this
fact, saving computation with incremental updating and us-
ing the fact that our kernel matrix is not dense—making it
likely that many off-diagonal elements are near zero— we
can reduce storage and computation to linear in b.

The key steps in the algorithm are to maintain a clustering
of prototypes, compute all pairwise swaps between proto-
types within a block—which is much more efﬁcient than
pairwise swaps between all prototypes— and ﬁnally per-
form a single swap between two blocks. The computational
complexity of Algorithm 2 on each step is O(bd + r3)
for block size r (see Appendix F for an in-depth expla-
nation). We assume that, with a block-diagonal KS with
, the submodular function separates into g(S) =
blocks
B
g(B). For both the log-determinant and the trace
of the inverse of KS, this is the case because the in-
P
verse of a block-diagonal matrix corresponds to a block-
diagonal matrix of the inverses of these blocks. Therefore,
log det(KB).
log det(KS) =

2B

B

B

2B

We use this property to avoid all pairwise comparisons. If x
is added to S, it gets clustered into its nearest block, based

P

Adapting Kernel Representations Online Using Submodular Maximization

BlockGreedy Estimation

1

Block Greedy

Block Greedy with
only local replacement

Percentage
0.6
Accuracy

Block Greedy without clustering

FullGreedy

SieveStreaming

BlockGreedy

Log 
Determinant
60

BlockGreedy without clustering

Random

120

100

80

40

20

0

0.8

0.4

0.2

0

0

800
Time
(seconds)
600

1400

1200

1000

400

200

0

FullGreedy

SieveStreaming

BlockGreedy

500

1000

1500

2000

2500

3000

3500

Samples Processed

(a) log det of K

20

40
Block Size

60

80

100

100

200

400

500

600

300
Budget Size

(b) Estimate Accuracy, with b = 200

(c) Runtime with increasing b

Figure 1. Performance of BlockGreedy in Telemonitoring. Figure (a) shows the true log determinant of K for the prototypes selected
by each algorithm. Our algorithm, BlockGreedy, achieves almost the same performance as FullGreedy, which uses no approximation to
K to compute the log-determinant. Figure (b) shows the accuracy of the log determinant estimate as the block size increases. We can
see that clustering is key, and that for smaller block sizes, comparing between blocks is key. Figure (c) shows the runtime of the main
prototype selection competitors, FullGreedy and SieveStreaming, versus BlockGreedy with block size r = 10.

on distance to the mean of that cluster. To compute the
log-determinant for the new S, we simply need to recom-
pute the log-determinant for the modiﬁed block, as the log-
determinant for the remaining blocks is unchanged. There-
fore, if KS really is block-diagonal, computing all pairwise
swaps with x is equivalent to ﬁrst computing the least use-
ful point z in the closest cluster to x, and then determining
if g(S
) would be least reduced by removing z or
removing the least useful prototype from another cluster.
With some book-keeping, we maintain the least-useful pro-
totype for each cluster, to avoid recomputing it each step.

[{

x

}

6. Experiments

We empirically illustrate the accuracy and efﬁciency of our
proposed method as compared to OnlineGreedy with no
approximation to the submodular function (which we call
Full Greedy), Sieve Streaming, and various naive versions
of our algorithm. We also show this method can achieve
reasonable regression accuracy as compared with KRLS
(Engel et al., 2004). For these experiments we use four
well known datasets: Boston Housing (Lichman, 2015),
Parkinson’s Telemonitoring (Tsanas et al., 2010), Sante Fe
A (Weigend, 1994) and Census 1990 (Lichman, 2015). Fur-
ther details about each dataset are in Appendix C. We use a
Gaussian kernel for the ﬁrst three datasets, and a Hamming
distance kernel for Census, which has categorical features.
To investigate the effect of the block-diagonal approxima-
tion, we select the log-determinant as the criterion, which
is an instance of our criterion, and set   = 1.

Quality of the log-determinant approximation.

We ﬁrst investigate the quality of prototypes selection and
their runtimes, depicted in Figure 1. We compare our al-

gorithm with the FullGreedy, SieveStreaming and a ran-
dom prototype selection baseline. We also use variants of
our algorithm including without clustering—naively divid-
ing prototypes into equal-sized blocks—and one where we
only consider replacement in the closest block. We in-
clude these variants to indicate the importance of clustering
and of searching between blocks as well within blocks, in
BlockGreedy. For all experiments on maximization quality,
we use percentage gain with a threshold of ✏t = 0.001.

We plot the log determinant with increasing samples, in
Figure 1(a). Experiments on the other datasets are included
in Appendix C. BlockGreedy maximizes the submodular
function within 1% of the FullGreedy method. Though
BlockGreedy achieves nearly as high a log determinant
value, we can see that its approximation of the log deter-
minant is an overestimate for this small block size, r = 5.

|

gactual

gestimate

Our next experiment,
focuses on the esti-
therefore,
mate accuracy of BlockGreedy with increasing block
size, in Figure 1(b). The accuracy is computed by 1
 
gactual 
. We can see our algorithm, BlockGreedy
|
performs much better as compared to the other variants,
ranging in accuracy from 0.82 to 0.99. This suggests that
one can choose reasonably small block sizes, without in-
curring a signiﬁcant penalty in maximizing the log deter-
minant. In Figure 1(a), the estimate is inaccurate by about
20%, but follows the same trend of the full log determinant
and picks similar prototypes to those chosen by FullGreedy.

The runtime of our algorithm should be much less than
that of FullGreedy, and memory overhead much less than
SieveStreaming. In Figure 1(c), we can see our method
scales much better than FullGreedy and even has gains in
speed over SieveStreaming. Though not shown, the number
of sieves generated by SieveStreaming is large, in many in-
stances well over 600, introducing a signiﬁcant amount of

Adapting Kernel Representations Online Using Submodular Maximization

KRLS

 Root  
  Mean   
Square 
 Error  

5.5

6

5

3.5

3

2.5

Random

Sieve Streaming

Full Greedy

Block Greedy

50

100

150

200
Samples Processed

250

300

350

400

6.5
Root
Mean
6
Square
Error

5.5

7.5

8

7

4.5

4

Random

BlockGreedy without Clustering

BlockGreedy

KRLS

5

SieveStreaming

FullGreedy

True continuation

BlockGreedy
prediction

1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

(a) Boston housing

(b) Telemonitoring

(c) Santa Fe Data Set A

500

1000

1500

2000

2500

3000

3500

Samples Processed

0
1000

1020

1040

1060

1080

1100

Time Steps 1001-1100

Figure 2. Figure (a) is the learning curve on Bostondata, averaged over 50 runs, with ⌘ = 0.01. On average, KRLS uses 116.46
prototypes. Figure (b) is the learning curve on the Telemonitoring data set, over 50 runs, with b = 500 and ⌘ = 0.001. Figure (c) plots
the predicted values of our algorithm and true values. The regularizer ⌘ = 0.001, and the utility threshold is ✏t = 0.0001.

overhead. Overall, by taking advantage of the block struc-
ture of the kernel matrix, our algorithm obtains signiﬁcant
runtime and memory improvements, while also producing
a highly accurate estimate of the log determinant.

Learning performance for regression problems.

While the maximization of the submodular function is
useful in creating a diverse collection of prototypes, ulti-
mately we would like to use these representations for pre-
diction. In Figure 2, we show the effectiveness of solving
(KS +⌘I)w = y for the three regression datasets, by using
our algorithm to select prototypes for KS. For all regres-
sion experiments, we use a threshold of ✏t = 0.01 unless
otherwise speciﬁed.

For Boston housing data, in ﬁgure 2(a), we see that Block-
Greedy can perform almost as well as FullGreedy and
SieveStreaming, and outperforms KRLS at early learning
and ﬁnally converges to almost same performance. We set
the parameters for KRLS using the same parameter settings
for this dataset as in their paper (Engel et al., 2004). For
our algorithms we set the budget size to b = 80, which is
smaller than what KRLS used, and chose a block size of
4. We also have lower learning variance than KRLS, likely
because we use explicit regularization, whereas KRLS uses
its prototype selection mechanism for regularization.

On the Telemonitoring dataset, the competitive algorithms
all perform equally well, reaching a RMSE of approx-
imately 4.797. BlockGreedy, however, uses signiﬁcantly
less computation for selecting prototypes. We used a bud-
get of b = 500, and a block size of r = 25; a block size
of r = 5 for this many prototypes impacted the log de-
terminant estimation enough that it was only able to reach
a RMSE of about 5.2. With the larger block size, Block-
Greedy obtained a log determinant value within 0.5% of
FullGreedy.

On the benchmark time series data set Santa Fe Data Set
A, we train on the ﬁrst 1000 time steps in the series and
predict the next 100 steps, calculating the normalized MSE
(NMSE), as stated in the original competition. We set the
width parameter and budget size to that used with KRLS
after one iteration on the training set. The NMSE of our
algorithm and KRLS were 0.0434 and 0.026 respectively.
While our method performs worse, note that KRLS actually
runs on 6
1000 samples according to its description (En-
gel et al., 2004), but with 1000 samples it performs worse
with a NMSE of 0.0661. We demonstrate the 100-step fore-
cast with BlockGreedy, in Figure 2(c); we include forecast
plots for the other algorithms in Figure 4, Appendix C.4.

⇥

7. Conclusion

We developed a memory and computation efﬁcient incre-
mental algorithm, called BlockGreedy, to select centers for
kernel representations in a continual learning setting. We
derived a criterion for prototype selection, and showed that
the log-determinant is an instance of this criterion. We ex-
tended results from streaming submodular maximization,
to obtain an approximation ratio for OnlineGreedy. We
then derived the efﬁcient variant, BlockGreedy, to take ad-
vantage of the block-diagonal structure of the kernel ma-
trix, which enables separability of the criteria and faster
local computations. We demonstrated that, by taking ad-
vantage of this structure, BlockGreedy can signiﬁcantly re-
duce computation without incurring much penalty in max-
imizing the log-determinant and maintaining competitive
prediction performance. Our goal within continual learning
was to provide a principled, near-linear time algorithm for
prototype selection, in terms of the number of prototypes.
We believe that BlockGreedy provides one of the ﬁrst such
algorithms, and is an important step towards effective ker-
nel representations for continual learning settings, like on-
line learning and reinforcement learning.

Adapting Kernel Representations Online Using Submodular Maximization

Acknowledgements

This research was supported in part by NSF CCF-1525024,
IIS-1633215 and the Precision Health Initiative at Indiana
University. We would also like to thank Inhak Hwang for
helpful discussions.

References

Argyriou, A. and Dinuzzo, F. A Unifying View of Repre-
In International Conference on Ma-

senter Theorems.
chine Learning, 2014.

Bach, F. R. and Jordan, M. I. Predictive low-rank decom-
position for kernel methods. In International Conference
on Machine Learning, 2005.

Badanidiyuru, A., Mirzasoleiman, B., Karbasi, A., and
Krause, A. Streaming submodular maximization: mas-
sive data summarization on the ﬂy. Conference on
Knowledge Discovery and Data Mining, 2014.

Brookes, M. Matrix reference manual. Imperial College

London, 2004.

Chen, B., Zhao, S., Zhu, P., and Principe, J. C. Quan-
tized Kernel Recursive Least Squares Algorithm. IEEE
Transactions on Neural Networks and Learning Systems,
2013.

Cheng, C.-A. and Boots, B. Incremental Variational Sparse
Gaussian Process Regression. Advances in Neural Infor-
mation Processing Systems, 2016.

Cheng, L., Vishwanathan, S. V. N., Schuurmans, D., Wang,
S., and Caelli, S. W. Implicit Online Learning with Ker-
nels. In Advances in Neural Information Processing Sys-
tems, 2007.

Csat´o, L. and Opper, M. Sparse On-Line Gaussian Pro-

cesses. dx.doi.org, 2006.

Dai, B., Xie, B., He, N., Liang, Y., Raj, A., Balcan, M.-
F. F., and Song, L. Scalable Kernel Methods via Doubly
Stochastic Gradients. Advances in Neural Information
Processing Systems, 2014.

Das, A. and Kempe, D.

Submodular meets Spectral:
Greedy Algorithms for Subset Selection, Sparse Ap-
proximation and Dictionary Selection. arXiv.org, 2011.

Drineas, P. and Mahoney, M. W. On the Nystr¨om Method
for Approximating a Gram Matrix for Improved Kernel-
Based Learning. Journal of Machine Learning Research,
2005.

Gittens, A. and Mahoney, M. W. Revisiting the Nystrom
In
method for improved large-scale machine learning.
International Conference on Machine Learning, 2013.

Guha, S., Meyerson, A., Mishra, N., Motwani, R., and
O’Callaghan, L. Clustering Data Streams: Theory and
Practice. IEEE Transaction on Knowledge and Data En-
gineering, 2003.

Huang, P. S., Avron, H., and Sainath, T. N. Kernel methods
match deep neural networks on timit. IEEE International
Conference on Acoustics, Speech and Signal Processing,
2014.

Kivinen, J., Smola, A., and Williamson, R. C. Online learn-
ing with kernels. IEEE Transactions on Signal Process-
ing, 2010.

Krause, A. and Gomes, R. G. Budgeted nonparametric
learning from data streams. In International Conference
on Machine Learning, 2010.

Krause, A., McMahon, H. B., Guestrin, C., and Gupta, A.
Robust Submodular Observation Selection. Journal of
Machine Learning Research, 2008a.

Krause, A., Singh, A. P., and Guestrin, C. Near-Optimal
Sensor Placements in Gaussian Processes: Theory, Efﬁ-
cient Algorithms and Empirical Studies. Journal of Ma-
chine Learning Research, 2008b.

Li, C., Jegelka, S., and Sra, S. Fast DPP Sampling for Nys-
In Interna-

trom with Application to Kernel Methods.
tional Conference on Machine Learning, 2016.

Lichman, M. UCI machine learning repository. URL

http://archive. ics. uci. edu/ml, 2015.

Lu, Z., May, A., Liu, K., Garakani, A. B., Guo, D., Bellet,
A., Fan, L., Collins, M., Kingsbury, B., Picheny, M., and
Sha, F. How to Scale Up Kernel Methods to Be As Good
As Deep Neural Nets. CoRR abs/1202.6504, 2014.

Mairal, J., Koniusz, P., Harchaoui, Z., and Schmid, C. Con-

volutional Kernel Networks. NIPS, 2014.

Matic, I. Inequalities with determinants of perturbed posi-
tive matrices. Linear Algebra and its Applications, 2014.

Park, J. and Sandberg, I. Universal Approximation Using
Radial-Basis-Function Networks. Neural Computation,
1991.

Rahimi, A. and Recht, B. Random features for large-scale
In Advances in Neural Information

kernel machines.
Processing Systems, 2007.

Engel, Y., Mannor, S., and Meir, R. The kernel recursive
IEEE Transactions on Signal

least-squares algorithm.
Processing, 2004.

Richard, C., Bermudez, J. C. M., and Honeine, P. On-
line Prediction of Time Series Data With Kernels. IEEE
Transactions on Signal Processing, 2009.

Adapting Kernel Representations Online Using Submodular Maximization

Rudi, A., Camoriano, R., and Rosasco, L. Less is More:
Nystr¨om Computational Regularization. Advances in
Neural Information Processing Systems, 2015.

Schraudolph, N. N., Smola, A. J., and Joachims, T. Step
size adaptation in reproducing kernel Hilbert space.
Journal of Machine Learning Research, 2006.

Seeger, M. Greedy Forward Selection in the Informative

Vector Machine. 2004.

Seeger, M., Williams, C., and Lawrence, N. Fast Forward
Selection to Speed Up Sparse Gaussian Process Regres-
sion. Artiﬁcial Intelligence and Statistics, 2003.

Si, S., Hsieh, C.-J., and Dhillon, I. Memory efﬁcient kernel
approximation. In International Conference on Machine
Learning, 2014.

Tsanas, A., Little, M. A., and McSharry, P. E. Accu-
rate Telemonitoring of Parkinson’s Disease Progression
IEEE transactions on
by Noninvasive Speech Tests.
Biomedical Engineering, 2010.

Van Vaerenbergh, S. and Santamaria, I. A comparative
In Digi-
study of kernel adaptive ﬁltering algorithms.
tal Signal Processing and Signal Processing Education
Meeting, 2013.

Van Vaerenbergh, S., Santamar´ıa, I., Liu, W., and Principe,
J. C. Fixed-budget kernel recursive least-squares.
In
IEEE International Conference on Acoustics, Speech
and Signal Processing, 2010.

Weigend, A. S. Time Series Prediction: Forecasting the
Future and Understanding the Past. Santa Fe Institute
Studies in the Sciences of Complexity, 1994.

