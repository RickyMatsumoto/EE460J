The Sample Complexity of Online One-Class Collaborative Filtering

Reinhard Heckel 1 Kannan Ramchandran 1

Abstract

We consider the online one-class collaborative
ﬁltering (CF) problem that consists of recom-
mending items to users over time in an online
fashion based on positive ratings only. This prob-
lem arises when users respond only occasionally
to a recommendation with a positive rating, and
never with a negative one. We study the im-
pact of the probability of a user responding to
a recommendation, pf , on the sample complex-
ity, i.e., the number of ratings required to make
‘good’ recommendations, and ask whether re-
ceiving positive and negative ratings, instead of
positive ratings only, improves the sample com-
plexity. Both questions arise in the design of
recommender systems. We introduce a simple
probabilistic user model, and analyze the perfor-
mance of an online user-based CF algorithm. We
prove that after an initial cold start phase, where
recommendations are invested in exploring the
user’s preferences, this algorithm makes—up to
a fraction of the recommendations required for
updating the user’s preferences—perfect recom-
mendations. The number of ratings required for
the cold start phase is nearly proportional to 1/pf ,
and that for updating the user’s preferences is es-
sentially independent of pf . As a consequence
we ﬁnd that, receiving positive and negative rat-
ings instead of only positive ones improves the
number of ratings required for initial exploration
by a factor of 1/pf , which can be signiﬁcant.

1. Introduction

Recommender systems seek to identify the subset of a large
collection of items that a user likes (Aggarwal, 2016). In
practice, recommender systems often use collaborative ﬁl-
tering (CF) (Ekstrand et al., 2011) to identify items a given

1University of California, Berkeley, California, USA. Corre-

spondence to: Reinhard Heckel <heckel@berkeley.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

user likes, based on ratings that this user and a large num-
ber of other users have provided in the past. To this end,
a user-based CF algorithm ﬁrst identiﬁes similar users, and
then predicts the ratings of a given user from the ratings
provided by similar users. In practice, recommender sys-
tems typically operate in an online fashion, i.e., items are
recommended to users over time, and the ratings obtained
in response to recommendations are used to improve future
recommendations.

However, in many application areas of recommender sys-
tems, users only occasionally rate what they ‘like’, and
never what they ‘dislike’. E.g., in e-commerce, such as
Amazon’s recommender system, an item (or a set of items)
is recommended to a user, and the user either purchases
the item, which indicates a ‘like’, or the user does not pur-
chase the item. Not purchasing the item, however, does
not necessarily indicate a ‘dislike’, since the user might not
even have considered the recommendation. Other exam-
ples of such feedback include implicit ratings such as view-
ing a webpage and listening to a song (Hu et al., 2008), and
business-to-business recommender systems (Heckel et al.,
2017). The problem of generating recommendations based
on positive ratings only is known as one-class CF (Pan
et al., 2008). The lack of negative ratings is often consid-
ered to make this problem challenging (Pan et al., 2008).
However, it is unclear whether it is fundamentally more
difﬁcult in the absence of negative ratings to identify the
user’s preferences, in the sense that the sample complexity
(i.e., the number of ratings required to make good recom-
mendations) is fundamentally larger. Additionally, there is
little theoretical understanding on how the probability of a
user responding to a recommendation, pf , affects the sam-
ple complexity of a one-class CF algorithm and in particu-
lar its cold start time, i.e., the number of recommendations
the algorithm needs to invest in learning the user’s prefer-
ences before being able to make good recommendations.
In this paper, we address those two questions, that turn out
to be closely related.

To this end, we introduce a probabilistic model for a one-
class online recommender system and a corresponding on-
line user-based CF algorithm, termed User-CF, and ana-
lyze its performance. Our model, and elements of our
algorithm, are inspired by a related model and algorithm
by Bresler et al. (2014) for the two-class CF problem, i.e.,

Online One-Class Collaborative Filtering

for a setup where positive and negative ratings are avail-
In a nutshell, each user in our model has a latent
able.
probability preference vector which describes the extent
to which she likes or dislikes each item. Similar users
have similar preference vectors. At a given time step
t = 0, 1, . . ., the User-CF algorithm recommends a single
item to each user, typically different for each user. With
probability speciﬁed by a corresponding preference vector,
the user likes or dislikes the recommended item. If the user
likes the item, the user rates it with probability pf , and if
the user does not like the item, no rating is given. An item
that has been rated cannot be recommended again, since a
rating often corresponds to consuming an item, and there is
little point in, e.g., recommending a product that has been
previously purchased in the past for a second time. While
in practice the probability pf could be different for each
user, for ease of presentation, we assume that pf is con-
stant over all users. The goal of the User-CF algorithm is
to maximize the number of recommendations that a users
likes.

The User-CF algorithm consists of an exploitation step that
recommends items that similar users have rated positively,
and two kinds of exploration steps; one to learn the pref-
erences of the users and the other to explore similarity be-
tween users.

Our main result, stated in Section 4, guarantees that after
a certain cold start time in which the User-CF algorithm
1
recommends the order of (log(N )/p2
f )
1−α items to each
user, a fraction 1 − c/pf of the remaining recommendations
given by the User-CF algorithm are optimal. Here, α is a
learning rate that can be chosen very close to zero, N is
the number of users, and c a numerical constant. The cold
start time is required to identify similar users and learn their
preferences regarding a few items. We also show that any
algorithm has to make on the order of 1/p2
f recommenda-
tions before it can make good recommendations, therefore
the User-CF algorithm is near optimal. The fraction c/pf
of the remaining time steps is associated with learning the
preferences of the users. This ‘cost’ of c/pf does not have
to be paid upfront, but is paid continuously: After the cold
start time, the User-CF algorithm starts exploiting success-
fully. Again, a fraction of the recommendations propor-
tional to 1/pf is necessary to learn the preference of the
users. Our numerical results in Section 5 show that even if
our data is not generated from the probabilistic model, but
is based on real data, the cold start time and the fraction of
time steps required to learn the preferences of the users are
nearly proportional to 1/p2

f and 1/pf , respectively.

As a consequence of this result, we ﬁnd that obtaining pos-
itive and negative ratings instead of only positive ones, im-
proves the number of ratings required for the initial cold
start period by a factor of pf . To see this, note that the ex-

pected number of ratings obtained by a user in a given num-
ber of time steps or equivalently after a given number of
recommendations is proportional to pf . Thus, the number
of ratings required for the initial cold start time is inversely
proportional to pf , and the number of ratings required for
continuously learning the preferences is independent of pf .
Since pf = 1 corresponds to users giving positive and neg-
ative feedback (no positive feedback implies dislike when
pf = 1), the number of ratings required for the cold-start
time is by a factor of 1/pf larger than the number of ratings
required by a user-based CF algorithm that obtains positive
and negative ratings.

Those ﬁndings are relevant for the design of recommender
systems, since both pf and whether positive, or negative
and positive ratings are obtained can often be incorporated
in the design of a recommender system. Therefore an un-
derstanding of the associated beneﬁts and costs in terms
of sample complexity, as provided in this paper, is impor-
tant. We ﬁnally note that the goal of this paper is not to
improve upon state-of-the art algorithms, but rather to in-
form the design of algorithms and what to expect in terms
of sample complexity as a function of the various parame-
ters involved.

Related literature: While to the best of our knowledge,
this is the ﬁrst work that analytically studies one-class CF
in an online setting, theoretical results have been estab-
lished for the two or multiple class CF problems. One
of the ﬁrst analytical results on user-based CF algorithms,
an asymptotic performance guarantee under a probabilis-
tic model, was established by Biau et al. (2010). Most
related to our approach is the Collaborative-Greedy algo-
rithm studied by Bresler et al. (2014) for the online two-
class CF problem. The Collaborative-Greedy algorithm
differs from our User-CF algorithm in selecting the nearest
neighbors based on thresholding similarity, instead of se-
lecting the k most similar users, and in the way preferences
of the users are explored. This difference in the exploration
steps is crucial for establishing that after the cold start pe-
riod, our User-CF algorithm makes optimal recommenda-
tions in a fraction 1 − c/pf of the remaining time steps.
Dabeer (2013) studies a probabilistic model in an online
setup, and Barman & Dabeer (2012) study a probabilistic
model in an ofﬂine setup, and state performance guarantees
for a two-class user-based CF algorithm. Closely related to
user-based CF is item-based CF. Item-based CF exploits
similarity in item space by recommending items similar to
those a given user has rated positively in the past. Our re-
sults do not extend trivially to item-based CF, since a cor-
responding analysis requires assumptions on the similarity
in item space, and additionally the exploration strategies of
item-based CF algorithms are considerably different. We
do not discuss item based CF algorithms here, but refer
to (Bresler et al., 2015) for a recent analysis of an item

Online One-Class Collaborative Filtering

based CF algorithm for the two-class CF problem. Next,
we note that Deshpande & Montanari (2012) study rec-
ommender systems in the context of multi-armed bandits
(Bubeck & Cesa-Bianchi, 2012). Speciﬁcally, Deshpande
& Montanari (2012) consider a model where the (continu-
ous) ratings are described by the inner product of a user and
item feature vector, and assume the item feature vectors to
be given.

A conceptually related online learning problem are multi-
armed bandits with dependent arms (Pandey et al., 2007).
Speciﬁcally, in this variant of the multi-armed bandit prob-
lem, the arms are grouped into clusters, and the arms within
each cluster are dependent. The assignments of arms to
clusters are assumed known. In our paper, we assume that
users cluster in user types that have similar distributions.
Therefore, the learning problem in our paper can be viewed
as an multi-armed bandit problem with dependent arms, but
the assignment of the arms to clusters is unknown.

Finally, we note that a class of learning problems reminis-
cent to that considered here is partial monitoring (Bartók
et al., 2014). While partial monitoring has been studied in
the context of recommender systems (Kveton et al., 2015),
we are not aware of papers on partial monitoring in collab-
orative ﬁltering.

Outline:
In Section 2, we formally specify our model,
motivate it, and state the CF problem. Sections 3 and 4 con-
tain the User-CF algorithm and corresponding performance
guarantee, respectively. In Section 5 we provide numerical
results on real data. The proof of our main result can be
found in the supplementary material.

2. Model and learning problem
In this section we introduce the probabilistic model and
learning problem considered in this paper. As mentioned
previously, this model is inspired by that in (Bresler et al.,
2014) for the two-class CF problem.

Model: Consider N users and M items. A user may like
an item (+1), or dislike an item (−1). Associated with each
user is an (unknown) latent preference vector pu ∈ [0, 1]M
whose entries pui are the probabilities of user u liking item
i. We assume that an item i is either “likable” for user u,
i.e., pui > 1/2 + ∆, for some ∆ ∈ (0, 1/2], or “not lik-
able”, i.e., pui < 1/2 − ∆. The hidden ranking Rhidden
is
obtained at random as Rhidden
= 1 (like) with probability
pui, and Rhidden
= −1 (dislike) with probability 1 − pui.
The ratings are stochastic to model that users are not fully
consistent in their rating; the parameter ∆ quantiﬁes the in-
consistency (or uncertainty or noise). The one-class aspect
is incorporated in our model by assuming that users never
reveal that they dislike an item.

ui

ui

ui

Speciﬁcally, an CF algorithm operates on the model as fol-

lows. At each time step t = 0, 1, . . . the algorithm recom-
mends a single item i = i(t, u) to each user u—typically
this item is different for each user—and obtains an realiza-
tion of the binary random variable

(cid:40)

Rui =

Zui ∼ Bernoulli(pf ),
0,

if Rhidden
ui
if Rhidden
ui

= 1,
= −1

in response, independently across u and i. It follows that
P [Rui = 1] = puipf and P [Rui = 0] = 1 − puipf ,. Here,
pf corresponds to the probability of a user reporting a pos-
itive rating. As mentioned before, while one might treat
the slightly more general case of the probability pf being
different for each user, for ease of presentation, we assume
that it is constant over the users. If Rui = 1, user u con-
sumes item i, and i will not be recommended to u in subse-
quent time steps. Note that Rui = 0 means that either user
u does not like item i (Rhidden
= −1), or user u did not
respond to the recommendation. Therefore, if Rui = 0, i
may be recommended to u again in subsequent time steps.
Finally, observe that if pf = 1, the user provides positive
and negative ratings, since Rhidden
= 0 implies Rui = −1
if pf = 1.

ui

ui

In order to make recommendations based on the user’s pref-
erences, we must assume some relation between the users.
Following (Bresler et al., 2014), we assume that each user
belongs to one of K < N user types. Two users u and v
belong to the same type if they ﬁnd the same items likable,
i.e., if 1 {pui > 1/2 + ∆} = 1 {pvi > 1/2 + ∆}, for all
items i. This does not require the preference vectors pu and
pv of two users corresponding to the same user type to be
equivalent. We note that this assumption could be relaxed
by only assuming that users of the same type share a large
fraction of the items that they ﬁnd likable. We assume that
the preference vectors belonging to the same type are more
similar than those belonging to other types. Speciﬁcally,
assume that for all u ∈ [N ], [N ] := {0, 1, . . . , N − 1}, and
for some γ ∈ [0, 1),

γ min
v∈Tu

(cid:104)pu, pv(cid:105) ≥ max
v /∈Tu

(cid:104)pu, pv(cid:105) ,

(1)

where Tu ⊂ [N ] is the subset of all users that are of the
same type as u. The smaller γ, the more distinct users
of the same type are from users of another type. We fur-
ther assume that each user likes at least a fraction ν of the
items. This assumption is made to avoid degenerate situa-
tions were a user u does not like any item. Assuming that
users cluster in the user-item space in different user types
is common and is implicitly used by user-based CF algo-
rithms (Sarwar et al., 2000), which perform well in prac-
tice. To further justify this assumption empirically, we plot
in Figure 1 the clustering of user ratings of the Movielens
10 Million dataset (Harper & Konstan, 2015). Figure 1
shows that the user’s ratings cluster both in user and in item
space.

Online One-Class Collaborative Filtering

and exploiting, i.e., recommending items predicted to be
likable based on previous ratings. To this end, the User-
CF algorithm, formally introduced below, performs at time
t = 0, 1, . . ., either an preference exploration, similarity
exploration, or exploitation step.

An exploitation step ﬁrst identiﬁes the k most similar users
in terms of their rating vectors rv ∈ {0, 1}M , for a given
user u. The rating vectors consist of the responses Rui of
users to recommendations (u, i) made by the User-CF algo-
rithm at previous time steps. The exploitation step proceeds
by recommending the item that has received the largest
number of positive ratings from the nearest neighbors of
u in previous time steps. For an exploitation step to be
successful, it is crucial to ﬁnd similar users and learn their
preferences effectively. This is accomplished with similar-
ity exploration steps, that recommend the same items to
all users, and preference exploration steps that recommend
random items to certain subsets of the users. Before for-
mally stating the User-CF algorithm, we illustrate its main
steps using a toy example.

Example 1 Consider N = 6 users and M = 5 items, with
preference vectors pu and rating vectors ru at time t = 2
given by





















pT
0
pT
1
pT
2
pT
3
pT
4
pT
5





















rT
0
rT
1
rT
2
rT
3
rT
4
rT
5











.9
.9
.9
.1
.2
.1

=

.8
.8
.8
.3
.2
.1













1
1
1
0
0
0

=

0
1
1

0
0
0

.9
.9
.9
.1
.1
.3

0
0
0
1

0
0

.1
.2
.1
.8
.9
.7

0
0
0
0
1
0























,

.

.1
.3
.2
.7
.9
.8

0

0
0
0
0
0

Users 0, 1, 2 are of the same type as they ﬁnd items 0, 1, 2
likable, and users 3, 4, 5 belong to a second type as they
ﬁnd items 3, 4 likable. The preference vectors are obtained
by executing at time step 0 a preference exploration step,
that recommends the randomly chosen items 4, 1, 1, 2, 3, 3
to users 0, 1, . . . , 5, respectively, and a similarity explo-
ration step that recommends item 0 to all users. The re-
sponses Rui obtained from the similarity and preference
exploration step are marked with rectangles and circles, re-
spectively. Consider recommending an item to user 0 with
an exploitation step at time 2. The k = 2 nearest neigh-
bors of u = 0 are Nu = {1, 2} ((cid:104)r0, rv(cid:105) = 1 for v = 1, 2
and (cid:104)r0, rv(cid:105) = 0 for v = 3, 4, 5). Since (cid:80)
rvi is
maximized for i = 1 (rvi is the i-th entry of ru), item 1
is recommended to user u, which happens to be a likable

v∈Nu

Figure 1. The user-items rating matrix consisting of a subset of
the Movielens 10 Million dataset corresponding to the 1000 most
rated movies (columns) and the 1000 users (rows) that rated most
movies. The Movielens dataset consists of 10 Million movie rat-
ings in {1, 2, 3, 4, 5}; we took the ratings ≥ 4 as 1, ratings ≤ 3 as
−1, and missing ratings as 0; depicted in black, white, and gray.

Learning problem and reward: The goal of a CF algo-
rithm is to maximize reward. A reasonable reward for the
online CF problem is the expected number of recommen-
dations that a user rates positively, i.e., the pseudo-reward

T −1
(cid:88)

N −1
(cid:88)

t=0

u=0

E (cid:2)Rui(u,t)

(cid:3) .

Here, i(u, t) is the item recommended to u at time t. In
an e-commerce setting this corresponds to the number of
recommended products that a user buys. Note that due to
the uncertainty of a user liking an item (the random rating
Rhidden
might be −1 even when i is likable by u), we can-
ui
not expect to do better than maximizing the pseudo-reward.

In this paper our focus is on recommending likable items.
Following (Bresler et al., 2014) we therefore consider the
closely related accumulated reward deﬁned as the expected
total number of likable items (pui > 1/2) that are recom-
mended by an algorithm up to time T :

E [reward(T )] :=

E (cid:2)Xui(u,t)

(cid:3) .

(2)

T −1
(cid:88)

N −1
(cid:88)

t=0

u=0

Here, Xui(u,t) = 1 {pui > 1/2} is the indicator random
variable that is equal to one if item i(u, t) recommended
to user u at time t is likable and zero otherwise (note that
item i is chosen by the CF algorithm as a function of the
responses Ru(cid:48)i(cid:48) to recommendations (i(cid:48), u(cid:48)) made at previ-
ous time steps, and is therefore a random variable).

3. User-CF algorithm

In this section we present our user-based CF algorithm
(User-CF). In order to maximize reward the User-CF al-
gorithm balances exploring, i.e., learning about the users,

Online One-Class Collaborative Filtering

item, as desired.

We next formally describe the User-CF algorithm, and ex-
plain the intuition behind the speciﬁc steps. Input param-
eters of the User-CF algorithm are learning rates α and
η ∈ (0, 1) (e.g., η = 1/2) relevant for similarity and prefer-
ence exploration steps, respectively, a batch size Q relevant
for preference exploration steps, and ﬁnally the number of
nearest neighbors k, relevant for exploitation steps. Our re-
sults guarantee that for a range of input parameters that de-
pends on properties of the model such as the number of user
types and pf , the User-CF algorithm performs essentially
optimally. While we may or may not have prior knowledge
of those model parameters, in practice, we can optimize for
the hyper-parameters of the User-CF algorithm by using
cross validation.

At initialization, the User-CF algorithm generates a random
permutation π of the items [M ] required by the similarity
exploration step. Furthermore, it splits the item space into
M/Q random, and equally sized1 subsets of cardinality Q
(batches), denoted by Qq ⊂ [M ], q = 0, . . . , M/Q − 1.

At time steps t = (cid:98)ηQq(cid:99), q = 0, . . . , M/Q − 1, the User-
CF algorithm performs preference exploration steps. At
(t−q)α , q =
all other time steps, with probabilities pJ =
(cid:98)t/(ηQ)(cid:99), and pE = 1 − pJ , the algorithm performs simi-
larity exploration and exploitation steps, respectively.

1

Similarity exploration step: For each user u, recommend
the ﬁrst item i in the permutation π that has not been recom-
mended to user u in previous steps of the algorithm. This
step explores the item space and its important for select-
ing ‘good’ neighborhoods. Performing a sufﬁcient number
of similarity exploration steps allows to guarantee that the
nearest neighbors of a given user u are of the same type.

Preference exploration step: At time t = (cid:98)ηQq(cid:99), rec-
ommend to each user u an item, chosen independently and
uniformly at random from Qq, that has not been rated by u
in previous time steps. This step is important to learn the
preferences of users.

Exploitation step: For all users u, estimate the probability
of u liking a given item i as

containing only the responses Rui of user u to recommen-
dations i given in previous similarity exploration steps up
to time t, and is zero otherwise. Moreover, nui is the num-
ber of users in Nu that received recommendation i. Finally,
for each user u, recommend an item i that maximizes ˆpui(cid:48)
over all items i(cid:48) that have not been rated yet.

The idea behind the User-CF algorithm is as follows. An
exploitation step recommends likable items to u if a) most
of the neighbors of u are of the same user type as u, and
if b) the items are sufﬁciently well explored so that ˆpui in-
dicates whether i is likable by u (i.e., pui > 1/2) or not,
for all i. A large portion of the ﬁrst few steps is likely to
be spent on similarity exploration. This is sensible, as we
need to ensure that a) is satisﬁed in order to make good
recommendations. As time evolves, the User-CF algorithm
randomly explores batches of items, one batch at a time, in
order to estimate the preferences of the users regarding the
items in the corresponding batches. Note that if the User-
CF algorithm would explore the entire item space at once,
e.g., by recommending an item chosen at random from all
items, the time required for the algorithm to make ‘good’
recommendations would grow linearly in M , and M might
be very large. By splitting the item space into batches Qq,
the User-CF algorithm can start exploiting without having
learned the preferences of the users regarding all items. Fi-
nally note that the User-CF algorithm may recommend the
same item at several time steps (unless the item is rated by
the user); this is sensible in particular if pf is small.

4. Main result
Our main result, stated below, shows that after a certain
cold start time, the User-CF algorithm produces essentially
optimal recommendations.

Theorem 1 Suppose that there are at least N
2K users of the
same type, for all user types, and that condition (1) holds
for some γ ∈ [0, 1], which ensures that user types are dis-
tinct. Moreover, assume that at least a fraction ν of all
items is likable to a given user, for all users. Pick δ > 0
and suppose that there are sufﬁciently many users per user
type:

c

N
K

≥

νpf ∆2 log(M/δ) log(4/δ).

(4)

ˆpui =

(cid:40) 1
nui
0,

(cid:80)

v∈Nu

Rvi,

if nui > 0,
if nui = 0.

(3)

Set

Here, Rvi is the rating of user v for item i obtained in pre-
vious time steps (we use the convention Rvi = 0 if no
rating was obtained at a previous time step). Next, Nu is
the set of users corresponding to the k largest values of
(cid:10)rsim
u ∈ {0, 1}M is the vector

(cid:11) , v ∈ [N ]. Here, rsim

u , rsim
v

1We assume for simplicity that M is divisible by Q, if this is
not the case, batch (cid:100)M/Q(cid:101) − 1 may simply contain less than Q
items.

Tstart :=
(cid:18) ˜c log(N/δ)
p2
f (1 − γ)2ν)

(cid:19) 1

1−α (cid:18)

1 − max

(cid:18) 1
T

,

K
N

c log(M/δ)
pf ∆2

(cid:19)(cid:19)

,

where ˜c is a numerical constant. Then, for appropriate
choices2 of the parameters η, k, and Q, the expected re-
ward accumulated by the User-CF algorithm up to time

2 Speciﬁcally, η = c1ν,

k = c2

N
K ,

and Q =

Online One-Class Collaborative Filtering

T ∈ [Tstart, 4

E [reward(T )]
N T

5 νM pf ] satisﬁes
(cid:18)

≥

1 −

− 2α (T − Tstart)1−α

T (1 − α)

Tstart + 1
T
c log(M/δ)
pf ∆2

K
N

−

(cid:19)

(1 − δ).

(5)

c log(M/δ)
pf ∆2

Theorem 1 states that after an initial cold start time on the
order of Tstart, the User-CF algorithm recommends only
likable items up to a fraction K
of the time steps.
N
This follows since a oracle that only recommends likable
items obtains an reward of E [reward(T )] = N T . This
yields the claim from the introduction, that after the cold
start time, a fraction 1 − c/pf of all recommendations made
by the User-CF algorithm are likable. Note that condi-
tion (4) allows the number of user types, K, to be near
linear in the number of users, N .

We note that the particular choice of the parameters of the
User-CF algorithm in Theorem 1 is mainly out of exposi-
tional convenience; the supplementary material contains a
more general statement.

Theorem 1 is proven by showing that after the initial cold
start time, exploration steps recommend likable items with
very high probability. An exploration step recommends a
likable item to user u provided that

a) most of the nearest neighbors of u are of the same user

type, and

b) the items are sufﬁciently well explored so that the max-
imum of ˆpui over items not rated yet corresponds to a
likable item.

For a), we use that the user types are sufﬁciently distinct
and that most of the nearest neighbors of u are of the
same user type. The former is ensured by condition (1),
and the latter holds after the initial cold start time which
ensures that sufﬁciently many similarity exploration steps
have been executed. After the initial cold start time, most
of the nearest neighbors of u are of the same user type, and
essentially no further cost is required to learn the neigh-
borhoods. This is reﬂected in the lower bound (5), by the
terms depending on T becoming negligible as T becomes
large compared to Tstart. Note the dependence of Tstart on
γ; the more similar the user types are (i.e., the closer γ is
to 1), the longer it takes till User-CF is guaranteed to ﬁnd
good neighborhoods.

4.1. Dependence on pf is nearly optimal
The cold start time of the User-CF algorithm guaranteed by
1
Theorem 1 is proportional to (1/p2
f )
1−α . For small learn-
ing rates α, this scaling can not be improved signiﬁcantly,
as the following results shows.

c3

kpf ∆2
log(M/δ) , for numerical constants c1, c2, and c3.

Proposition 1 Suppose that there are more items than user
types, i.e., M ≥ K. Fix λ ∈ (0, 1). Then there is a set of
users with at least N
2K users of the same type, for each user
type, with preference vectors such that for all T ≤ λ
, the
p2
f
expected reward of any online algorithm is upper bounded
by

E[reward(T )]
T N

≤ λ + 1
K .

Proposition 1 shows that if the cold start time is signiﬁ-
cantly smaller than 1/p2
f , then there are problem instances
for which any algorithm mostly recommends non-likable
items. The proposition is a consequence of the fact that
after making on the order of 1/p2
f recommendations, for
many users we did not obtain any rating. A consequence
of the proposition is that the cold start time of the User-CF
algorithm is near optimal.

c log(M/δ)
pf ∆2

Recall that even after the initial cold start time, a constant
fraction of K
of the recommendations might be
N
non-likable. This fraction is the cost for establishing b).
Speciﬁcally, in order to ensure b), the User-CF algorithm
needs to recommend sufﬁciently many items to the k neigh-
bors of u so that ˆpui indicates whether user u likes item i or
not, or more precisely such that the maximum of ˆpui over
items not rated yet corresponds to a likable item. This is es-
tablished by showing that ˆpui > pf /2 for all likable items
t
i ∈ Qq, q = 0, . . . ,
ηQ − 1, and ˆpui < pf /2 for all other
items. Since the expected number of positive ratings per
recommendation is proportional to pf , the number of rat-
ings required to ensure that pui > pf /2 is proportional to
1/pf .

4.2. One versus two class CF
Recall that pf = 1 implies that users provide positive and
negative ratings, and that the User-CF algorithm is nearly
optimal in pf . Since the expected number of ratings ob-
tained by a user in a given number of time steps is propor-
tional to pf , a consequence of our result is that receiving
positive and negative ratings instead of only positive ones
improves the number of ratings required for initial explo-
ration by a factor of 1/pf , which can be signiﬁcant.

We ﬁnally note that Bresler et al. (2014) proved a perfor-
mance guarantee for a closely related two-class collabo-
rative CF algorithm termed Collaborative-Greedy. Bresler
et al. (2014) consider the regime where the number of
users is much larger than the number of items, i.e., N =
O(M C), C > 1 and additionally the number of user types
obeys (N = O(KM )). For this regime, Theorem 1 par-
ticularized to pf = 1 essentially reduces to Theorem 1 in
(Bresler et al., 2014) (there are some further minor differ-
ences). However, our result particularized to the two-class
case also holds when the number of items is much larger
than the number of users, and allows the number of user
types to be near linear in the number of users. This im-
provement is due to differences in the preference explo-

Online One-Class Collaborative Filtering

ration strategies of the algorithms.

4.3. Alternative exploration strategies
While there are other sensible preference exploration
strategies, the essential element of our approach is to split
up the item space into subsets of items Q0, Q1, . . ., start by
exploring Q0, then allow for exploitation steps, continue
with exploring Q1, again allow for exploitation steps and
so forth. If one explores instead the whole item space [M ]
at the beginning, the learning time required for ˆpui to in-
dicate whether an item is likable or not, is proportional to
M , and can therefore be very large. To see this, consider a
preference exploration step that recommends a single item
to all users, chosen uniformly at random from the set of
all items [M ]. The expected number of ratings obtained
by executing Tr such preference exploration steps relevant
for estimating whether pui > 1/2, is the expected number
of neighbors of u to which i has been recommend, and is
therefore proportional to Trk/M . To ensure that this ex-
pectation is larger than 0, Tr has to be on the order or M
(provided that the other parameters are ﬁxed).

5. Numerical results
In this section, we simulate an online recommender system
based on real-world data in order to understand whether
the User-CF algorithm behaves as predicted by Theorem
1, even when the data is not generated by the probabilistic
model, but is based on real data. While an ideal dataset
to validate our algorithm would consist of the ratings from
all users for all items, the vast majority of ratings in stan-
dard CF datasets such as the Netﬂix or Movielens dataset
(consisting of movie ratings) are unknown. To obtain
a dataset with a higher proportion of ratings, following
(Bresler et al., 2014), we consider the subset of the Movie-
lens dataset corresponding to frequently rated items and to
users that have rated many items. The Movielens dataset
consists of 10 Million movie ratings in {1, 2, 3, 4, 5}; we
took the ratings ≥ 4 as 1, ratings ≤ 3 as −1, and miss-
ing ratings as 0. Many of the items (movies) in the dataset
have a signiﬁcant bias towards a positive or negative rat-
ing. To make sure our results are not due to exploiting such
biases, we only select frequently rated items out of the (ap-
proximately) unbiased items. Note that a nearest neigh-
bor based algorithm, like the User-CF algorithm, performs
well in case the item ratings are very biased even when
the neighborhoods are randomly selected. Of the resulting
dataset, denoted by RML ∈ {−1, 0, 1}1000×500, 18.1% of
the ratings are 1, 17.1% are −1, and the remaining ones are
unknown and therefore set to 0.

One class versus two class CF: We start with compar-
ing the qualitative behavior of the User-CF algorithm to a
two-class version of the User-CF algorithm. The two-class
version of the User-CF algorithm differs from the one-class
version in taking into account the negative ratings. Specif-

)
T
(
d
r
a
w
e
r
-
c
c
a

40

20

0

one-class
two-class

T

0

100

200

300

400

500

Figure 2. Comparison of one and two class recommenders.

ically, the ratings Rvi in (3) for the two-class version or
the User-CF algorithm are set to −1, 0, and 1, if a nega-
tive, none, or a positive rating was obtained as a response
to a recommendation. We performed the following experi-
ment. If the User-CF algorithm recommends item i to user
u, it obtains the rating Rui = 1 in response provided that
[RML]ui = 1 ([RML]ui denotes the (u, i)-th entry of RML),
and Rui = 0 otherwise, while the two-class User-CF algo-
rithm obtains Rui = [RML]ui in response. We allow both
algorithms to only recommend an item to a given user once,
so after M = 500 time steps, all items have been recom-
mend to all users. We measure performance in terms of the
accumulated reward, deﬁned as

acc-reward(T ) :=

reward(t),

reward(t) :=

[RML]ui(u,t),

(6)

where i(u, t) is the item recommended to user u by the cor-
responding variant of the User-CF algorithm. The results,
depicted in Figure 3, show that the two-class recommender
performs better, as expected, since it obtains signiﬁcantly
more ratings. Speciﬁcally, the expected number of ratings
it obtains is almost twice the expected number of ratings
the one-class User-CF algorithm obtains. After having rec-
ommend most of the likable items, mostly non-likable are
left to recommend, which explains the inverse U -shape in
Figure 3.

Dependence of User-CF on pf : We next validate empir-
ically that the cold start time and number of preference
exploration steps (needed to learn the preferences of the
users) scale as 1/p2
f and 1/pf , respectively. We start with
the former. To this end, we split the items into two ran-
dom disjoint sets I1 ⊂ [M ] and I2 ⊂ [M ] of equal car-
dinality. We then perform the following experiment for

T −1
(cid:88)

t=0

1
N

N −1
(cid:88)

u=0

)
s
T
(
d
r
a
w
e
r

0.14

0.12

0.1

0.08

0.06

Online One-Class Collaborative Filtering

0.2

)
r
T
(
d
r
a
w
e
r

0.15

0.1

0.05

References

Springer, 2016.

Aggarwal, Charu C. Recommender systems: The textbook.

pf = 1
pf = 0.75
pf = 0.5

40

20
Tr/pf

Bardenet, Rémi and Maillard, Odalric-Ambrym. Concen-
tration inequalities for sampling without replacement.
Bernoulli, 21(3):1361–1385, 2015.

Barman, Kishor and Dabeer, Onkar. Analysis of a col-
laborative ﬁlter based on popularity amongst neighbors.
IEEE Trans. Inf. Theory, 58(12):7110–7134, 2012.

0

20

10
Ts/p2
f

30

0

Figure 3. Left: Reward obtained from a single exploitation step,
after performing Ts similarity exploration steps and a ﬁxed num-
ber of preference exploration steps. Right: Reward obtained from
a single exploration step, after performing Tr preference explo-
ration steps and a ﬁxed number of similarity exploration steps.

pf ∈ {1, 0.75, 0.5}. We start by recommending 3M
items,
kpf
chosen uniformly at random from I2 to each user, and, pro-
vided the corresponding rating is positive ([RML]ui = 1),
we provide this rating to the User-CF algorithm with proba-
bility pf . The expected number of positive ratings obtained
is therefore independent of pf . Those preference explo-
ration steps make sure that the preferences of the items in
I2 are explored well. We then perform Ts similarity explo-
ration steps on the items in the sets I1 = {i0, . . . , iM/2−1},
by recommending item it to user u at t = 0, . . . , Ts − 1.
If [RML]uit = 1 then we provide the rating [RML]uit to the
User-CF algorithm with probability pf . After Ts such sim-
ilarity exploration steps, we perform an exploitation step.
In Figure 3 we plot the reward deﬁned in (6) obtained by
the exploitation step, over Ts/p2
f . The results conﬁrm that
the cold start time required to ﬁnd ‘good’ neighborhoods
scales inversely proportional to p2
f , since all three curves
lie on top of each other.

Next, we demonstrate that the number of preference explo-
ration steps required to learn the preferences of the users
is proportional to 1/pf . To this end, we perform the same
experiment as above, this time, however, we ﬁrst perform
Ts = 25/p2
f similarity exploration steps on the items in the
set I1, and then perform Tr preference exploration steps
by recommending Tr items, chosen uniformly at random
from I2 to each user. As before, if [RML]ui = 1, the rating
[RML]ui is provided to the algorithm with probability pf .
In Figure 3 we plot the reward obtained from performing
a single exploitation step after Tr such preference explo-
ration steps over Tr/pf . The results indicate that, as pre-
dicted by our theory, the number of preference exploration
steps required to learn the preferences is proportional to pf ,
as the curves for different pf lie on top of each other. As
mentioned previously, this is not surprising, as the number
of positive ratings obtained is proportional to pf .

Bartók, Gábor, Foster, Dean P., Pál, Dávid, Rakhlin,
Alexander, and Szepesvári, Csaba. Multi-armed bandit
problems with dependent arms. Math. Oper. Res., 39(4):
967–997, June 2014.

Biau, Gérard, Cadre, Benoît, and Rouvière, Laurent. Sta-
tistical analysis of k-nearest neighbor collaborative rec-
ommendation. Ann. Stat., 38(3):1568–1592, 2010.

Bresler, Guy, Chen, George H, and Shah, Devavrat. A la-
tent source model for online collaborative ﬁltering.
In
Advances in Neural Information Processing Systems, pp.
3347–3355. 2014.

Bresler, Guy, Shah, Devavrat, and Voloch, Luis F. Re-
gret guarantees for item-item collaborative ﬁltering.
arXiv:1507.05371, 2015.

Bubeck, Sébastien and Cesa-Bianchi, Nicolò. Regret anal-
ysis of stochastic and nonstochastic multi-armed bandit
problems. Foundations and Trends in Machine Learn-
ing, 5, 2012.

Dabeer, O. Adaptive collaborating ﬁltering: The low noise
regime. In IEEE International Symposium on Informa-
tion Theory, pp. 1197–1201, 2013.

Deshpande, Yash and Montanari, Andrea. Linear bandits
in high dimension and recommendation systems. In An-
nual Allerton Conference on Communication, Control,
and Computing, pp. 1750–1754, October 2012.

Ekstrand, Michael D., Riedl, John T., and Konstan,
Joseph A. Collaborative ﬁltering recommender sys-
tems. Found. Trends Hum.-Comput. Interact., 4(2):81–
173, 2011.

Harper, F. Maxwell and Konstan, Joseph A. The Movie-
Lens datasets: History and context. ACM Trans. Inter-
act. Intell. Syst., 5(4):19:1–19:19, 2015.

Heckel, Reinhard, Vlachos, Michail, Parnell, Thomas, and
Scalable and interpretable prod-
Dünner, Celestine.
uct recommendations via overlapping co-clustering. In
IEEE International Conference on Data Engineering,
2017.

Online One-Class Collaborative Filtering

Hu, Yifan, Koren, Yehuda, and Volinsky, Chris. Collabo-
In IEEE
rative ﬁltering for implicit feedback datasets.
International Conference on Data Mining, pp. 263–272,
2008.

Kveton, Branislav, Szepesvari, Csaba, Wen, Zheng, and
Ashkan, Azin. Cascading Bandits: Learning to Rank
in the Cascade Model. In International Conference on
Machine Learning, pp. 767–776, 2015.

Pan, Rong, Zhou, Yunhong, Cao, Bin, Liu, N.N., Lukose,
R., Scholz, M., and Yang, Qiang. One-class collabora-
tive ﬁltering. In IEEE International Conference on Data
Mining, pp. 502–511, 2008.

Pandey, Sandeep, Chakrabarti, Deepayan, and Agarwal,
Deepak. Multi-armed Bandit Problems with Dependent
Arms. In International Conference on Machine Learn-
ing, ICML ’07, pp. 721–728, New York, NY, USA,
2007.

Sarwar, Badrul, Karypis, George, Konstan, Joseph, and
Riedl, John. Analysis of recommendation algorithms for
In ACM Conference on Electronic Com-
e-commerce.
merce, pp. 158–167, 2000.

