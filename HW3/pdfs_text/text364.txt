Provable Alternating Gradient Descent for Non-negative Matrix Factorization
with Strong Correlations

Yuanzhi Li 1 Yingyu Liang 1

Abstract

Non-negative matrix factorization is a basic tool
for decomposing data into the feature and weight
matrices under non-negativity constraints, and in
practice is often solved in the alternating min-
imization framework. However,
it is unclear
whether such algorithms can recover the ground-
truth feature matrix when the weights for differ-
ent features are highly correlated, which is com-
mon in applications. This paper proposes a sim-
ple and natural alternating gradient descent based
algorithm, and shows that with a mild initializa-
tion it provably recovers the ground-truth in the
presence of strong correlations. In most interest-
ing cases, the correlation can be in the same order
as the highest possible. Our analysis also reveals
its several favorable features including robust-
ness to noise. We complement our theoretical
results with empirical studies on semi-synthetic
datasets, demonstrating its advantage over sev-
eral popular methods in recovering the ground-
truth.

1. Introduction

Non-negative matrix factorization (NMF) is an important
tool in data analysis and is widely used in image process-
ing, text mining, and hyperspectral imaging (e.g., (Lee &
Seung, 1997; Blei et al., 2003; Yang & Leskovec, 2013)).
Given a set of observations Y = {y(1), y(2), . . . , y(n)},
the goal of NMF is to ﬁnd a feature matrix A =
{a1, a2, . . . , aD} and a non-negative weight matrix X =
{x(1), x(2), . . . , x(n)} such that y(i) ≈ Ax(i) for any i, or
Y ≈ AX for short. The intuition of NMF is to write each
data point as a non-negative combination of the features.

Authors

listed in alphabetic order.
NJ,
Princeton,

1Princeton Uni-
versity,
to:
Yuanzhi Li <yuanzhil@cs.princeton.edu>, Yingyu Liang
<yingyul@cs.princeton.edu>.

Correspondence

USA.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

By doing so, one can avoid cancellation of different fea-
tures and improve interpretability by thinking of each x(i)
as a (unnormalized) probability distribution over the fea-
tures. It is also observed empirically that the non-negativity
constraint on the coefﬁcients can lead to better features and
improved downstream performance of the learned features.

Unlike the counterpart which factorizes Y ≈ AX with-
out assuming non-negativity of X, NMF is usually much
harder to solve, and can even by NP-hard in the worse
case (Arora et al., 2012b). This explains why, despite all
the practical success, NMF largely remains a mystery in
theory. Moreover, many of the theoretical results for NMF
were based on very technical tools such has algebraic ge-
ometry (e.g., (Arora et al., 2012b)) or tensor decomposi-
tion (e.g.
(Anandkumar et al., 2012)), which undermine
their applicability in practice. Arguably, the most widely
used algorithms for NMF use the alternative minimization
scheme: In each iteration, the algorithm alternatively keeps
A or X as ﬁxed and tries to minimize some distance be-
tween Y and AX. Algorithms in this framework, such
as multiplicative update (Lee & Seung, 2001) and alterna-
tive non-negative least square (Kim & Park, 2008), usually
perform well on real world data. However, alternative min-
imization algorithms are usually notoriously difﬁcult to an-
alyze. This problem is poorly understood, with only a few
provable guarantees known (Awasthi & Risteski, 2015; Li
et al., 2016). Most importantly, these results are only for
the case when the coordinates of the weights are from es-
sentially independent distributions, while in practice they
are known to be correlated, for example, in correlated topic
models (Blei & Lafferty, 2006). As far as we know, there
exists no rigorous analysis of practical algorithms for the
case with strong correlations.

In this paper, we provide a theoretical analysis of a nat-
ural algorithm AND (Alternative Non-negative gradient
Descent) that belongs to the practical framework, and show
that it probably recovers the ground-truth given a mild ini-
tialization. It works under general conditions on the feature
matrix and the weights, in particular, allowing strong cor-
It also has multiple favorable features that are
relations.
unique to its success. We further complement our theoreti-
cal analysis by experiments on semi-synthetic data, demon-

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

strating that the algorithm converges faster to the ground-
truth than several existing practical algorithms, and provid-
ing positive support for some of the unique features of our
algorithm. Our contributions are detailed below.

1.1. Contributions

In this paper, we assume a generative model of the data
points, given the ground-truth feature matrix A∗. In each
round, we are given y = A∗x,1 where x is sampled i.i.d.
from some unknown distribution µ and the goal is to re-
cover the ground-truth feature matrix A∗. We give an al-
gorithm named AND that starts from a mild initialization
matrix and provably converges to A∗ in polynomial time.
We also justify the convergence through a sequence of ex-
periments. Our algorithm has the following favorable char-
acteristics.

1.1.1. SIMPLE GRADIENT DESCENT ALGORITHM

The algorithm AND runs in stages and keeps a working
matrix A(t) in each stage. At the t-th iteration in a stage,
after getting one sample y, it performs the following:

(Decode)

z = φα

(cid:16)

(A(0))†y

(cid:17)

,
(cid:16)

(Update) A(t+1) = A(t) + η

yz(cid:62) − A(t)zz(cid:62)(cid:17)

,

where α is a threshold parameter,

φα(x) =

(cid:26) x if x ≥ α,
otherwise,

0

(A(0))† is the Moore-Penrose pesudo-inverse of A(0), and
η is the update step size. The decode step aims at recov-
ering the corresponding weight for the data point, and the
update step uses the decoded weight to update the feature
matrix. The ﬁnal working matrix at one stage will be used
as the A(0) in the next stage. See Algorithm 1 for the de-
tails.

At a high level, our update step to the feature matrix can be
thought of as a gradient descent version of alternative non-
negative least square (Kim & Park, 2008), which at each
iteration alternatively minimizes L(A, Z) = (cid:107)Y − AZ(cid:107)2
F
by ﬁxing A or Z. Our algorithm, instead of perform-
ing an complete minimization, performs only a stochas-
tic gradient descent step on the feature matrix. To see
this, consider one data point y and consider minimizing
L(A, z) = (cid:107)y − Az(cid:107)2
F with z ﬁxed. Then the gradient
of A is just −∇L(A) = (y − Az)z(cid:62), which is exactly the
update of our feature matrix in each iteration.

As to the decode step, when α = 0, our decoding can be
regarded as a one-shot approach minimizing (cid:107)Y − AZ(cid:107)2
F

1We also consider the noisy case; see 1.1.5.

restricted to Z ≥ 0. Indeed, if for example projected gra-
dient descent is used to minimize (cid:107)Y − AZ(cid:107)2
F , then the
projection step is exactly applying φα to Z with α = 0. A
key ingredient of our algorithm is choosing α to be larger
than zero and then decreasing it, which allows us to outper-
form the standard algorithms.

Perhaps worth noting, our decoding only uses A(0). Ide-
ally, we would like to use (A(t))† as the decoding matrix
in each iteration. However, such decoding method requires
computing the pseudo-inverse of A(t) at every step, which
is extremely slow.
Instead, we divide the algorithm into
stages and in each stage, we only use the starting matrix
in the decoding, thus the pseudo-inverse only needs to be
computed once per stage and can be used across all itera-
tions inside. We can show that our algorithm converges in
polylogarithmic many stages, thus gives us to a much bet-
ter running time. These are made clear when we formally
present the algorithm in Section 4 and the theorems in Sec-
tion 5 and 6.

1.1.2. HANDLING STRONG CORRELATIONS

The most notable property of AND is that it can provably
deal with highly correlated distribution µ on the weight x,
meaning that the coordinates of x can have very strong
correlations with each other. This is important since such
correlated x naturally shows up in practice. For example,
when a document contains the topic “machine learning”, it
is more likely to contain the topic “computer science” than
“geography” (Blei & Lafferty, 2006).

Most of the previous theoretical approaches for analyz-
ing alternating between decoding and encoding, such
as (Awasthi & Risteski, 2015; Li et al., 2016; Arora
et al., 2015), require the coordinates of x to be pairwise-
independent, or almost pairwise-independent (meaning
Eµ[xixj] ≈ Eµ[xi]Eµ[xj]). In this paper, we show that al-
gorithm AND can recover A∗ even when the coordinates
are highly correlated. As one implication of our result,
when the sparsity of x is O(1) and each entry of x is in
{0, 1}, AND can recover A∗ even if each Eµ[xixj] =
Ω(min{Eµ[xi], Eµ[xj]}), matching (up to constant) the
highest correlation possible. Moreover, we do not assume
any prior knowledge about the distribution µ, and the result
also extends to general sparsities as well.

1.1.3. PSEUDO-INVERSE DECODING

One of the feature of our algorithm is to use Moore-Penrose
pesudo-inverse in decoding.
Inverse decoding was also
used in (Li et al., 2016; Arora et al., 2015; 2016). How-
ever, their algorithms require carefully ﬁnding an inverse
such that certain norm is minimized, which is not as efﬁ-
cient as the vanilla Moore-Penrose pesudo-inverse. It was
also observed in (Arora et al., 2016) that Moore-Penrose

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

pesudo-inverse works equally well in practice, but the ex-
periment was done only when A = A∗. In this paper, we
show that Moore-Penrose pesudo-inverse also works well
when A (cid:54)= A∗, both theoretically and empirically.

1.1.4. THRESHOLDING AT DIFFERENT α

Thresholding at a value α > 0 is a common trick used in
many algorithms. However, many of them still only con-
sider a ﬁxed α throughout the entire algorithm. Our contri-
bution is a new method of thresholding that ﬁrst sets α to
be high, and gradually decreases α as the algorithm goes.
Our analysis naturally provides the explicit rate at which
we decrease α, and shows that our algorithm, following this
scheme, can provably converge to the ground-truth A∗ in
polynomial time. Moreover, we also provide experimental
support for these choices.

1.1.5. ROBUSTNESS TO NOISE

We further show that the algorithm is robust to noise. In
particular, we consider the model y = A∗x + ζ, where ζ
is the noise. The algorithm can tolerate a general family of
noise with bounded moments; we present in the main body
the result for a simpliﬁed case with Gaussian noise and pro-
vide the general result in the appendix. The algorithm can
recover the ground-truth matrix up to a small blow-up fac-
tor times the noise level in each example, when the ground-
truth has a good condition number. This robustness is also
supported by our experiments.

2. Related Work

Practical algorithms. Non-negative matrix factorization
has a rich empirical history, starting with the practical al-
gorithms of (Lee & Seung, 1997; 1999; 2001). It has been
widely used in applications and there exist various methods
for NMF, e.g., (Kim & Park, 2008; Lee & Seung, 2001; Ci-
chocki et al., 2007; Ding et al., 2013; 2014). However, they
do not have provable recovery guarantees.

Theoretical analysis. For theoretical analysis, (Arora
et al., 2012b) provided a ﬁxed-parameter tractable algo-
rithm for NMF using algebraic equations. They also pro-
vided matching hardness results: namely they show there is
no algorithm running in time (mW )o(D) unless there is a
sub-exponential running time algorithm for 3-SAT. (Arora
et al., 2012b) also studied NMF under separability assump-
tions about the features, and (Bhattacharyya et al., 2016)
studied NMF under related assumptions. The most re-
lated work is (Li et al., 2016), which analyzed an alter-
nating minimization type algorithm. However, the result
only holds with strong assumptions about the distribution
of the weight x, in particular, with the assumption that the
coordinates of x are independent.

Topic modeling. Topic modeling is a popular generative
model for text data (Blei et al., 2003; Blei, 2012). Usu-
ally, the model results in NMF type optimization problems
with (cid:107)x(cid:107)1 = 1, and a popular heuristic is variational in-
ference, which can be regarded as alternating minimiza-
tion in KL-divergence. Recently, there is a line of theo-
retical work analyzing tensor decomposition (Arora et al.,
2012a; 2013; Anandkumar et al., 2013) or combinatorial
methods (Awasthi & Risteski, 2015). These either need
strong structural assumptions on the word-topic matrix A∗,
or need to know the distribution of the weight x, which is
usually infeasible in applications.

3. Problem and Deﬁnitions

We use (cid:107)M(cid:107)2 to denote the 2-norm of a matrix M. (cid:107)x(cid:107)1
is the 1-norm of a vector x. We use [M]i to denote the i-
th row and [M]i to denote the i-th column of a matrix M.
σmax(M)(σmin(M)) stands for the maximum (minimal)
singular value of M, respectively. We consider a generative
model for non-negative matrix factorization, where the data
y is generated from2

y = A∗x, A∗ ∈ RW ×D

where A∗ is the ground-truth feature matrix, and x is a non-
negative random vector drawn from an unknown distribu-
tion µ. The goal is to recover the ground-truth A∗ from
i.i.d. samples of the observation y.

Since the general non-negative matrix factorization is NP-
hard (Arora et al., 2012b), some assumptions on the distri-
bution of x need to be made. In this paper, we would like to
allow distributions as general as possible, especially those
with strong correlations. Therefore, we introduce the fol-
lowing notion called (r, k, m, λ)-general correlation condi-
tions (GCC) for the distribution of x.

Deﬁnition 1 (General Correlation Conditions, GCC). Let
∆ := E[xx(cid:62)] denote the second moment matrix.

1. (cid:107)x(cid:107)1 ≤ r and xi ∈ [0, 1], ∀i ∈ [D].

2. ∆i,i ≤ 2k

D , ∀i ∈ [D].

3. ∆i,j ≤ m

D2 , ∀i (cid:54)= j ∈ [D].

4. ∆ (cid:23) k

D λI.

The ﬁrst condition regularizes the sparsity of x.3 The sec-
ond condition regularizes each coordinate of xi so that
there is no xi being large too often. The third condition

2Section 6.2 considers the noisy case.
3Throughout this paper, the sparsity of x refers to the (cid:96)1 norm,
which is much weaker than the (cid:96)0 norm (the support sparsity). For
example, in LDA, the (cid:96)1 norm of x is always 1.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

regularizes the maximum pairwise correlation between xi
and xj. The fourth condition always holds for λ = 0 since
E[xx(cid:62)] is a PSD matrix. Later we will assume this condi-
tion holds for some λ > 0 to avoid degenerate cases. Note
that we put the weight k/D before λ such that λ deﬁned
in this way will be a positive constant in many interesting
examples discussed below.

To get a sense of what are the ranges of k, m, and λ given
sparsity r, we consider the following most commonly stud-
ied non-negative random variables.

Proposition 1 (Examples of GCC).

1. If x is chosen uniformly over s-sparse random vectors
with {0, 1} entries, then k = r = s, m = s2 and
λ = 1 − 1
s .

2. If x is uniformly chosen from Dirichlet distribution
D , then r = k = 1 and m = 1

sD

with parameter αi = s
with λ = 1 − 1
s .

For these examples, the result in this paper shows that we
can recover A∗ for aforementioned random variables x as
long as s = O(D1/6). In general, there is a wide range
of parameters (r, k, m, λ) such that learning A∗ is doable
with polynomially many samples of y and in polynomial
time.

However, just the GCC condition is not enough for recov-
ering A∗. We will also need a mild initialization.

Deﬁnition 2 ((cid:96)-initialization). The initial matrix A0 satis-
ﬁes for some (cid:96) ∈ [0, 1),

1. A0 = A∗(Σ + E), for some diagonal matrix Σ and

off-diagonal matrix E.

2. (cid:107)E(cid:107)2 ≤ (cid:96), (cid:107)Σ − I(cid:107)2 ≤ 1
4 .

The condition means that the initialization is not too far
away from the ground-truth A∗. For any i ∈ [D], the i-
th column [A0]i = Σi,i[A∗]i + (cid:80)
j(cid:54)=i Ej,i[A∗]j. So the
condition means that each feature [A0]i has a large frac-
tion of the ground-truth feature [A∗]i and a small fraction
of the other features. Σ can be regarded as the magnitude
of the component from the ground-truth in the initializa-
tion, while E can be regarded as the magnitude of the error
terms. In particular, when Σ = I and E = 0, we have
A0 = A∗. The initialization allows Σ to be a constant
away from I, and the error term E to be (cid:96) (in our theorems
(cid:96) can be as large as a constant).

In practice, such an initialization is typically achieved by
setting the columns of A0 to reasonable “pure” data points
that contain one major feature and a small fraction of some
others (e.g. (lda, 2016; Awasthi & Risteski, 2015)).

for t = 0, 1, . . . , T do

Algorithm 1 Alternating Non-negative gradient Descent
(AND)
Input: Threshold values {α0, α1, . . . , αs}, T , A0
1: A(0) ← A0
2: for j = 0, 1, . . . , s do
3:
4:
5:
6:
7:
8: A(0) ← A(T +1)
9: end for
Output: A ← A(T +1)

On getting sample y(t), do:
(cid:0)(A(0))†y(t)(cid:1)
z(t) ← φαj
A(t+1) ← A(t) + η (cid:0)y(t) − A(t)z(t)(cid:1) (z(t))(cid:62)

end for

4. Algorithm

The algorithm is formally describe in Algorithm 1. It runs
in s stages, and in the j-th stage, uses the same threshold
αj and the same matrix A(0) for decoding, where A(0) is
either the input initialization matrix or the working matrix
obtained at the end of the last stage. Each stage consists
of T iterations, and each iteration decodes one data point
and uses the decoded result to update the working matrix.
It can use a batch of data points instead of one data point,
and our analysis still holds.

By running in stages, we save most of the cost of comput-
ing (A(0))†, as our results show that only polylogarithmic
stages are needed. For the simple case where x ∈ {0, 1}D,
the algorithm can use the same threshold value α = 1/4
for all stages (see Theorem 1), while for the general case,
it needs decreasing threshold values across the stages (see
Theorem 4). Our analysis provides the hint for setting the
threshold; see the discussion after Theorem 4, and Sec-
tion 7 for how to set the threshold in practice.

5. Result for A Simpliﬁed Case

In this section, we consider the following simpliﬁed case:

y = A∗x, x ∈ {0, 1}D.

(5.1)

That is, the weight coordinates xi’s are binary.
Theorem 1 (Main, binary). For the generative model (5.1),
there exists (cid:96) = Ω(1) such that for every (r, k, m, λ)-
GCC x and every (cid:15) > 0, Algorithm AND with T =
poly(D, 1
(cid:15) ) , {αi}s
i=1 for s =
polylog(D, 1
(cid:15) ) and an (cid:96) initialization matrix A0, outputs a
matrix A such that there exists a diagonal matrix Σ (cid:23) 1
2 I
with (cid:107)A − A∗Σ(cid:107)2 ≤ (cid:15) using poly(D, 1
(cid:15) ) samples and it-
erations, as long as

i=1 = { 1

1
poly(D, 1

(cid:15) ), η =

4 }s

m = O

(cid:18) kDλ4
r5

(cid:19)

.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Therefore, our algorithm recovers the ground-truth A∗ up
to scaling. The scaling in unavoidable since there is no as-
sumption on A∗, so we cannot, for example, distinguish
A∗ from 2A∗. Indeed, if we in addition assume each col-
umn of A∗ has norm 1 as typical in applications, then
we can recover A∗ directly. In particular, by normalizing
each column of A to have norm 1, we can guarantee that
(cid:107)A − A∗(cid:107)2 ≤ O((cid:15)).

In many interesting applications (for example, those in
Proposition 1), k, r, λ are constants. The theorem implies
that the algorithm can recover A∗ even when m = O(D).
In this case, Eµ[xixj] can be as large as O(1/D), the same
order as min{Eµ[xi], Eµ[xj]}, which is the highest possi-
ble correlation.

5.1. Intuition

The intuition comes from assuming that we have the “cor-
rect decoding”, that is, suppose magically for every y(t),
our decoding z(t) = φαj (A†y(t)) = x(t). Here and in this
subsection, A is a shorthand for A(0). The gradient de-
scent is then A(t+1) = A(t) + η(y(t) − A(t)x(t))(x(t))(cid:62).
Subtracting A∗ on both side, we will get

(A(t+1) − A∗) = (A(t) − A∗)(I − ηx(t)(x(t))(cid:62))

Since x(t)(x(t))(cid:62) is positive semideﬁnite, as long as
E[x(t)(x(t))(cid:62)] (cid:31) 0 and η is sufﬁciently small, A(t) will
converge to A∗ eventually.

However, this simple argument does not work when A (cid:54)=
A∗ and thus we do not have the correct decoding. For ex-
ample, if we just let the decoding be ˜z(t) = A†y(t), we will
have y(t) − A˜z(t) = y(t) − A†Ay(t) = (I − A†A)A∗x(t).
Thus, using this decoding, the algorithm can never make
any progress once A and A∗ are in the same subspace.

The most important piece of our proof is to show that af-
ter thresholding, z(t) = φα(A†y(t)) is much closer to x(t)
than ˜z(t). Since A and A∗ are in the same subspace, in-
spired by (Li et al., 2016) we can write A∗ as A(Σ + E)
for a diagonal matrix Σ and an off-diagonal matrix E, and
thus the decoding becomes z(t) = φα(Σx(t) + Ex(t)).
Let us focus on one coordinate of z(t), that is, z(t)
i =
φα(Σi,ix(t)
i + Eix(t)), where Ei is the i-th row of Ei. The
term Σi,ix(t)
is a nice term since it is just a rescaling of
i
x(t)
, while Eix(t) mixes different coordinates of x(t). For
i
simplicity, we just assume for now that x(t)
i ∈ {0, 1} and
Σi,i = 1. In our proof, we will show that the threshold will
remove a large fraction of Eix(t) when x(t)
i = 0, and keep a
i when x(t)
large fraction of Σi,ix(t)
i = 1. Thus, our decod-
ing is much more accurate than without thresholding. To
show this, we maintain a crucial property that for our de-
coding matrix, we always have (cid:107)Ei(cid:107)2 = O(1). Assuming

this, we ﬁrst consider two extreme cases of Ei.

1. Ultra dense: all coordinates of Ei are in the order of
1√
. Since the sparsity of x(t) is r, as long as r =
d
√
d)α, Eix(t) will not pass α and thus z(t)
o(
decoded to zero when x(t)

i will be

i = 0.

2. Ultra sparse: Ei only has few coordinate equal to Ω(1)
and the rest are zero. Unless x(t) has those exact coor-
dinates equal to 1 (which happens not so often), then
i will still be zero when x(t)
z(t)

i = 0.

Of course, the real Ei can be anywhere in between these
two extremes, and thus we need more delicate decoding
lemmas, as shown in the complete proof.

Furthermore, more complication arises when each x(t)
is
i
not just in {0, 1} but can take fractional values. To han-
dle this case, we will set our threshold α to be large at the
beginning and then keep shrinking after each stage. The in-
tuition here is that we ﬁrst decode the coordinates that we
are most conﬁdent in, so we do not decode z(t)
to be non-
zero when x(t)
i = 0. Thus, we will still be able to remove a
large fraction of error caused by Eix(t). However, by set-
ting the threshold α so high, we may introduce more errors
to the nice term Σi,ix(t)
as well, since Σi,ix(t)
i might not
i
be larger than α when x(t)
(cid:54)= 0. Our main contribution is to
i
show that there is a nice trade-off between the errors in Ei
terms and those in Σi,i terms such that as we gradually de-
creases α, the algorithm can converge to the ground-truth.

i

5.2. Proof Sketch

For simplicity, we only focus on one stage and the expected
update. The expected update of A(t) is given by

A(t+1) = A(t) + η(E[yz(cid:62)] − A(t)E[zz(cid:62)]).

Let us write A(0) = A∗(Σ0 + E0) where Σ0 is diagonal
and E0 is off-diagonal. Then the decoding is given by

z = φα((A(0))†y) = φα((Σ0 + E0)−1x).

Let Σ, E be the diagonal part and the off-diagonal part of
(Σ0 + E0)−1.

The key lemma for decoding says that under suitable con-
ditions, z will be close to Σx in the following sense.
Lemma 2 (Decoding, informal). Suppose E is small and
Σ ≈ I. Then with a proper threshold value α, we have

E[Σxx(cid:62)] ≈ E[zx(cid:62)], E[Σxz(cid:62)] ≈ E[zz(cid:62)].

Now, let us write A(t) = A∗(Σt + Et). Then applying the
above decoding lemma, the expected update of Σt + Et is
Σt+1 +Et+1 = (Σt +Et)(I−Σ∆Σ)+Σ−1(Σ∆Σ)+Rt

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

where ∆ = E[xx(cid:62)] and Rt is a small error term.

Our second key lemma is about this update.

Lemma 3 (Update, informal). Suppose the update rule is

Σt+1 + Et+1 = (Σt + Et)(1 − ηΛ) + ηQΛ + ηRt

for some PSD matrix Λ and (cid:107)Rt(cid:107)2 ≤ C (cid:48)(cid:48). Then

(cid:107)Σt + Et − Q(cid:107)2 ≤ (cid:107)Σ0 + E0 − Q(cid:107)2(1 − ηλmin(Λ))t

+

C (cid:48)(cid:48)
λmin(Λ)

.

Applying this on our update rule with Q = Σ−1 and
Λ = Σ∆Σ, we know that when the error term is sufﬁ-
ciently small, we can make progress on (cid:107)Σt +Et −Σ−1(cid:107)2.
Furthermore, by using the fact that Σ0 ≈ I and E0 is small,
and the fact that Σ is the diagonal part of (Σ0 + E0)−1, we
can show that after sufﬁciently many iterations, (cid:107)Σt − I(cid:107)2
blows up slightly, while (cid:107)Et(cid:107)2 is reduced signiﬁcantly. Re-
peating this for multiple stages completes the proof.

We note that most technical details are hidden, especially
for the proofs of the decoding lemma, which need to show
that the error term Rt is small. This crucially relies on
the choice of α, and relies on bounding the effect of the
correlation. These then give the setting of α and the bound
on the parameter m in the ﬁnal theorem.

6. More General Results

6.1. Result for General x

This subsection considers the general case where x ∈
[0, 1]D. Then the GCC condition is not enough for recov-
ery, even for k, r, m = O(1) and λ = Ω(1). For example,
GCC does not rule out the case that x is drawn uniformly
over (r − 1)-sparse random vectors with { 1
D , 1} entries,
when one cannot recover even a reasonable approximation
of A∗ since a common vector 1
i[A∗]i shows up in all
D
the samples. This example shows that the difﬁculty arises
if each xi constantly shows up with a small value. To avoid
this, a general and natural way is to assume that each xi,
once being non-zero, has to take a large value with sufﬁ-
cient probability. This is formalized as follows.

(cid:80)

Deﬁnition 3 (Decay condition). A distribution of x satisﬁes
the order-q decay condition for some constant q ≥ 1, if for
all i ∈ [D], xi satisﬁes that for every α > 0,

Pr[xi ≤ α | xi (cid:54)= 0] ≤ αq.

When q = 1, each xi, once being non-zero, is uniformly
distributed in the interval [0, 1]. When q gets larger, each
xi, once being non-zero, will be more likely to take larger

values. We will show that our algorithm has a better guar-
antee for larger q. In the extreme case when q = ∞, xi will
only take {0, 1} values, which reduces to the binary case.

In this paper, we show that this simple decay condition,
combined with the GCC conditions and an initialization
with constant error, is sufﬁcient for recovering A∗.
Theorem 4 (Main). There exists (cid:96) = Ω(1) such that for
every (r, k, m, λ)-GCC x satisfying the order-q condition,
every (cid:15) > 0, there exists T, η and a sequence of {αi} 4
such that Algorithm AND, with (cid:96)-initialization matrix A0,
outputs a matrix A such that there exists a diagonal matrix
Σ (cid:23) 1
(cid:15) ) samples
and iterations, as long as

2 I with (cid:107)A − A∗Σ(cid:107)2 ≤ (cid:15) with poly(D, 1

m = O

(cid:32)

q λ4+ 4

q

kD1− 1
r5+ 6

q+1

(cid:33)

.

As mentioned, in many interesting applications, k = r =
λ = Θ(1), where our algorithm can recover A∗ as long as
m = O(D1− 1
q+1 ). This means Eµ[xixj] = O(D−1− 1
q+1 ),
a factor of D− 1
q+1 away from the highest possible correla-
tion min{Eµ[xi], Eµ[xj]} = O(1/D). Then, the larger q,
the higher correlation it can tolerate. As q goes to inﬁnity,
we recover the result for the case x ∈ {0, 1}D, allowing
the highest order correlation.

The analysis also shows that the decoding threshold should

(cid:16) λ(cid:107)E0(cid:107)2
r

(cid:17) 2

q+1

be α =
where E0 is the error matrix at the
beginning of the stage. Since the error decreases exponen-
tially with stages, this suggests to decrease α exponentially
with stages. This is crucial for AND to recover the ground-
truth; see Section 7 for the experimental results.

6.2. Robustness to Noise

We now consider the case when the data is generated from
y = A∗x + ζ, where ζ is the noise. For the sake of demon-
stration, we will just focus on the case when xi ∈ {0, 1}
and ζ is random Gaussian noise ζ ∼ γN (cid:0)0, 1
W I(cid:1). 5 A
more general theorem can be found in the appendix.

Deﬁnition 4 (((cid:96), ρ)-initialization). The initial matrix A0
satisﬁes for some (cid:96), ρ ∈ [0, 1),

1. A0 = A∗(Σ + E) + N, for some diagonal matrix Σ

and off-diagonal matrix E.

2. (cid:107)E(cid:107)2 ≤ (cid:96), (cid:107)Σ − I(cid:107)2 ≤ 1

4 , (cid:107)N(cid:107)2 ≤ ρ.

Theorem 5 (Noise, binary). Suppose each xi ∈ {0, 1}.
There exists (cid:96) = Ω(1) such that for every (r, k, m, λ)-GCC
x, every (cid:15) > 0, Algorithm AND with T = poly(D, 1
(cid:15) ), η =

4In fact, we will make the choice explicit in the proof.
5we make this scaling so (cid:107)ζ(cid:107)2 ≈ γ.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

4 }4

i=1 = { 1

(cid:15) ) , {αi}s

1
i=1 and an ((cid:96), ρ)-initialization
poly(D, 1
A0 for ρ = O(σmin(A∗)), outputs A such that there exists
a diagonal matrix Σ (cid:23) 1
2 I with
(cid:18)

(cid:19)

(cid:107)A − A∗Σ(cid:107)2 ≤ O

(cid:15) + r

σmax(A∗)
σmin(A∗)λ

γ

using poly(D, 1

(cid:15) ) iterations, as long as m = O

(cid:16) kDλ4
r5

(cid:17)

.

The theorem implies that the algorithm can recover the
ground-truth up to r σmax(A∗)
σmin(A∗)λ times γ, the noise level in
each sample. Although stated here for Gaussian noise for
simplicity, the analysis applies to a much larger class of
noises, including adversarial ones. In particular, we only
need to the noise ζ have sufﬁciently bounded (cid:107)E[ζζ (cid:62)](cid:107)2;
see the appendix for the details. For the special case of
Gaussian noise, by exploiting its properties, it is possible
to improve the error term with a more careful calculation,
though not done here.

7. Experiments

To demonstrate the advantage of AND, we complement the
theoretical analysis with empirical study on semi-synthetic
datasets, where we have ground-truth feature matrices and
can thus verify the convergence. We then provide support
for the beneﬁt of using decreasing thresholds, and test its
robustness to noise.
In the appendix, we further test its
robust to initialization and sparsity of x, and provide qual-
itative results in some real world applications. 6

Setup. Our work focuses on convergence of the solu-
tion to the ground-truth feature matrix. However, real-
world datasets in general do not have ground-truth. So we
construct semi-synthetic datasets in topic modeling: ﬁrst
take the word-topic matrix learned by some topic model-
ing method as the ground-truth A∗, and then draw x from
some speciﬁc distribution µ. For fair comparison, we use
one not learned by any algorithm evaluated here. In partic-
ular, we used the matrix with 100 topics computed by the
algorithm in (Arora et al., 2013) on the NIPS papers dataset
(about 1500 documents, average length about 1000). Based
on this we build two semi-synthetic datasets:

1. DIR. Construct a 100 × 5000 matrix X, whose
columns are from a Dirichlet distribution with pa-
rameters (0.05, 0.05, . . . , 0.05). Then the dataset is
Y = A∗X.

2. CTM. The matrix X is of the same size as above,
while each column is drawn from the logistic normal
prior in the correlated topic model (Blei & Lafferty,
2006). This leads to a dataset with strong correlations.

Note that the word-topic matrix is non-negative. While
some competitor algorithms require a non-negative feature
matrix, AND does not need such a condition. To demon-
strate this, we generate the following synthetic data:

3. NEG. The entries of the matrix A∗ are i.i.d. samples
from the uniform distribution on [−0.5, 0.5). The ma-
trix X is the same as in CTM.

Finally, the following dataset is for testing the robustness
of AND to the noise:

4. NOISE. A∗ and X are the same as in CTM, but Y =
A∗X + N where N is the noise matrix with columns
drawn from γN (cid:0)0, 1

W I(cid:1) with the noise level γ.

Competitors. We compare the algorithm AND to the fol-
lowing popular methods: Alternating Non-negative Least
Square (ANLS (Kim & Park, 2008)), multiplicative update
(MU (Lee & Seung, 2001)), LDA (online version (Hoffman
et al., 2010)),7 and Hierarchical Alternating Least Square
(HALS (Cichocki et al., 2007)).

Evaluation criterion. Given the output matrix A and the
ground truth matrix A∗, the correlation error of the i-th
column is given by

εi(A, A∗) = min

{(cid:107)[A∗]i − σ[A]j(cid:107)2}.

j∈[D],σ∈R

Thus, the error measures how well the i-th column of A∗
is covered by the best column of A up to scaling. We ﬁnd
the best column since in some competitor algorithms, the
columns of the solution A may only correspond to a per-
mutation of the columns of A∗.8

We also deﬁne the total correlation error as

ε(A, A∗) =

εi(A, A∗).

D
(cid:88)

i=1

We report the total correlation error in all the experiments.

Initialization.
In all the experiments, the initialization
matrix A0 is set to A0 = A∗(I + U) where I is the
identity matrix and U is a matrix whose entries are i.i.d.
samples from the uniform distribution on [−0.05, 0.05).
Note that this is a very weak initialization, since [A0]i =
(1 + Ui,i)[A∗]i + (cid:80)
j(cid:54)=i Uj,i[A∗]j and the magnitude of
the noise component (cid:80)
j(cid:54)=i Uj,i[A∗]j can be larger than
the signal part (1 + Ui,i)[A∗]i.

7We use the implementation in the sklearn package (http:

//scikit-learn.org/)

6The

code
public
PrincetonML/AND4NMF.

is

on https://github.com/

8In the Algorithm AND, the columns of A correspond to the

columns of A∗ without permutation.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

(a) on DIR dataset

(b) on CTM dataset

(c) on NEG dataset

Figure 1. The performance of different algorithms on the three datasets. The x-axis is the running time (in seconds), the y-axis is the
logarithm of the total correlation error.

(a) different thresholds on DIR

(b) different thresholds on CTM

(c) robustness to noise

Figure 2. The performance of the algorithm AND with different thresholding schemes, and its robustness to noise. The x-axis is the
running time (in seconds), the y-axis is the logarithm of the total correlation error. (a)(b) Using different thresholding schemes on the
DIR/CTM dataset. “Decreasing thresold” refers to the scheme used in the original AND, “Constant threshold c” refers to using the
threshold value c throughout all iterations. (c) The performance in the presence of noises of various levels.

Hyperparameters and Implementations. For most ex-
periments of AND, we used T = 50 iterations for each
stage, and thresholds αi = 0.1/(1.1)i−1. For experiments
on the robustness to noise, we found T = 100 leads to
better performance. Furthermore, for all the experiments,
instead of using one data point at each step, we used the
whole dataset for update.

7.1. Convergence to the Ground-Truth

Figure 1 shows the convergence rate of the algorithms on
the three datasets. AND converges in linear rate on all three
datasets (note that the y-axis is in log-scale). HALS con-
verges on the DIR and CTM datasets, but the convergence
is in slower rates. Also, on CTM, the error oscillates. Fur-
thermore, it doesn’t converge on NEG where the ground-
truth matrix has negative entries. ANLS converges on DIR
and CTM at a very slow speed due to the non-negative least
square computation in each iteration. 9 All the other algo-

rithms do not converge to the ground-truth, suggesting that
they do not have recovery guarantees.

7.2. The Threshold Schemes

Figure 2(a) shows the results of using different thresholding
schemes on DIR, while Figure 2(b) shows that those on
CTM. When using a constant threshold for all iterations,
the error only decreases for the ﬁrst few steps and then stop
decreasing. This aligns with our analysis and is in strong
contrast to the case with decreasing thresholds.

7.3. Robustness to Noise

Figure 2(c) shows the performance of AND on the NOISE
dataset with various noise levels γ. The error drops at the
ﬁrst few steps, but then stabilizes around a constant related
to the noise level, as predicted by our analysis. This shows
that it can recover the ground-truth to good accuracy, even
when the data have a signiﬁcant amount of noise.

9We also note that even the thresholding of HALS and ALNS
designed for non-negative feature matrices is removed, they still

do not converge on NEG.

05001000150020002500300035004000Time in seconds−40−30−20−10010log(Error)ANDANLSMULDAHALS05001000150020002500300035004000Time in seconds−40−30−20−10010log(Error)ANDANLSMULDAHALS0200400600800100012001400Time in seconds−50−40−30−20−10010log(Error)ANDANLSMULDAHALS05001000150020002500300035004000Time in seconds−40−30−20−10010log(Error)Decreasing thresholdConstant threshold 0.0001Constant threshold 0.105001000150020002500300035004000Time in seconds−40−30−20−10010log(Error)Decreasing thresholdConstant threshold 0.0001Constant threshold 0.1050100150200Time in seconds−10−8−6−4−2024log(Error)noise level 0.1noise level 0.05noise level 0.01noise level 0.005noise level 0.001noise level 0.0005Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Blei, David M, Ng, Andrew Y, and Jordan, Michael I. La-

tent dirichlet allocation. JMLR, 3:993–1022, 2003.

Cichocki, Andrzej, Zdunek, Rafal, and Amari, Shun-ichi.
Hierarchical als algorithms for nonnegative matrix and
3d tensor factorization. In International Conference on
Independent Component Analysis and Signal Separa-
tion, pp. 169–176. Springer, 2007.

Ding, W., Rohban, M.H., Ishwar, P., and Saligrama, V.
Topic discovery through data dependent and random
projections. arXiv preprint arXiv:1303.3664, 2013.

Ding, W., Rohban, M.H., Ishwar, P., and Saligrama, V. Ef-
ﬁcient distributed topic modeling with provable guaran-
tees. In AISTAT, pp. 167–175, 2014.

Hoffman, Matthew, Bach, Francis R, and Blei, David M.
In ad-
Online learning for latent dirichlet allocation.
vances in neural information processing systems, pp.
856–864, 2010.

Kim, Hyunsoo and Park, Haesun. Nonnegative matrix fac-
torization based on alternating nonnegativity constrained
least squares and active set method. SIAM journal on
matrix analysis and applications, 30(2):713–730, 2008.

Lee, Daniel D and Seung, H Sebastian. Unsupervised
learning by convex and conic coding. NIPS, pp. 515–
521, 1997.

Lee, Daniel D and Seung, H Sebastian. Learning the parts
of objects by non-negative matrix factorization. Nature,
401(6755):788–791, 1999.

Lee, Daniel D and Seung, H Sebastian. Algorithms for
non-negative matrix factorization. In NIPS, pp. 556–562,
2001.

Li, Yuanzhi, Liang, Yingyu, and Risteski, Andrej. Recov-
ery guarantee of non-negative matrix factorization via al-
ternating updates. Advances in neural information pro-
cessing systems, 2016.

Yang, Jaewon and Leskovec, Jure. Overlapping community
detection at scale: a nonnegative matrix factorization ap-
proach. In Proceedings of the sixth ACM international
conference on Web search and data mining, pp. 587–596.
ACM, 2013.

Acknowledgements

This work was supported in part by NSF grants CCF-
1527371, DMS-1317308, Simons Investigator Award, Si-
mons Collaboration Grant, and ONR-N00014-16-1-2329.
This work was done when Yingyu Liang was visiting the
Simons Institute.

References

Lda-c software. https://github.com/blei-lab/
lda-c/blob/master/readme.txt, 2016. Ac-
cessed: 2016-05-19.

Anandkumar, A., Kakade, S., Foster, D., Liu, Y., and Hsu,
D. Two svds sufﬁce: Spectral decompositions for prob-
abilistic topic modeling and latent dirichlet allocation.
Technical report, 2012.

Anandkumar, A., Hsu, D., Javanmard, A., and Kakade, S.
Learning latent bayesian networks and topic models un-
der expansion constraints. In ICML, 2013.

Arora, S., Ge, R., and Moitra, A. Learning topic models –

going beyond svd. In FOCS, 2012a.

Arora, S., Ge, R., Halpern, Y., Mimno, D., Moitra, A.,
Sontag, D., Wu, Y., and Zhu, M. A practical algorithm
for topic modeling with provable guarantees. In ICML,
2013.

Arora, S., Ge, R., Ma, T., and Moitra, A. Simple, efﬁcient,
and neural algorithms for sparse coding. In COLT, 2015.

Arora, Sanjeev, Ge, Rong, Kannan, Ravindran, and Moitra,
Ankur. Computing a nonnegative matrix factorization–
provably. In STOC, pp. 145–162. ACM, 2012b.

Arora, Sanjeev, Ge, Rong, Koehler, Frederic, Ma, Tengyu,
and Moitra, Ankur. Provable algorithms for inference in
topic models. In Proceedings of The 33rd International
Conference on Machine Learning, pp. 2859–2867, 2016.

Awasthi, Pranjal and Risteski, Andrej. On some provably
correct cases of variational inference for topic models.
In NIPS, pp. 2089–2097, 2015.

Bhattacharyya, Chiranjib, Goyal, Navin, Kannan, Ravin-
dran, and Pani, Jagdeep. Non-negative matrix factor-
ization under heavy noise. In Proceedings of the 33nd
International Conference on Machine Learning, 2016.

Blei, David and Lafferty, John. Correlated topic models.
Advances in neural information processing systems, 18:
147, 2006.

Blei, David M. Probabilistic topic models. Communica-

tions of the ACM, 2012.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

A. Complete Proofs

We now recall the proof sketch.

For simplicity, we only focus on one stage and the expected update. The expected update of A(t) is given by

A(t+1) = A(t) + η(E[yz(cid:62)] − A(t)E[zz(cid:62)]).

Let us write A = A∗(Σ0 + E0) where Σ0 is diagonal and E0 is off-diagonal. Then the decoding is given by

Let Σ, E be the diagonal part and the off-diagonal part of (Σ0 + E0)−1.

z = φα(A†x) = φα((Σ0 + E0)−1x).

The ﬁrst step of our analysis is a key lemma for decoding. It says that under suitable conditions, z will be close to Σx in
the following sense:

E[Σxx(cid:62)] ≈ E[zx(cid:62)], E[Σxz(cid:62)] ≈ E[zz(cid:62)].
This key decoding lemma is formally stated in Lemma 6 (for the simpliﬁed case where x ∈ {0, 1}D) and Lemma 8 (for
the general case where x ∈ [0, 1]D).

Now, let us write A(t) = A∗(Σt + Et). Then applying the above decoding lemma, the expected update of Σt + Et is

Σt+1 + Et+1 = (Σt + Et)(I − Σ∆Σ) + Σ−1(Σ∆Σ) + Rt

where Rt is a small error term.

The second step is a key lemma for updating the feature matrix: for the update rule

Σt+1 + Et+1 = (Σt + Et)(1 − ηΛ) + ηQΛ + ηRt

where Λ is a PSD matrix and (cid:107)Rt(cid:107)2 ≤ C (cid:48)(cid:48), we have

(cid:107)Σt + Et − Q(cid:107)2 ≤ (cid:107)Σ0 + E0 − Q(cid:107)2(1 − ηλmin(Λ))t +

C (cid:48)(cid:48)
λmin(Λ)

.

This key updating lemma is formally stated in Lemma 10.

Applying this on our update rule with Q = Σ−1 and Λ = Σ∆Σ, we know that when the error term is sufﬁciently small,
we can make progress on (cid:107)Σt + Et − Σ−1(cid:107)2. Then, by using the fact that Σ0 ≈ I and E0 is small, and the fact that Σ is
the diagonal part of (Σ0 + E0)−1, we can show that after sufﬁciently many iterations, (cid:107)Σt − I(cid:107)2 blows up slightly, while
(cid:107)Et(cid:107)2 is reduced signiﬁcantly (See Lemma 11 for the formal statement). Repeating this for multiple stages completes the
proof.

Organization. Following the proof sketch, we ﬁrst present the decoding lemmas in Section A.1, and then the update
lemmas in Section A.2. Section A.3 then uses these lemmas to prove the main theorems (Theorem 1 and Theorem 4).
Proving the decoding lemmas is highly non-trivial, and we collect the lemmas needed in Section A.4.

Finally, the analysis for the robustness to noise follows a similar proof sketch. It is presented in Section A.5.

A.1. Decoding

A.1.1. xi ∈ {0, 1}

where

Here we present the following decoding Lemma when xi ∈ {0, 1}.
Lemma 6 (Decoding). For every (cid:96) ∈ [0, 1), every off-diagonal matrix E(cid:48) such that (cid:107)E(cid:48)(cid:107)2 ≤ (cid:96) and every diagonal matrix
Σ(cid:48) such that (cid:107)Σ(cid:48) − I(cid:107)2 ≤ 1

2 , let z = φα((Σ(cid:48) + E(cid:48))x) for α ≤ 1

4 . Then for every β ∈ (0, 1/2],

(cid:107)E[(Σ(cid:48)x − z)x(cid:62)](cid:107)2, (cid:107)E[(Σ(cid:48)x − z)z(cid:62)](cid:107)2 = O(C1)

C1 =

kr
D

+

m(cid:96)4r2
α3D2 +

√

(cid:96)2

kmr1.5

D1.5β

+

(cid:96)4r3m
β2D2 +

(cid:96)5r2.5m
D2α2β

.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Proof of Lemma 6. We will prove the bound on (cid:107)E[(Σ(cid:48)x − z)z(cid:62)](cid:107)2, and a simlar argument holds for that on (cid:107)E[(Σ(cid:48)x −
z)x(cid:62)](cid:107)2.
First consider the term |Σ(cid:48)
φα(Σ(cid:48)

i,ixi − zi| for a ﬁxed i ∈ [D]. Due to the decoding, we have zi = φα([(Σ(cid:48) + E(cid:48))]ix) =

i,ixi + (cid:104)ei, x(cid:105)) where ei is the i-th row of E(cid:48).

Claim 7.

Σ(cid:48)

i,ixi − zi = ax,1φα(−(cid:104)ei, x(cid:105)) + ax,2φα((cid:104)ei, x(cid:105)) − (cid:104)ei, x(cid:105)xi

(A.1)

where ax,1, ax,2 ∈ [−1, 1] that depends on x.

Proof. To see this, we split into two cases:

1. When xi = 0, then |Σ(cid:48)

i,ixi − zi| = |zi| ≤ φα((cid:104)ei, x(cid:105)).

2. When xi = 1, then zi = 0 only when −(cid:104)ei, x(cid:105) ≥ 1

2 − α ≥ α, which implies that |Σ(cid:48)

i,ixi − zi + (cid:104)ei, x(cid:105)| ≤ α ≤

φα(−(cid:104)ei, x(cid:105)). When Σ(cid:48)

i,ixi − zi + (cid:104)ei, x(cid:105) (cid:54)= 0, then Σ(cid:48)

i,ixi − zi = −(cid:104)ei, x(cid:105).

Putting everything together, we always have:

|Σ(cid:48)

i,ixi − zi + (cid:104)ei, x(cid:105)xi| ≤ φα(|(cid:104)ei, x(cid:105)|)

which means that there exists ax,1, ax,2 ∈ [−1, 1] that depend on x such that

Σ(cid:48)

i,ixi − zi = ax,1φα(−(cid:104)ei, x(cid:105)) + ax,2φα((cid:104)ei, x(cid:105)) − (cid:104)ei, x(cid:105)xi.

Consider the term (cid:104)ei, x(cid:105)xi, we know that for every β ≥ 0,

|(cid:104)ei, x(cid:105) − φβ((cid:104)ei, x(cid:105)) + φβ(−(cid:104)ei, x(cid:105))| ≤ β.

Therefore, there exists bx ∈ [−β, β] that depends on x such that

(cid:104)ei, x(cid:105)xi = φβ((cid:104)ei, x(cid:105)) − φβ(−(cid:104)ei, x(cid:105)) − bxxi.

Putting into (A.1), we get:

Σ(cid:48)

i,ixi − zi = ax,1φα(−(cid:104)ei, x(cid:105)) + ax,2φα((cid:104)ei, x(cid:105)) − φβ((cid:104)ei, x(cid:105))xi + φβ(−(cid:104)ei, x(cid:105))xi + bxxi.

For notation simplicity, let us now write

zi = (Σ(cid:48)

i,i − bx)xi + ai + bi

ai = −ax,1φα(−(cid:104)ei, x(cid:105)) − ax,2φα((cid:104)ei, x(cid:105)),

bi = φβ((cid:104)ei, x(cid:105))xi − φβ(−(cid:104)ei, x(cid:105))xi.

(Σ(cid:48)

i,ixi − zi)zj = (bxxi − ai − bi)((Σ(cid:48)

j,j − bx)xj + aj + bj).

Let us now construct matrix M1, · · · M9, whose entries are given by

where

We then have

1. (M1)i,j = bxxi(Σ(cid:48)

j,j − bx)xj

2. (M2)i,j = bxxiaj

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

3. (M3)i,j = bxxibj

4. (M4)i,j = −ai(Σ(cid:48)

j,j − bx)xj

7. (M7)i,j = −bi(Σ(cid:48)

j,j − bx)xj

5. (M5)i,j = −aiaj

6. (M6)i,j = −aibj

8. (M8)i,j = −biaj

9. (M9)i,j = −bibj

Thus, we know that E[(Σ(cid:48)x−z)z(cid:62)] = (cid:80)9
as we discuss below.

i=1

E[Mi]. It is sufﬁcient to bound the spectral norm of each matrices separately,

1. M2, M4: these matrices can be bounded by Lemma 14, term 1.

2. M5: this matrix can be bounded by Lemma 14, term 2.

3. M6, M8: these matrices can be bounded by Lemma 15, term 3.

4. M3, M7: these matrices can be bounded by Lemma 15, term 2.

5. M9: this matrix can be bounded by Lemma 15, term 1.

6. E[M1]: this matrix is of the form E[bxx(x (cid:12) dx)(cid:62)], where dx is a vector whose j-th entry is (Σ(cid:48)

j,j − bx).

To bound the this term, we have that for any u, v such that (cid:107)u(cid:107)2 = (cid:107)v(cid:107)2 = 1,

u(cid:62)E[bxx(x (cid:12) dx)(cid:62)]v = E[bx(cid:104)u, x(cid:105)(cid:104)v, x (cid:12) dx(cid:105)].

When β ≤ 1
dx = (2, · · · , 2) and u, v are all non-negative, which gives us

2 , since x is non-negative, we know that the maximum of E[bx(cid:104)u, x(cid:105)(cid:104)v, x (cid:12) dx(cid:105)] is obtained when bx = β,

E[bx(cid:104)u, x(cid:105)(cid:104)v, x (cid:12) dx(cid:105)] ≤ 2β(cid:107)E[xx(cid:62)](cid:107)2 ≤

(cid:107)E[xx(cid:62)](cid:107)1(cid:107)E[xx(cid:62)](cid:107)∞ = (cid:107)E[xx(cid:62)](cid:107)1.

(cid:113)

Now, for each row of (cid:107)E[xx(cid:62)](cid:107)1, we know that [E[xx(cid:62)]]i ≤ E[xi

(cid:80)

j xj] ≤ 2rk

D , which gives us

(cid:107)E[M1](cid:107)2 ≤

4βrk
D

.

Putting everything together gives the bound on (cid:107)E[(Σ(cid:48)x − z)z(cid:62)](cid:107)2. A similar proof holds for the bound on (cid:107)E[(Σ(cid:48)x −
z)x(cid:62)](cid:107)2.

A.1.2. GENERAL xi

We have the following decoding lemma for the general case when xi ∈ [0, 1] and the distribution of x satisﬁes the order-q
decay condition.
Lemma 8 (Decoding II). For every (cid:96) ∈ [0, 1), every off-diagonal matrix E(cid:48) such that (cid:107)E(cid:48)(cid:107)2 ≤ (cid:96) and every diagonal matrix
Σ(cid:48) such that (cid:107)Σ(cid:48) − I(cid:107)2 ≤ 1

2 , let z = φα((Σ(cid:48) + E(cid:48))x) for α ≤ 1

4 . Then for every β ∈ (0, α],

(cid:107)E[(Σ(cid:48)x − z)x(cid:62)](cid:107)2, (cid:107)E[(Σ(cid:48)x − z)z(cid:62)](cid:107)2 = O(C2)

where

C2 =

(cid:96)4r3m
αβ2D2 +

(cid:96)5r2.5m
D2α2.5β

+

(cid:96)2kr
Dβ

(cid:16) m
Dk

(cid:17) q

2q+2

√
(cid:96)3r2
km
D1.5α2 +

+

(cid:96)6r4m
α4D2 + kβ

(cid:16) r
D

(cid:17) 2q+1

2q+2

+

kr
D

q+1

2 .

α

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Proof of Lemma 8. We consider the bound on (cid:107)E[(Σ(cid:48)x − z)z(cid:62)](cid:107)2, and that on E[(Σ(cid:48)x − z)x(cid:62)](cid:107)2 can be proved by a
similar argument.

zi = φα([(Σ(cid:48) + E(cid:48))]ix) = φα(Σ(cid:48)

i,ixi + (cid:104)ei, x(cid:105)).

However, this time even when xi (cid:54)= 0, xi can be smaller than α. Therefore, we need the following inequality.

Again, we still have

Claim 9.

|Σ(cid:48)

i,ixi − zi + (cid:104)ei, x(cid:105)1xi≥4α| ≤ φα/2(|(cid:104)ei, x(cid:105)|) + 2xi1xi∈(0,4α).

Proof. To see this, we can consider the following four events:

1. xi = 0, then |Σ(cid:48)

i,ixi − zi + (cid:104)ei, x(cid:105)1xi≥2α| = |zi| ≤ φα((cid:104)ei, x(cid:105))

2. xi ≥ 4α. |Σ(cid:48)

i,ixi − zi + (cid:104)ei, x(cid:105)1xi≥4α| = |Σ(cid:48)

i,ixi + (cid:104)ei, x(cid:105) − φα(Σ(cid:48)

i,ixi + (cid:104)ei, x(cid:105))|. Since Σ(cid:48)

i,ixi ≥ 2α, we can get

the same bound.

3. xi ∈ (α/4, 4α): then if zi (cid:54)= 0, |Σ(cid:48)

i,ixi − zi + (cid:104)ei, x(cid:105)| = 0. Which implies that

|Σ(cid:48)

i,ixi − zi| ≤ |(cid:104)ei, x(cid:105)| ≤ φα/2(|(cid:104)ei, x(cid:105)|) +

≤ φα/2(|(cid:104)ei, x(cid:105)|) + 2xi1xi∈(0,4α)

α
2

If zi = 0, then

|Σ(cid:48)

i,ixi − zi| = Σ(cid:48)

i,ixi ≤ 2xi1xi∈(0,2α)

4. xi ∈ (0, α/4), then Σ(cid:48)
If z0 = 0, then |Σ(cid:48)

i,ixi − zi| ≤ 2xi1xi∈(0,4α) as before.

i,ixi ≤ α

2 , therefore, zi (cid:54)= 0 only when (cid:104)ei, x(cid:105) ≥ α

2 . We still have: |Σ(cid:48)

i,ixi −zi| ≤ φα/2((cid:104)ei, x(cid:105))

Putting everything together, we have the claim.

Following the exact same calculation as in Lemma 6, we can obtain

Σ(cid:48)

i,ixi − zi = ax,1φα/2(−(cid:104)ei, x(cid:105)) + ax,2φα/2((cid:104)ei, x(cid:105))
− φβ((cid:104)ei, x(cid:105))1xi≥4α + φβ(−(cid:104)ei, x(cid:105))1xi≥4α
+ bx1xi≥4α + cx2xi1xi∈(0,4α)

for ax,1, ax,1, cx ∈ [−1, 1] and bx ∈ [−β, β].

Therefore, consider a matrix M whose (i, j)-th entry is (Σ(cid:48)
following terms.

1. Terms that can be bounded by Lemma 14. These include

i,ixi − zi)zj. This entry can be written as the summation of the

ax,1φα/2(−(cid:104)ei, x(cid:105))xj,

ax,2φα/2((cid:104)ei, x(cid:105))xj,

ax,uax,vφα/2((−1)u(cid:104)ei, x(cid:105))φα/2((−1)v(cid:104)ej, x(cid:105))

for u, v ∈ {1, 2}, and

ax,ubxφα/2((−1)u(cid:104)ei, x(cid:105))1xi≥4α,

2ax,ucxφα/2((−1)u(cid:104)ei, x(cid:105))xj1xj ∈(0,4α)

by using 0 ≤ 1xj ≥4α ≤ xj

4α and 0 ≤ xj1xj ∈(0,4α) ≤ xj.

2. Terms that can be bounded by Lemma 21. These include

−φβ((cid:104)ei, x(cid:105))1xi≥4αxj, φβ(−(cid:104)ei, x(cid:105))1xi≥4αxj,

(−1)uax,vφβ((−1)1+u(cid:104)ei, x(cid:105))1xi≥4αφα/2((−1)v(cid:104)ej, x(cid:105)),

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

(−1)u+vφβ((−1)1+u(cid:104)ei, x(cid:105))1xi≥4α1xj ≥4αφβ((−1)1+v(cid:104)ej, x(cid:105))

for u, v ∈ {1, 2}. Also include

2(−1)ucxφβ((−1)1+u(cid:104)ei, x(cid:105))1xi≥4αxj1xj ∈(0,4α)

by using0 ≤ xj1xj ∈(0,4α) ≤ xj. Also include

2(−1)ubxφβ((−1)1+u(cid:104)ei, x(cid:105))1xi≥4α1xj ≥4α

by using 0 ≤ 1xj ≥4α ≤ xj
4α .

3. Terms that can be bounded by Lemma 18. These include

bx1xi≥4αxj,

b2
x1xi≥4α1xj ≥4α,

2bxcx1xi≥4αxi1xj ∈(0,4α)xj.

Where agin we use the fact that 0 ≤ 1xi≥4α ≤ xj

4α and 0 ≤ xi, 1xj ∈(0,4α) ≤ 1

4. Terms that can be bounded by Lemma 17. These include

cx2xi1xi∈(0,4α)xj,

4c2

xxi1xi∈(0,4α)xj1xj ∈(0,4α).

Where we use the fact that 0 ≤ 1xj ∈(0,4α) ≤ 1.

Putting everything together, when 0 < β ≤ α,

(cid:107)E[(Σ(cid:48)x − z)z(cid:62)](cid:107)2 = O (C2)

where

C2 =

(cid:96)4r3m
αβ2D2 +

(cid:96)5r2.5m
D2α2.5β

+

(cid:96)2kr
Dβ

(cid:16) m
Dk

(cid:17) q

2q+2

√
(cid:96)3r2
km
D1.5α2 +

+

(cid:96)6r4m
α4D2 + kβ

(cid:16) r
D

(cid:17) 2q+1

2q+2

+

kr
D

q+1
2 .

α

This gives the bound on E[(Σ(cid:48)x − z)z(cid:62)](cid:107)2. The bound on E[(Σ(cid:48)x − z)x(cid:62)](cid:107)2 can be proved by a similar argument.

A.2. Update

A.2.1. GENERAL UPDATE LEMMA

Lemma 10 (Update). Suppose Σt is diagonal and Et is off-diagonal for all t. Suppose we have an update rule that is
given by

Σt+1 + Et+1 = (Σt + Et)(1 − η∆) + ηΣ∆ + ηRt

for some positive semideﬁnite matrix ∆ and some Rt such that (cid:107)Rt(cid:107)2 ≤ C (cid:48)(cid:48). Then for every t ≥ 0,

(cid:107)Σt + Et − Σ(cid:107)2 ≤ (cid:107)Σ0 + E0 − Σ(cid:107)2(1 − ηλmin(∆))t +

C (cid:48)(cid:48)
λmin(∆)

.

Proof of Lemma 10. We know that the update is given by

Σt+1 + Et+1 − Σ = (Σt + Et − Σ)(1 − η∆) + ηRt.

If we let

Σt + Et − Σ = (Σ0 + E0 − Σ)(1 − η∆)t + Ct.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Then we can see that the update rule of Ct is given by

C0 = 0,

Ct+1 = Ct(1 − η∆) + ηRt

which implies that ∀t ≥ 0, (cid:107)Ct(cid:107)2 ≤ C(cid:48)(cid:48)

λmin(∆) .

Putting everything together completes the proof.

Lemma 11 (Stage). In the same setting as Lemma 10, suppose initially for (cid:96)1, (cid:96)2 ∈ [0, 1

8 ) we have

(cid:107)Σ0 − I(cid:107)2 ≤ (cid:96)1, (cid:107)E0(cid:107) ≤ (cid:96)2, Σ = (Diag[(Σ0 + E0)−1])−1.

Moreover, suppose in each iteration, the error Rt satisﬁes that (cid:107)Rt(cid:107)2 ≤ λmin(∆)

(cid:96)2.

160

Then after t =

log 400
(cid:96)2
ηλmin(∆) iterations, we have

1. (cid:107)Σt − I(cid:107)2 ≤ (cid:96)1 + 4(cid:96)2,

2. (cid:107)Et(cid:107)2 ≤ 1

40 (cid:96)2.

Proof of Lemma 11. Using Taylor expansion, we know that

Diag[(Σ0 + E0)−1] = Σ−1

0 +

Σ−1/2
0

Diag[(−Σ−1/2

0 E0Σ−1/2

0

)i]Σ−1/2
0

.

Since (cid:107)Diag(M)(cid:107)2 ≤ (cid:107)M(cid:107)2 for any matrix M,

(cid:107)Diag[(Σ0 + E0)−1] − Σ−1

0 (cid:107)2 = (cid:107)

Σ−1/2
0

Diag[(−Σ−1/2

0 E0Σ−1/2

0

)i]Σ−1/2
0

(cid:107)2

∞
(cid:88)

i=1

∞
(cid:88)

i=1
∞
(cid:88)

i=1

≤ (cid:107)

Σ−1/2
0

(−Σ−1/2

0 E0Σ−1/2

0

)iΣ−1/2
0

(cid:107)2

= (cid:107)[(Σ0 + E0)−1](−E0Σ−1
(cid:96)2
(1 − (cid:96)1)(1 − (cid:96)1 − (cid:96)2)

0 )(cid:107)2
32
21

≤

≤

(cid:96)2.

Therefore,

which gives us

This then leads to

(cid:107)Diag[(Σ0 + E0)−1]Σ0 − I(cid:107)2 ≤

(cid:96)2(1 + (cid:96)1)
(1 − (cid:96)1)(1 − (cid:96)1 − (cid:96)2)

≤ (cid:96) :=

12
7

(cid:96)2.

(cid:107)Diag[(Σ0 + E0)−1]−1Σ−1

0 − I(cid:107)2 ≤

(cid:96)
1 − (cid:96)

≤

(cid:96)2.

24
11

(cid:107)Σ − Σ0(cid:107)2 ≤ (cid:107)Diag[(Σ0 + E0)−1]−1 − Σ0(cid:107)2 ≤

(1 + (cid:96)1)(cid:96)
1 − (cid:96)

≤ 3(cid:96)2.

Now since (cid:107)Σ0 + E0 − Σ(cid:107)2 ≤ 4(cid:96)2 ≤ 1, after t =

log 400
(cid:96)2
ηλmin(∆) iterations, we have

(cid:107)Σt + Et − Σ(cid:107)2 ≤

(cid:96)2.

1
80

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Then since Σt − Σ = Diag[Σt + Et − Σ], we have

This implies that

and

(cid:107)Σt − Σ(cid:107)2 ≤ (cid:107)Σt + Et − Σ(cid:107)2 ≤

(cid:96)2.

(cid:107)Et(cid:107)2 ≤ (cid:107)Σt − Σ(cid:107)2 + (cid:107)Σt + Et − Σ(cid:107)2 ≤

1
40

(cid:96)2

1
80

1
80

(cid:107)Σt − I(cid:107)2 ≤ (cid:107)Σt − Σ(cid:107)2 + (cid:107)Σ − Σ0(cid:107)2 + (cid:107)Σ0 − I(cid:107)2 ≤

(cid:96)2 + 3(cid:96)2 + (cid:96)1 ≤ (cid:96)1 + 4(cid:96)2.

Corollary 12 (Corollary of Lemma 11). Under the same setting as Lemma 11, suppose initially (cid:96)1 ≤ 1

17 , then

8 holds true through all stages,

1. (cid:96)1 ≤ 1
2. (cid:96)2 ≤ (cid:0) 1

40

(cid:1)t

after t stages.

Proof of Corollary 12. The second claim is trivial. For the ﬁrst claim, we have

((cid:96)1)stage s+1 ≤ ((cid:96)1)stage s + 4((cid:96)2)stage s ≤ · · · ≤

1
17

+

1
8

(cid:88)

i

(1/40)i ≤

1
8

.

A.3. Proof of the Main Theorems

With the update lemmas, we are ready to prove the main theorems.

Proof of Theorem 1. For simplicity, we only focus on the expected update. The on-line version can be proved directly from
this by noting that the variance of the update is polynomial bounded and setting accordingly a polynomially small η. The
expected update of A(t) is given by

A(t+1) = A(t) + η(E[yz(cid:62)] − A(t)E[zz(cid:62)])

Let us pick α = 1

4 , focus on one stage and write A = A∗(Σ0 + E0). Then the decoding is given by

z = φα(A†x) = φα((Σ0 + E0)−1x).

Let Σ, E be the diagonal part and the off diagonal part of (Σ0 + E0)−1. By Lemma 6,

(cid:107)E[(Σx − z)x(cid:62)Σ](cid:107)2, (cid:107)E[(Σx − z)z(cid:62)(cid:107)2 = O(C1).

Now, if we write A(t) = A∗(Σt + Et), then the expected update of Σt + Et is given by

Σt+1 + Et+1 = (Σt + Et)(I − Σ∆Σ) + Σ−1(Σ∆Σ) + Rt

where (cid:107)Rt(cid:107)2 = O(C1).
By Lemma 11, as long as C1 = O(σmin(∆)(cid:107)E0(cid:107)2) = O (cid:0) kλ
C1 with (cid:96) ≥ (cid:107)E0(cid:107)2, we can see that as long as

D (cid:107)E0(cid:107)2

(cid:1), we can make progress. Putting in the expression of

βkr
D

+

m(cid:96)4r2
α3D2 +

√

(cid:96)2

kmr1.5

D1.5β

+

(cid:96)4r3m
β2D2 +

(cid:96)5r2.5m
D2α2β

= O

(cid:18) kλ
D

(cid:19)
(cid:96)

,

we can make progress. By setting β = O (cid:0) λ(cid:96)

(cid:1), with Corollary 12 we completes the proof.

r

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Proof of Theorem 4. For simplicity, we only focus on the expected update. The on-line version can be proved directly from
this by setting a polynomially small η. The expected update of A(t) is given by

A(t+1) = A(t) + η(E[yz(cid:62)] − A(t)E[zz(cid:62)]).

Let us focus on one stage and write A = A∗(Σ0 + E0). Then the decoding is given by

z = φα(A†x) = φα((Σ0 + E0)−1x).

Let Σ, E be the diagonal part and the off diagonal part of (Σ0 + E0)−1. By Lemma 8,

(cid:107)E[(Σx − z)x(cid:62)Σ](cid:107)2, (cid:107)E[(Σx − z)z(cid:62)(cid:107)2 = O(C2).

Now, if we write A(t) = A∗(Σt + Et), then the expected update of Σt + Et is given by

Σt+1 + Et+1 = (Σt + Et)(I − Σ∆Σ) + Σ−1(Σ∆Σ) + Rt

where (cid:107)Rt(cid:107)2 = O(C2).
By Lemma 11, as long as C2 = O(σmin(∆)(cid:107)E0(cid:107)2) = O (cid:0) kλ
C2 with (cid:96) ≥ (cid:107)E0(cid:107)2, we can see that as long as

D (cid:107)E0(cid:107)2

(cid:1), we can make progress. Putting in the expression of

C2 =

(cid:96)4r3m
αβ2D2 +

(cid:96)5r2.5m
D2α2.5β

+

(cid:96)2kr
Dβ

(cid:16) m
Dk

(cid:17) q

2q+2

√
(cid:96)3r2
km
D1.5α2 +

+

(cid:96)6r4m
α4D2 + kβ

(cid:16) r
D

(cid:17) 2q+1

2q+2

+

kr
D

q+1
2 = O

α

(cid:18) kλ
D

(cid:19)
(cid:96)

,

we can make progress. Now set

λ(cid:96)
(cid:1) 2q+1

2q+2

, α =

(cid:18) λ(cid:96)
r

(cid:19) 2

q+1

β =

D (cid:0) r

D

and thus in C2,

1. First term

2. Second term

3. Third term

4. Fourth term

5. Fifth term

5q+6
q+1 m

(cid:96)2− 2
λ2+ 2

q+1 k0r
q+1 D2− 1

q+1

7q+16
2q+2 m

(cid:96)4− 5
λ1+ 5

q+1 k0r
q+1 D2− 1

2q+2

(cid:96)1k

q+2
2q+2 r

q
2q+2

4q+3
2q+2 m
3q+1
2q+2

λD

4

(cid:96)3− 4
q+1 k 1
λ

2 r
4
q+1 D− 3

2

q+1 +2m 1

2

q+1 k0r4+ 8
(cid:96)6− 8
q+1 D2
λ

8

q+1 m

We need each term to be smaller than λk(cid:96)

D , which implies that (we can ignore the constant (cid:96) )

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

1. First term:

2. Second term:

3. Third term:

4. Fourth term:

5. Fifth term:

m ≤

kD1− 1

q+1

q+1 λ3+ 2
r5+ 1

q+1

m ≤

kD1− 1
r

2q+2 λ2+ 5
2 + 9

2q+2

7

q+1

kD

m ≤

q

q−1

q λ4+ 4
r4+ 2

q

m ≤

q+1

kDλ2+ 8
r4+ 8

q+1

m ≤

q+1

kDλ1+ 8
r4+ 8

q+1

This is satisﬁed by our choice of m in the theorem statement.

Then with Corollary 12 we completes the proof.

A.4. Expectation Lemmas

A.4.1. LEMMAS WITH ONLY GCC

In this subsection, we assume that x follows (r, k, m, λ)-GCC. Then we show the following lemmas.

Lemma 13 (Expectation). For every (cid:96) ∈ [0, 1), every vector e such that (cid:107)e(cid:107)2 ≤ (cid:96), for every α such that α > 2(cid:96), we have

Proof of Lemma 13. Without lose of generality, we can assume that all the entries of e are non-negative. Let us denote a
new vector g such that

Due to the fact that (cid:107)x(cid:107)1 ≤ r, we can conclude (cid:104)e − g, x(cid:105) ≤ α

2r × r = α

2 , which implies

E[φα((cid:104)e, x(cid:105))] ≤

16m(cid:96)4r2
α2(α − 2(cid:96))D2 .

gi =

(cid:26) ei
0

if ei ≥ α
2r ;
otherwise.

φ α
2

((cid:104)g, x(cid:105)) ≥

φα((cid:104)e, x(cid:105)).

1
2

Now we can only focus on g. Since (cid:107)g(cid:107)2 ≤ (cid:96), we know that g has at most 4(cid:96)2r2
set of non-zero entries of g as E, so we have |E| ≤ 4(cid:96)2r2
α2 .

α2 non-zero entries. Let us then denote the

Suppose the all the x such that (cid:104)g, x(cid:105) ≥ α

2 forms a set S of size S, each x(s) ∈ S has probability pt. Then we have:

E[φα((cid:104)e, x(cid:105))] ≤ 2

ps(cid:104)g, x(s)(cid:105) = 2

(cid:88)

s∈[S]

(cid:88)

psgix(s)

.

i

s∈[S],i∈E

On the other hand, we have:

1. ∀s ∈ [S] : (cid:80)

i∈E gix(s)

i ≥ α
2 .

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

2. ∀i (cid:54)= j ∈ [D] : (cid:80)

s∈[S] psx(s)

i x(s)

j ≤ m

D2 . This is by assumption 5 of the distribution of x.

Using (2) and multiply both side by gigj, we get

(cid:88)

s∈[S]

ps(gix(s)

i )(gjx(s)

j ) ≤

mgigj
D2

Sum over all j ∈ E, j (cid:54)= i, we have:

(cid:88)

(cid:88)

s∈[S]

j∈E,j(cid:54)=i

ps(gix(s)

i )(gjx(s)

j ) ≤





mgi
D2

(cid:88)

j∈E,j(cid:54)=i



gj

 ≤

mgi
D2

(cid:88)

j∈E

gj

By (1), and since (cid:80)

j∈E gjx(s)

j ≥ α

2 and gi ≤ (cid:96), x(s)

i ≤ 1, we can obtain (cid:80)

j∈E,j(cid:54)=i gjx(s)

j ≥ α

2 − (cid:96). This implies

ps(gix(s)

i ) ≤

(cid:88)

s∈[S]

1
j∈E,j(cid:54)=i gjx(s)

j

(cid:80)

mgi
D2

(cid:88)

j∈E

2m
(α − 2(cid:96))D2 gi

(cid:88)

j∈E

gj.







gj

 ≤

Summing over i,

(cid:88)

psgix(s)

i ≤

2m
(α − 2(cid:96))D2

s∈[S],i∈E


2





(cid:88)

j∈E

2m

gj



≤

(α − 2(cid:96))D2 |E|(cid:107)g(cid:107)2

2 ≤

8m(cid:96)4r2
α2(α − 2(cid:96))D2 .

Putting everything together we complete the proof.

Lemma 14 (Expectation, Matrix). For every (cid:96), (cid:96)(cid:48) ∈ [0, 1), every matrices E, E(cid:48) ∈ RD×D such that (cid:107)E(cid:107)2, (cid:107)E(cid:48)(cid:107)2 ≤ (cid:96),
α ≥ 4(cid:96) and every bx ∈ [−1, 1] that depends on x, the following hold.

1. Let M be a matrix such that [M]i,j = bxφα((cid:104)[E]i, x(cid:105))xj, then

(cid:107)E[M](cid:107)2 ≤ (cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞ ≤

√

8(cid:96)3r2

km

D1.5α2

.

2. Let M be a matrix such that [M]i,j = bxφα((cid:104)[E]i, x(cid:105))φα((cid:104)[E(cid:48)]j, x(cid:105)), then

(cid:107)E[M](cid:107)2 ≤ (cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞ ≤

32(cid:96)6r4m
α4D2

.

Proof of Lemma 14. Since all the φα((cid:104)[E]i, x(cid:105)) and xi are non-negative, without lose of generality we can assume that
bx = 1.

1. We have

On the other hand,



E[Mi,j] = E

φα((cid:104)[E]i, x(cid:105))


 ≤ rE[φα((cid:104)[E]i, x(cid:105))] ≤

xj

16(cid:96)4r3m
α2(α − 2(cid:96))D2 .

(cid:88)

j∈[D]

(cid:88)

j∈[D]

E[Mi,j] = E

(cid:88)

i∈[D]









(cid:88)

i∈[D]

φα((cid:104)[E]i, x(cid:105))

 xj




 ≤ E[(uxEx)xj]

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

where ux is a vector with each entry either 0 or 1 depend on (cid:104)[E]i, x(cid:105) ≥ α or not. Note that (cid:80)
ux can only have at most (cid:96)2r

α2 entries equal to 1, so (cid:107)ux(cid:107)2 ≤ (cid:96)

√
r
α . This implies that

i(cid:104)[E]i, x(cid:105)2 ≤ (cid:96)2r, so

Therefore, (cid:80)

E[Mi,j] ≤ 2(cid:96)2rk

αD , which implies that

i∈[D]

(uxEx) ≤

(cid:96)2r
α

.

(cid:107)E[M](cid:107)2 ≤

√

√

4

2(cid:96)3r2
D1.5α1.5(cid:112)(α − 2(cid:96))

km

.

2. We have

(cid:107)E[M](cid:107)1 ≤ max

E[Mi,j] = max

E

φα((cid:104)[E]i, x(cid:105))

φα((cid:104)[E(cid:48)]j, x(cid:105))

 ≤

(cid:88)

i

j∈[D]



i

(cid:88)

j∈[D]



(cid:96)2r
α

16(cid:96)4r3m
D2α2(α − 2(cid:96))

.

In the same way we can bound (cid:107)E[M](cid:107)∞ and get the desired result.

A.4.2. LEMMAS WITH xi ∈ {0, 1}

Here we present some expectation lemmas when xi ∈ {0, 1}.
Lemma 15 (Expectation, Matrix). For every (cid:96), (cid:96)(cid:48) ∈ [0, 1), every matrices E, E(cid:48) ∈ RD×D such that (cid:107)E(cid:107)2, (cid:107)E(cid:48)(cid:107)2 ≤ (cid:96), and
∀i ∈ [D], |Ei,i||E(cid:48)
i,i| ≤ (cid:96)(cid:48), then for every β > 4(cid:96)(cid:48) and α ≥ 4(cid:96) and every bx ∈ [−1, 1] that depends on x, the following
hold.

1. Let M be a matrix such that [M]i,j

(cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞ = bxφβ((cid:104)[E]i, x(cid:105))xixj, then

(cid:107)E[M](cid:107)2 ≤ (cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞ ≤

8(cid:96)1.5r1.25m
D1.5β0.5 .

2. Let M be a matrix such that [M]i,j = bxφβ((cid:104)[E]i, x(cid:105))xixjφβ((cid:104)[E(cid:48)]j, x(cid:105)), then

(cid:107)E[M](cid:107)2 ≤ (cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞ ≤

8(cid:96)4r3m
β2D2 .

3. Let M be a matrix such that [M]i,j = bxφβ((cid:104)[E]i, x(cid:105))xiφα((cid:104)[E(cid:48)]j, x(cid:105)), then

(cid:107)E[M](cid:107)2 ≤ (cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞ ≤

16(cid:96)5r2.5m
D2α2β

.

Proof. This Lemma is a special case of Lemma 21 by setting γ = 1.

A.4.3. LEMMAS WITH GENERAL xi

Here we present some expectation lemmas for the general case where xi ∈ [0, 1] and the distribution of x satisﬁes the
order-q decay condition.

Lemma 16 (General expectation). Suppose the distribution of x satisﬁes the order-q decay condition.

∀i ∈ [D], E[xi] ≤ Pr[xi (cid:54)= 0] ≤

(q + 2)2k
qD

.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Proof. Denote s = Pr[xi (cid:54)= 0]. By assumption, Pr[xi ≤
s(1 − αq/2). Now, since

√

α | xi (cid:54)= 0] ≤ αq/2, which implies that Pr[xi >

α] >

√

We obtain

E[x2

i ] =

Pr[x2

i ≥ α] =

(cid:90) 1

0

(cid:90) 1

0

√

Pr[xi ≥

α] ≤

2k
D

,

s ≤

2k
D

1
(cid:82) 1
0 (1 − αq/2)dα

≤

q + 2
q

2k
D

.

Lemma 17 (Truncated covariance). For every α > 0, every bx ∈ [−1, 1] that depends on x, the following holds. Let M
be a matrix such that [M]i,j = bx1xi≤αxixj, then

(cid:107)E[M](cid:107)2 ≤ (cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞ ≤

6kr
D

q+1
2 .

α

Proof of Lemma 17. Again, without lose of generality we can assume that bx are just 1.

E[1xi≤αxixj] ≤ rE[1xi≤αxi] ≤ rαE[10<xi≤α] = rα Pr[xi ∈ (0, α]].

On one hand,

By Lemma 16,

(cid:88)

j∈[D]

and thus

On the other hand,

Pr[xi ∈ (0, α]] = Pr[xi (cid:54)= 0] Pr[xi ≤ α | xi (cid:54)= 0] ≤

(q + 2)2k
qD

αq,

(cid:88)

j∈[D]

(cid:88)

i∈[D]

E[1xi≤αxixj] ≤

2(q + 2)kr
qD

αq+1 ≤

αq+1.

6kr
D

E[1xi≤αxixj] ≤ E





xi

 xj

 ≤









(cid:88)

i∈[D]

6kr
D

.

Putting everything together we completes the proof.

Lemma 18 (Truncated half covariance). For every α > 0, every bx ∈ [−1, 1] that depends on x, the following holds. Let
M be a matrix such that [M]i,j = bx1xi≥αxj, then

(cid:107)E[M](cid:107)2 ≤ (cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞ ≤ 12k

(cid:17) 2q+1

2q+2

(cid:16) r
D

Proof of Lemma 18. Without lose of generality, we can assume bx = 1. We know that

E[1xi≥αxj] ≤ Pr[xi (cid:54)= 0]E[xj | xi (cid:54)= 0]

≤

≤

1
s
1
s

E[xixj] + sq Pr[xi (cid:54)= 0].

Pr[xi (cid:54)= 0]E[1xi≥sxixj | xi (cid:54)= 0] + Pr[xi (cid:54)= 0]E[1xi<s | xi (cid:54)= 0]

From Lemma 16 we know that Pr[xi (cid:54)= 0] ≤ 6k

D , which implies that

E[xixj] = E[

xixj] ≤ rE[xj] ≤ r Pr[xj (cid:54)= 0] ≤

(cid:88)

i∈[D]

(cid:88)

i∈[D]

6kr
D

.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Therefore,

(cid:88)

i∈[D]

E[1xi≥αxj] ≤ 6ksq +

1
s

6kr
D

Choosing the optimal s, we are able to obtain

(cid:88)

i∈[D]

E[1xi≥αxj] ≤

(cid:19)q/(q+1)

(cid:18) r
qD

6k(q + 1) ≤ 24k

(cid:17)q/(q+1)

.

(cid:16) r
D

On the other hand,

(cid:88)

j∈[D]

E[1xi≥αxj] ≤ rE[1xi>0] ≤

6k
D

r.

Putting everything together we get the desired bound.

Lemma 19 (Expectation). For every (cid:96) ∈ [0, 1), every vector e such that (cid:107)e(cid:107)2 ≤ (cid:96), for every i ∈ [D], α > 2|ei|, γ > 0, the
following hold.

1.

2. If ei = 0, then

∀i ∈ [D] : E[φα((cid:104)e, x(cid:105))1xi≥γ] ≤

4(cid:96)2rm
γD2(α − 2|ei|)

.

∀i ∈ [D] : E[φα((cid:104)e, x(cid:105))1xi≥γ] ≤

24kr(cid:96)2
Dα

(cid:16) m
Dk

(cid:17)q/(q+1)

.

Proof of Lemma 19. We deﬁne g as in Lemma 13. We still have (cid:107)g(cid:107)1 ≤ (cid:107)g(cid:107)2

2

≤ 2r(cid:96)2
α .

α
2r

1. The value φα((cid:104)e, x(cid:105))1xi≥γ is non-zero only when xi ≥ γ. Therefore, we shall only focus on this case.

Let us again suppose x such that (cid:104)g, x(cid:105) ≥ α

2 and xi ≥ γ forms a set S of size S, each x(s) ∈ S has probability ps.

Claim 20.
(2) ∀j (cid:54)= i ∈ [D] : (cid:80)
(3) By Lemma 18,

(1) ∀s ∈ [S] : (cid:80)

j∈E gjx(s)
j x(s)

j ≥ α
2 .
i ≤ m
D2 .

s∈[S] psx(s)

∀j (cid:54)= i ∈ [D] :

(cid:88)

a∈[S]

pax(a)

j ≤

1
s

m

D2 + sq 6k

D

=

6k(q + 1)
D

6Dkq

(cid:18) m

(cid:19)q/(q+1)

by choosing optimal s. Moreover, we can directly calculate that

(cid:18) m

(cid:19)q/(q+1)

6k(q + 1)
D

6Dkq

≤

6k
D

(cid:16) m
Dk

(cid:17)q/(q+1)

.

With Claim 20(2), multiply both side by gj and taking the summation,

Using the fact that x(s)

i ≥ γ for every s ∈ [S], we obtain

(cid:88)

psgjx(s)

j x(s)

i ≤

s∈[S],j∈E,j(cid:54)=i

m
D2

(cid:88)

gj.

j∈E,j(cid:54)=i

(cid:88)

psgjx(s)

j ≤

s∈[S],j∈E,j(cid:54)=i

m
γD2

(cid:88)

gj.

j∈E,j(cid:54)=i

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

On the other hand, by Claim 20(1) and the fact that |ei| ≥ gi ≥ 0, we know that

Using the fact that x(s)

i ≥ γ for every s ∈ [S], we obtain

(cid:88)

j∈E,j(cid:54)=i

gjx(s)

j ≥

− |ei|.

α
2

(cid:88)

s∈[S]

ps ≤

2m
γ(α − 2|ei|)D2

(cid:88)

gj.

j∈E,j(cid:54)=i

Therefore, since gi ≤ |ei|,

(cid:88)

psgjx(s)

j ≤

(cid:88)

psgjx(s)

j +

(cid:88)

psgix(s)

i

s∈[S],j∈E

s∈[S],j∈E,j(cid:54)=i
(cid:18)

≤

m
γD2

1 +

2gi
α − 2|ei|

s∈[S]

(cid:19) (cid:88)

j∈E,j(cid:54)=i

gj ≤

m
γD2

α
α − 2|ei|

(cid:107)g(cid:107)1 ≤

2(cid:96)2rm
γD2(α − 2|ei|)

.

2. When ei = 0, in the same manner, but using Claim 20(3), we obtain

(cid:88)

s∈[S]

psgjx(s)

j ≤

6k
D

(cid:16) m
Dk

(cid:17)q/(q+1)

gj.

Summing over j ∈ E, j (cid:54)= i we have:

(cid:88)

psgjx(s)

j ≤

6k
D

(cid:16) m
Dk

(cid:17)q/(q+1) 2r(cid:96)2
α

.

s∈[S],j∈E,j(cid:54)=i

Lemma 21 (Expectation, Matrix). For every (cid:96), (cid:96)(cid:48) ∈ [0, 1), every matrices E, E(cid:48) ∈ RD×D such that (cid:107)E(cid:107)2, (cid:107)E(cid:48)(cid:107)2 ≤ (cid:96),
i,i| ≤ (cid:96)(cid:48), every β > 4(cid:96)(cid:48) and α ≥ 4(cid:96), every γ > 0 and every bx ∈ [−1, 1] that depends on x, the
and ∀i ∈ [D], |Ei,i|, |E(cid:48)
following hold.

1. Let M be a matrix such that [M]i,j = bxφβ((cid:104)[E]i, x(cid:105))1xi≥γxj, then

(cid:107)E[M](cid:107)2 ≤ (cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞ ≤ min

(cid:40)

8(cid:96)2
√

√

kr1.5√
γD1.5β

m

,

12k(cid:96)2r
Dβ

(cid:16) m
Dk

(cid:17)q/(2q+2)(cid:41)

.

2. Let M be a matrix such that [M]i,j = bxφβ((cid:104)[E]i, x(cid:105))1xi≥γ1xj ≥γφβ((cid:104)[E(cid:48)]j, x(cid:105)), then

(cid:107)E[M](cid:107)2 ≤ (cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞ ≤

8(cid:96)4r2m
γβ2D2 .

3. Let M be a matrix such that [M]i,j = bxφβ((cid:104)[E]i, x(cid:105))1xi≥γφα((cid:104)[E(cid:48)]j, x(cid:105)), then

(cid:107)E[M](cid:107)2 ≤ (cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞ ≤

16(cid:96)5r2.5m
√
γD2α2β

.

Proof of Lemma 21. Without loss of generality, assume bx = 1.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

1. Since every entry of M is non-negative, by Lemma 19,



E[Mi,j] = E

φβ((cid:104)[E]i, x(cid:105))1xi≥γ


 ≤ rE[φβ((cid:104)[E]i, x(cid:105))1xi≥γ] ≤

xj

4(cid:96)2r2m
γD2(β − 2(cid:96)(cid:48))

(cid:88)

j∈[D]

(cid:88)

j∈[D]

On the other hand, as in Lemma 14, we know that

and

Therefore,

E[Mi,j] ≤

24kr(cid:96)2
Dβ

(cid:16) m
Dk

(cid:17)q/(q+1)

.

(cid:88)

j∈[D]

φβ((cid:104)[E(cid:48)]j, x(cid:105)) ≤

(cid:96)2r
β

.

(cid:88)

j∈[D]

E[φβ((cid:104)[E]i, x(cid:105))1xi≥γxj] ≤

E[xj] ≤

(cid:96)2r
β

6k(cid:96)2r
βD

.

(cid:88)

i∈[D]

Now, since each entry of M is non-negative, using (cid:107)E[M](cid:107)2 ≤ (cid:112)(cid:107)E[M](cid:107)1(cid:107)E[M](cid:107)∞, we obtain the desired bound.
E[Mi,j], and a similar bound holds for

2. Since now M is a “symmetric” matrix, we only need to look at (cid:80)

j∈[D]

(cid:80)

E[Mi,j].

i∈[D]

E[Mi,j] = E

φβ((cid:104)[E]i, x(cid:105))1xi≥γ

φβ((cid:104)[E(cid:48)]j, x(cid:105))1xj ≥γ

 ≤



(cid:96)2r
β

4(cid:96)2rm
γD2(β − 2(cid:96)(cid:48))

.

(cid:88)

j∈[D]

(cid:88)

j∈[D]

E[Mi,j] = E

φβ((cid:104)[E]i, x(cid:105))1xi≥γ

φα((cid:104)[E(cid:48)]j, x(cid:105))

 ≤



(cid:96)2r
α

4(cid:96)2rm
γD2(β − 2(cid:96)(cid:48))

.

E[Mi,j] = E

φβ((cid:104)[E]i, x(cid:105))1xi≥γ









(cid:88)

i∈[D]


 φα((cid:104)[E(cid:48)]j, x(cid:105))



 ≤

(cid:96)2r
β

16(cid:96)4r2m
D2α2(α − 2(cid:96))

.

(cid:107)E[M](cid:107)2 ≤

√

8(cid:96)5r2.5m
√

√

γD2α1.5β0.5

β − 2(cid:96)(cid:48)

α − 2(cid:96)

≤

16(cid:96)5r2.5m
√
γD2α2β

.





The conclusion then follows.

3. On one hand,

(cid:88)

j∈[D]

(cid:88)

j∈[D]

(cid:88)

i∈[D]

On the other hand,

Therefore,

A.5. Robustness

In this subsection, we show that our algorithm is also robust to noise. To demonstrate the idea, we will present a proof for
the case when xi ∈ {0, 1}. The general case when xi ∈ [0, 1] follows from the same argument, just with more calculations.
Lemma 22 (Expectation). For every (cid:96), ν ∈ [0, 1), every vector e such that (cid:107)e(cid:107)2 ≤ (cid:96), every α such that α > 2(cid:96) + 2ν, the
following hold.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

1. E[φα((cid:104)e, x(cid:105) + ν)] ≤

16m(cid:96)4r2
α2(α−2(cid:96)−2ν)D2 .

2. If ei,i = 0, then E[|(cid:104)ei, x(cid:105)|xi] ≤

(cid:113) 2mkr
D3 .

Proof of Lemma 22. The proof of this lemma is almost the same as the proof of Lemma 13 with a few modiﬁcations.

1. Without lose of generality, we can assume that all the entries of e are non-negative. Let us denote a new vector g such
that

Due to the fact that (cid:107)x(cid:107)1 ≤ r, we can conclude (cid:104)e − g, x(cid:105) ≤ α

2 , which implies

gi =

(cid:26) ei
0

if ei ≥ α
2r ,
otherwise.

φ α
2

((cid:104)g, x(cid:105) + ν) ≥

φα((cid:104)e, x(cid:105) + ν).

2r × r = α
1
2

Now we can only focus on g. Since (cid:107)g(cid:107)2 ≤ (cid:96), we know that g has at most 4(cid:96)2r2
set of non-zero entries of g as E. Then we have |E| ≤ 4(cid:96)2r2
α2 .

α2 non-zero entries. Let us then denote the

Suppose the all the x such that (cid:104)g, x(cid:105) ≥ α

2 − ν forms a set S of size S, each x(s) ∈ S has probability pt. Then
(cid:88)

(cid:88)

E[φα((cid:104)e, x(cid:105))] ≤ 2

ps(cid:104)g, x(s)(cid:105) = 2

psgix(s)

.

i

s∈[S]

s∈[S],i∈E

On the other hand, we have the following claim.
1. ∀s ∈ [S] : (cid:80)

Claim 23.

i ≥ α

2 − ν.

i∈E gix(s)
i x(s)

j ≤ m

Using (2) and multiply both side by gigj, we get

2. ∀i (cid:54)= j ∈ [D] : (cid:80)

s∈[S] psx(s)

D2 . This is by the GCC conditions of the distribution of x.

(cid:88)

s∈[S]

ps(gix(s)

i )(gjx(s)

j ) ≤

mgigj
D2

.

Sum over all j ∈ E, j (cid:54)= i,

(cid:88)

(cid:88)

s∈[S]

j∈E,j(cid:54)=i

ps(gix(s)

i )(gjx(s)

j ) ≤





mgi
D2

(cid:88)

j∈E,j(cid:54)=i



gj

 ≤

mgi
D2

(cid:88)

j∈E

gj.

Using (1), and that (cid:80)

j∈E gjx(s)

j ≥ α

2 − ν and gi ≤ (cid:96), x(s)

i ≤ 1, we can obtain

(cid:88)

gjx(s)

j ≥

α
2

j∈E,j(cid:54)=i

− ν − (cid:96).

This implies

Summing over i,

ps(gix(s)

i ) ≤

(cid:88)

s∈[S]

1
j∈E,j(cid:54)=i gjx(s)

j

(cid:80)

mgi
D2

(cid:88)

j∈E

2m
(α − 2ν − 2(cid:96))D2 gi

(cid:88)

j∈E

gj.







gj

 ≤

(cid:88)

psgix(s)

i ≤

2m
(α − 4(cid:96))D2

s∈[S],i∈E


2





(cid:88)

j∈E

gj



≤

(α − 2ν − 2(cid:96))D2 |E|(cid:107)g(cid:107)2

2 ≤

2m

8m(cid:96)4r2
α2(α − 2(cid:96) − 2ν)D2 .

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

2. We can directly bound this term as follows.

E[|(cid:104)e, x(cid:105)|xi] ≤

|ej|E[xixj] ≤ (cid:96)

E[xixj]2 ≤ (cid:96)

E[xixj]2 ≤ (cid:96)

(cid:115)(cid:88)

j(cid:54)=i

(cid:115) m
D2

(cid:88)

j(cid:54)=i

(cid:88)

j(cid:54)=i

(cid:114)

2mkr
D3 .

We show the following lemma saying that even with noise, A†A∗ is roughly (Σ + E)−1.
Lemma 24 (Noisy inverse). Let A ∈ RW ×D be a matrix such that A = A∗(Σ + E) + N, for diagonal matrix Σ (cid:23) 1
off diagonal matrix E with (cid:107)E(cid:107)2 ≤ (cid:96) ≤ 1

4 σmin(A∗). Then

8 and (cid:107)N(cid:107)2 ≤ 1

2 I,

(cid:107)A†A∗ − (Σ + E)−1(cid:107)2 ≤

2(cid:107)N(cid:107)2

(cid:0) 1
2 − 3

2 (cid:96)(cid:1) σmin(A∗) − (cid:107)N(cid:107)2

≤

32(cid:107)N(cid:107)2
σmin(A∗)

.

Proof of Lemma 24.

(cid:107)A†A∗ − (Σ + E)−1(cid:107)2 ≤ (cid:107)A†(A∗(Σ + E) + N)(Σ + E)−1 − (Σ + E)−1(cid:107)2 + (cid:107)A†N(cid:107)2(cid:107)(Σ + E)−1(cid:107)2

≤ (cid:107)A†N(cid:107)2(cid:107)(Σ + E)−1(cid:107)
2
(1 − (cid:96))σmin(A)

(cid:107)N(cid:107)2.

≤

Since A = A∗(Σ + E) + N,

σmin(A) ≥ σmin(A∗(Σ + E)) − (cid:107)N(cid:107)2 ≥

− (cid:96)

σmin(A∗) − (cid:107)N(cid:107)2.

(cid:19)

(cid:18) 1
2

Putting everything together, we are able to obtain

(cid:107)A†A∗ − (Σ + E)−1(cid:107)2 ≤

(1 − (cid:96)) (cid:0) 1

2 − (cid:96)(cid:1) σmin(A∗) − (cid:107)N(cid:107)2

(cid:107)N(cid:107)2 ≤

(cid:0) 1
2 − 3

2 (cid:96)(cid:1) σmin(A∗) − (cid:107)N(cid:107)2

.

2

2(cid:107)N(cid:107)2

Lemma 25 (Noisy decoding). Suppose we have z = φα((Σ(cid:48) + E(cid:48))x + ξx) for diagonal matrix (cid:107)Σ(cid:48) − I(cid:107)2 ≤ 1
off diagonal matrix E(cid:48) such that (cid:107)E(cid:48)(cid:107)2 ≤ (cid:96) ≤ 1
4 > α > 4(cid:96) + 4ν, m ≤ D
1

2 and
8 and random variable ξx depend on x such that (cid:107)ξx(cid:107)∞ ≤ ν. Then if

r2 , we have

(cid:107)E[(Σx − z)x(cid:62)](cid:107)2, (cid:107)E[(Σx − z)z(cid:62)](cid:107)2 = O (C3)

where

C3 = (ν + β)

+

kr
D

m(cid:96)4r2
α3D2 +

√

(cid:96)2

kmr1.5

D1.5β

+

(cid:96)4r3m
β2D2 +

(cid:96)5r2.5m
D2α2β

.

Proof of Lemma 25. Since we have now

Like in Lemma 6, we can still show that

zi = φα(Σ(cid:48)

i,ixi + (cid:104)ei, x(cid:105) + ξx

i ).

|Σ(cid:48)

i,ixi + (cid:104)ei, x(cid:105)xi + ξx

i xi − zi| ≤ φα((cid:104)ei, x(cid:105) + ξx

i ) ≤ φα((cid:104)ei, x(cid:105) + ν)

which implies that there exists ax,ξ ∈ [−1, 1] that depends on x, ξ such that

zi − Σ(cid:48)

i,ixi = (cid:104)ei, x(cid:105)xi + ξx

i xi + ax,ξφα((cid:104)ei, x(cid:105) + ν).

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Therefore,

E[z2

i ] ≤ 3(Σ(cid:48)

i,i + ν)2E[x2

(cid:114)

i ] + 3E[(cid:104)ei, x(cid:105)2x2
r + ν)m(cid:96)4r2
48((cid:96)
2mk
D3 +
α2(α − 2ν − 2(cid:96))D2

i ] + 3E[φα((cid:104)ei, x(cid:105) + ν)2]
√

+ 3(cid:96)2r

≤

≤ O

6(2 + ν)2k
D
(cid:18) k
D

(cid:19)

.

i,ixi = (cid:104)ei, x(cid:105)xi + ξx
Again, from zi − Σ(cid:48)
but using Lemma 22 instead of Lemma 13, we obtain the result.

i xi + ax,ξφα((cid:104)ei, x(cid:105) + ν), following the exact same calculation as in Lemma 6,

Deﬁnition 5 ((γ1, γ2)-rounded). A random variable ζ is (γ1, γ2) rounded if

(cid:107)E[ζζ (cid:62)](cid:107)2 ≤ γ1,

(cid:107)ζ(cid:107)2 ≤ γ2.

Theorem 26 (Noise). Suppose A0 is ((cid:96), ρ)-initialization for (cid:96) = O(1), ρ = O(σmin(A∗)). Suppose that the data is
generated from y(t) = A∗x(t) + ζ (t), where ζ (t) is (γ1, γ2)-rounded, and γ2 = O(σmin(A∗)).
Then after poly(D, 1

(cid:15) ) iterations, Algorithm 1 outputs a matrix A such that there exists diagonal matrix ˜Σ (cid:23) 1

2 I with

(cid:107)A − A∗ ˜Σ(cid:107)2 = O

(cid:32)

√

(cid:114)

r

γ2
λ

σmax(A∗)
σmin(A∗)

+

γ1
λ

(cid:33)

+ ε

.

D
k

Proof of Theorem 26. For notation simplicity, we only consider one stages, and we drop the round number here and let
(cid:101)A = A(t+1) and A = A(t), and we denote the new decomposition as (cid:101)A = A∗( (cid:101)Σ + (cid:101)E) + (cid:101)N.

Thus, the decoding of z is given by

z = φα(A†

0(A∗x + ζ)).

By Lemma 24, there exists a matrix R such that (cid:107)R(cid:107)2 ≤ 32(cid:107)N0(cid:107)2
(Σ0 + E0)−1 + R, where Σ(cid:48) is diagonal and E(cid:48) is off-diagonal. Then

σmin(A∗) with A†

0A∗ = (Σ0 + E0)−1 + R. Now let Σ(cid:48) + E(cid:48) =

For simplicity, we only focus on the expected update. The on-line version can be proved directly from this by setting a
polynomially small η. The expected update is given by

z = φα((Σ(cid:48) + E(cid:48))x + A†

0ζ)

ν := (cid:107)A†

0ζ(cid:107)∞ ≤

16(cid:107)ζ(cid:107)2
σmin(A∗)

≤

16γ2
σmin(A∗)

.

(cid:101)A = A + ηE[(A∗x + ζ)z(cid:62) − Azz(cid:62)].

A∗( (cid:101)Σ + (cid:101)E) + (cid:101)N = A + ηE[(A∗x + ζ)z(cid:62) − Azz(cid:62)]

= A∗[(Σ + E)(I − ηE[zz(cid:62)]) + ηE[xz(cid:62)]] + N(I − ηE[zz(cid:62)]) + E[ζz(cid:62)].

(cid:101)Σ + (cid:101)E = (Σ + E)(I − ηE[zz(cid:62)]) + ηE[xz(cid:62)],

(cid:101)N = N(I − ηE[zz(cid:62)]) + E[ζz(cid:62)].

(cid:101)Σ + (cid:101)E = (Σ + E)(I − ηΣ(cid:48)∆Σ(cid:48)) + η∆Σ(cid:48) + C1

where

Therefore,

So we still have

By Lemma 25,

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

(cid:101)N = N(I − ηΣ(cid:48)∆Σ(cid:48)) + E[ζz(cid:62)] + NC2.

where (cid:107)C1(cid:107)2, (cid:107)C2(cid:107)2 ≤ C3, and

C3 = (ν + β)

+

kr
D

m(cid:96)4r2
α3D2 +

√

(cid:96)2

kmr1.5

D1.5β

+

(cid:96)4r3m
β2D2 +

(cid:96)5r2.5m
D2α2β

.

First, consider the update on (cid:101)Σ + (cid:101)E. By a similar argument as in Lemma 11, we know that as long as C3 = O (cid:0) k
D λ(cid:107)E0(cid:107)2
and ν = O((cid:96)), we can reduce the norm of E by a constant factor in polynomially many iterations. To satisfy the requirement
on C3, we will choose α = 1/4, β = λ

r . Then to make the terms in C3 small, m is set as follows.

(cid:1)

1. Second term:

2. Third term:

3. Fourth term:

4. Fifth term:

m ≤

Dkλ
r2 .

m ≤

Dλ4k
r5

.

m ≤

Dλ3k
r5

.

m ≤

Dλ2k
r3.5 .

This implies that after poly( 1

ε ) stages, the ﬁnal E will have

Next, consider the update on (cid:101)N. Since the chosen value satisﬁes C3 ≤ 1

2 σmin(Σ(cid:48)∆Σ(cid:48)), we have

(cid:107)E(cid:107)2 = O

(cid:18)

rγ2
λσmin(A∗)

(cid:19)

+ ε

.

(cid:26)

(cid:107) (cid:101)N(cid:107)2 ≤ max

(cid:107)N0(cid:107)2,

2(cid:107)E[ζz(cid:62)](cid:107)2
σmin(Σ(cid:48)∆Σ(cid:48))

(cid:27)

.

For the term E[ζz(cid:62)], we know that for every vectors u, v with norm 1,

u(cid:62)E[ζz(cid:62)]v ≤ E[|(cid:104)u, ζ(cid:105)||(cid:104)z, v(cid:105)|].

Since z is non-negative, we might without loss of generality assume that v is all non-negative, and obtain

E[|(cid:104)u, ζ(cid:105)||(cid:104)z, v(cid:105)|] ≤ (cid:112)E[(cid:104)u, ζ(cid:105)2]E[(cid:104)z, v(cid:105)2] ≤ (cid:112)E[(cid:104)u, ζ(cid:105)2]

(cid:114)

max
i∈[D]

E[z2

i ] = O

(cid:32)(cid:114)

(cid:33)

.

kγ1
D

Putting everything together and applying Corollary 12 across stages complete the proof.

Proof of Theorem 5. The theorem follows from Theorem 26 and noting that
order.

(cid:113) D

√

γ1
λ

k is smaller than r γ2

λ

σmax(A∗)
σmin(A∗) in

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

B. Additional Experiments

Here we provide additional experimental results. The ﬁrst set of experiments in Section B.1 evaluates the performance
of our algorithm in the presence of weak initialization, since for our theoretical analysis a warm start is crucial for the
convergence. It turns out that our algorithm is not very sensitive to the warm start; even if there is a lot of noise in the
initialization, it still produces reasonable results. This allows it to be used in a wide arrange of applications where a strong
warm start is hard to achieve.

The second set of experiments in Section B.2 evaluates the performance of the algorithm when the weight x has large
sparsity. Note that our current bounds have a slightly strong dependency on the (cid:96)1 norm of x. We believe that this is only
because we want to make our statement as general as possible, making only assumptions on the ﬁrst two moments of x. If
in addition, for example, x is assumed to have nice third moments, then our bound can be greatly improved. Here we show
that empirically, our algorithm indeed works for typical distributions with large sparsity.

The ﬁnal set of experiments in Section B.3 applies our algorithm on typical real world applications of NMF. In particular,
we consider topic modeling on text data and component analysis for image data, and compare our method to popular
existing methods.

B.1. Robustness to Initializations

In all the experiments in the main text, the initialization matrix A0 is set to A0 = A∗(I + U) where I is the identity
matrix and U is a matrix whose entries are i.i.d. samples from the uniform distribution on [−0.05, 0.05]. Note that this is
a very weak initialization, since [A0]i = (1 + Ui,i)[A∗]i + (cid:80)
j(cid:54)=i Uj,i[A∗]j and the magnitude of the noise component
(cid:80)

j(cid:54)=i Uj,i[A∗]j can be larger than the signal part (1 + Ui,i)[A∗]i.

Here, we further explore even worse initializations: A0 = A∗(I + U) + N where I is the identity matrix, U is a matrix
whose entries are i.i.d. samples from the uniform distribution on [−0.05, 0.05] × rl for a scalar rl, N is an additive error
matrix whose entries are i.i.d. samples from the uniform distribution on [−0.05, 0.05] × rn for a scalar rn. Here, we call
U the in-span noise and N the out-of-span noise, since they introduce noise in or out of the span of A∗.

We varied the values of rl or rn, and found that even when U violates our assumptions strongly, or the column norm of N
becomes as large as the column norm of the signal A∗, the algorithm can still recover the ground-truth up to small relative
error. Figure 3(a) shows the results for different values of rl. Note that when rl = 1, the in-span noise already violates our
assumptions, but as shown in the ﬁgure, even when rl = 2, the ground-truth can still be recovered, though at a slower yet
exponential rate. Figure 3(b) shows the results for different values of rn. For these noise values, the column norm of the
noise matrix N is comparable or even larger than the column norm of the signal A∗, but as shown in the ﬁgure, such noise
merely affects on the convergence.

(a) Initialization with in-span noise

(b) Initialization with out-of-span noise

Figure 3. The performance of the algorithm AND with weak initialization. The x-axis is the running time (in seconds), the y-axis is the
logarithm of the total correlation error. (a) Using different values for the noise level rl that controls the in-span noise in the initialization.
(b) Using different values for the noise level rn that controls the out-of-span noise in the initialization.

010002000300040005000Time in seconds−20−15−10−50510log(Error)noise level 1noise level 2noise level 4010002000300040005000Time in seconds−20−15−10−50510log(Error)noise level 0.005noise level 0.01noise level 0.015noise level 0.02Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

B.2. Robustness to Sparsity

We performed experiments on the DIR data with different sparsity. In particular, construct a 100 × 5000 matrix X, where
each column is drawn from a Dirichlet prior D(α) on d = 100 dimension, where α = (α/d, α/d, . . . , α/d) for a scalar α.
Then the dataset is Y = A∗X. We varied the α parameter of the prior to control the expected support sparsity, and ran the
algorithm on the data generated.

Figure 4 shows the results. For α as large as 20, the algorithm still converges to the ground-truth in exponential rate. When
α = 80 meaning that the weight vectors (columns in X) have almost full support, the algorithm still produces good results,
stabilizing to a small relative error at the end. This demonstates that the algorithm is not sensitive to the support sparsity
of the data.

Figure 4. The performance of the algorithm AND on data generated from Dirichlet prior on x with different sparsities. The x-axis is the
running time (in seconds), the y-axis is the logarithm of the total correlation error.

B.3. Qualitative Results on Some Real World Applications

We applied our algorithm to two popular applications with real world data to demonstrate the applicability of the method
to real world scenarios. Note that the evaluations here are qualitative, due to that the guarantees for our algorithm is the
convergence to the ground-truth, while there are no predeﬁned ground-truth for these datasets in practice. Quantitative
studies using other criteria computable in practice are left for future work.

B.3.1. TOPIC MODELING

Here our method is used to compute 10 topics on the 20newsgroups dataset, which is a standard dataset for the topic
modeling setting. Our algorithm is initialized with 10 random documents from the dataset, and the hyperparameters like
learning rate are from the experiments in the main text. Note that better initialization is possible, while here we keep things
simple to demonstrate the power of the method.

Table 1 shows the results of the NMF method and the LDA method in the sklearn package,10 and the result of our AND
method. It shows that our method indeed leads to reasonable topics, with quality comparable to well implemented popular
methods tuned to this task.

10http://scikit-learn.org/

010002000300040005000Time in seconds−10−50510log(Error)support sparsity 5support sparsity 10support sparsity 20support sparsity 80Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

Method

NMF (sklearn)

LDA (sklearn)

AND (ours)

Topic
just people don think like know time good make way
windows use dos using window program os drivers application help
god jesus bible faith christian christ christians does heaven sin
thanks know does mail advance hi info interested email anybody
car cars tires miles 00 new engine insurance price condition
edu soon com send university internet mit ftp mail cc
ﬁle problem ﬁles format win sound ftp pub read save
game team games year win play season players nhl runs
drive drives hard disk ﬂoppy software card mac computer power
key chip clipper keys encryption government public use secure enforcement
edu com mail send graphics ftp pub available contact university
don like just know think ve way use right good
christian think atheism faith pittsburgh new bible radio games
drive disk windows thanks use card drives hard version pc
hiv health aids disease april medical care research 1993 light
god people does just good don jesus say israel way
55 10 11 18 15 team game 19 period play
car year just cars new engine like bike good oil
people said did just didn know time like went think
key space law government public use encryption earth section security
game team year games win play season players 10 nhl
god jesus does bible faith christian christ new christians 00
car new bike just 00 like cars power price engine
key government chip clipper encryption keys use law public people
young encrypted exactly evidence events especially error eric equipment entire
thanks know does advance mail hi like info interested anybody
windows ﬁle just don think use problem like ﬁles know
drive drives hard card disk software ﬂoppy think mac power
edu com soon send think mail ftp university internet information
think don just people like know win game sure edu

Table 1. Results of different methods computing 10 topics on the 20newsgroups dataset. Each topic is visualized by using its top frequent
words, and each line presents one topic.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

B.3.2. IMAGE DECOMPOSITION

Here our method is used to compute 6 components on the Olivetti faces dataset, which is a standard dataset for image
decomposition. Our algorithm is initialized with 6 random images from the dataset, and the hyperparameters like learning
rate are from the experiments in the main text. Again, note that better initialization is possible, while here we keep things
simple to demonstrate the power of the method.

Figure 5 shows some examples from the dataset, the result of our AND method, and 6 other methods using the imple-
mentation in the sklearn package. It can be observed that our method can produce meaningful component images, and the
non-negative matrix factorization implementation from sklearn produces component images of similar quality. The results
of these two methods are generally better than those by the other methods.

Provable Alternating Gradient Descent for Non-negative Matrix Factorization with Strong Correlations

(a) Example images in the dataset

(b) Our AND algorithm

(c) K-means

(d) Principal Component Analysis

(e) Independent Component Analysis

(f) Dictionary learning

(g) Non-negative matrix factorization (sklearn)

(h) Sparse Principal Component Analysis

Figure 5. The results of different methods computing 6 components on the Olivetti faces dataset. For all the competitors, we used the
implementations in the sklearn package.

