Large-Scale Evolution of Image Classiﬁers

Esteban Real 1 Sherry Moore 1 Andrew Selle 1 Saurabh Saxena 1
Yutaka Leon Suematsu 2 Jie Tan 1 Quoc V. Le 1 Alexey Kurakin 1

Abstract
Neural networks have proven effective at solv-
ing difﬁcult problems but designing their archi-
tectures can be challenging, even for image clas-
siﬁcation problems alone. Our goal is to min-
imize human participation, so we employ evo-
lutionary algorithms to discover such networks
automatically. Despite signiﬁcant computational
requirements, we show that it is now possible to
evolve models with accuracies within the range
of those published in the last year.
Speciﬁ-
cally, we employ simple evolutionary techniques
at unprecedented scales to discover models for
the CIFAR-10 and CIFAR-100 datasets, start-
ing from trivial initial conditions and reaching
accuracies of 94.6% (95.6% for ensemble) and
77.0%, respectively. To do this, we use novel and
intuitive mutation operators that navigate large
search spaces; we stress that no human participa-
tion is required once evolution starts and that the
output is a fully-trained model. Throughout this
work, we place special emphasis on the repeata-
bility of results, the variability in the outcomes
and the computational requirements.

1. Introduction

Neural networks can successfully perform difﬁcult tasks
where large amounts of training data are available (He
et al., 2015; Weyand et al., 2016; Silver et al., 2016; Wu
et al., 2016). Discovering neural network architectures,
however, remains a laborious task. Even within the spe-
ciﬁc problem of image classiﬁcation, the state of the art
was attained through many years of focused investigation
by hundreds of researchers (Krizhevsky et al. (2012); Si-
monyan & Zisserman (2014); Szegedy et al. (2015); He
et al. (2016); Huang et al. (2016a), among many others).

1Google Brain, Mountain View, California, USA 2Google Re-
search, Mountain View, California, USA. Correspondence to: Es-
teban Real <ereal@google.com>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

It is therefore not surprising that in recent years, tech-
niques to automatically discover these architectures have
been gaining popularity (Bergstra & Bengio, 2012; Snoek
et al., 2012; Han et al., 2015; Baker et al., 2016; Zoph
& Le, 2016). One of the earliest such “neuro-discovery”
methods was neuro-evolution (Miller et al., 1989; Stanley
& Miikkulainen, 2002; Stanley, 2007; Bayer et al., 2009;
Stanley et al., 2009; Breuel & Shafait, 2010; Pugh & Stan-
ley, 2013; Kim & Rigazio, 2015; Zaremba, 2015; Fernando
et al., 2016; Morse & Stanley, 2016). Despite the promising
results, the deep learning community generally perceives
evolutionary algorithms to be incapable of matching the
accuracies of hand-designed models (Verbancsics & Har-
guess, 2013; Baker et al., 2016; Zoph & Le, 2016). In this
paper, we show that it is possible to evolve such competi-
tive models today, given enough computational power.

We used slightly-modiﬁed known evolutionary algorithms
and scaled up the computation to unprecedented levels, as
far as we know. This, together with a set of novel and
intuitive mutation operators, allowed us to reach compet-
itive accuracies on the CIFAR-10 dataset. This dataset
was chosen because it requires large networks to reach
high accuracies, thus presenting a computational challenge.
We also took a small ﬁrst step toward generalization and
evolved networks on the CIFAR-100 dataset.
In transi-
tioning from CIFAR-10 to CIFAR-100, we did not mod-
ify any aspect or parameter of our algorithm. Our typical
neuro-evolution outcome on CIFAR-10 had a test accuracy
with µ = 94.1%, σ = 0.4% @ 9 × 1019 FLOPs, and our
top model (by validation accuracy) had a test accuracy of
94.6% @ 4×1020 FLOPs. Ensembling the validation-top
2 models from each population reaches a test accuracy of
95.6%, at no additional training cost. On CIFAR-100, our
single experiment resulted in a test accuracy of 77.0% @
2 × 1020 FLOPs. As far as we know, these are the most
accurate results obtained on these datasets by automated
discovery methods that start from trivial initial conditions.

Throughout this study, we placed special emphasis on the
simplicity of the algorithm.
In particular, it is a “one-
shot” technique, producing a fully trained neural network
It also has few impactful
requiring no post-processing.
meta-parameters (i.e. parameters not optimized by the al-
gorithm). Starting out with poor-performing models with

Large-Scale Evolution

Table 1. Comparison with single-model hand-designed architectures. The “C10+” and “C100+” columns indicate the test accuracy on
the data-augmented CIFAR-10 and CIFAR-100 datasets, respectively. The “Reachable?” column denotes whether the given hand-
designed model lies within our search space. An entry of “–” indicates that no value was reported. The † indicates a result reported by
Huang et al. (2016b) instead of the original author. Much of this table was based on that presented in Huang et al. (2016a).

STUDY

PARAMS.

C10+

C100+

REACHABLE?

MAXOUT (GOODFELLOW ET AL., 2013)
NETWORK IN NETWORK (LIN ET AL., 2013)
ALL-CNN (SPRINGENBERG ET AL., 2014)
DEEPLY SUPERVISED (LEE ET AL., 2015)
HIGHWAY (SRIVASTAVA ET AL., 2015)
RESNET (HE ET AL., 2016)

EVOLUTION (OURS)

WIDE RESNET 28-10 (ZAGORUYKO & KOMODAKIS, 2016)
WIDE RESNET 40-10+D/O (ZAGORUYKO & KOMODAKIS, 2016)
DENSENET (HUANG ET AL., 2016A)

–

–
–

61.4%
90.7%
–
91.2%
66.3%
1.3 M 92.8%
65.4%
92.0%
2.3 M 92.3%
67.6%
1.7 M 93.4% 72.8%†
5.4 M
94.6%
40.4 M
36.5 M 96.0%
50.7 M 96.2%
25.6 M 96.7%

77.0%
80.0%
81.7%
82.8%

NO
NO
YES
NO
NO
YES

N/A

YES
NO
NO

no convolutions, the algorithm must evolve complex con-
volutional neural networks while navigating a fairly unre-
stricted search space: no ﬁxed depth, arbitrary skip con-
nections, and numerical parameters that have few restric-
tions on the values they can take. We also paid close atten-
tion to result reporting. Namely, we present the variabil-
ity in our results in addition to the top value, we account
for researcher degrees of freedom (Simmons et al., 2011),
we study the dependence on the meta-parameters, and we
disclose the amount of computation necessary to reach the
main results. We are hopeful that our explicit discussion of
computation cost could spark more study of efﬁcient model
search and training. Studying model performance normal-
ized by computational investment allows consideration of
economic concepts like opportunity cost.

2. Related Work

Neuro-evolution dates back many years (Miller et al.,
1989), originally being used only to evolve the weights
of a ﬁxed architecture. Stanley & Miikkulainen (2002)
showed that it was advantageous to simultaneously evolve
the architecture using the NEAT algorithm. NEAT has
three kinds of mutations: (i) modify a weight, (ii) add a
connection between existing nodes, or (iii) insert a node
while splitting an existing connection. It also has a mech-
anism for recombining two models into one and a strategy
to promote diversity known as ﬁtness sharing (Goldberg
et al., 1987). Evolutionary algorithms represent the models
using an encoding that is convenient for their purpose—
analogous to nature’s DNA. NEAT uses a direct encoding:
every node and every connection is stored in the DNA. The
alternative paradigm, indirect encoding, has been the sub-
ject of much neuro-evolution research (Gruau, 1993; Stan-
ley et al., 2009; Pugh & Stanley, 2013; Kim & Rigazio,

2015; Fernando et al., 2016). For example, the CPPN
(Stanley, 2007; Stanley et al., 2009) allows for the evolu-
tion of repeating features at different scales. Also, Kim
& Rigazio (2015) use an indirect encoding to improve the
convolution ﬁlters in an initially highly-optimized ﬁxed ar-
chitecture.

Research on weight evolution is still ongoing (Morse &
Stanley, 2016) but the broader machine learning commu-
nity defaults to back-propagation for optimizing neural net-
work weights (Rumelhart et al., 1988). Back-propagation
and evolution can be combined as in Stanley et al. (2009),
where only the structure is evolved. Their algorithm fol-
lows an alternation of architectural mutations and weight
back-propagation. Similarly, Breuel & Shafait (2010) use
this approach for hyper-parameter search. Fernando et al.
(2016) also use back-propagation, allowing the trained
weights to be inherited through the structural modiﬁca-
tions.

The above studies create neural networks that are small in
comparison to the typical modern architectures used for im-
age classiﬁcation (He et al., 2016; Huang et al., 2016a).
Their focus is on the encoding or the efﬁciency of the evo-
lutionary process, but not on the scale. When it comes to
images, some neuro-evolution results reach the computa-
tional scale required to succeed on the MNIST dataset (Le-
Cun et al., 1998). Yet, modern classiﬁers are often tested
on realistic images, such as those in the CIFAR datasets
(Krizhevsky & Hinton, 2009), which are much more chal-
lenging. These datasets require large models to achieve
high accuracy.

Non-evolutionary neuro-discovery methods have been
more successful at tackling realistic image data. Snoek
et al.
(2012) used Bayesian optimization to tune 9
hyper-parameters for a ﬁxed-depth architecture, reach-

3 LAYERS

–

BAYESIAN
(SNOEK
ET AL., 2012)

Q-LEARNING
(BAKER
ET AL., 2016)

RL (ZOPH &
LE, 2016)

RL (ZOPH &
LE, 2016)

Large-Scale Evolution

Table 2. Comparison with automatically discovered architectures. The “C10+” and “C100+” contain the test accuracy on the data-
augmented CIFAR-10 and CIFAR-100 datasets, respectively. An entry of “–” indicates that the information was not reported or is not
known to us. For Zoph & Le (2016), we quote the result with the most similar search space to ours, as well as their best result. Please
refer to Table 1 for hand-designed results, including the state of the art. “Discrete params.” means that the parameters can be picked
from a handful of values only (e.g. strides ∈ {1, 2, 4}).

STUDY

STARTING POINT

CONSTRAINTS

POST-PROCESSING

PARAMS.

C10+

C100+

FIXED ARCHITECTURE, NO
SKIPS

NONE

–

90.5%

–

DISCRETE PARAMS., MAX.
NUM. LAYERS, NO SKIPS

TUNE, RETRAIN

11.2 M 93.1%

72.9%

20 LAYERS, 50%
SKIPS

DISCRETE PARAMS.,
EXACTLY 20 LAYERS

SMALL GRID
SEARCH, RETRAIN

39 LAYERS, 2 POOL
LAYERS AT 13 AND
26, 50% SKIPS

DISCRETE PARAMS.,
EXACTLY 39 LAYERS, 2
POOL LAYERS AT 13 AND 26

ADD MORE FILTERS,
SMALL GRID
SEARCH, RETRAIN

EVOLUTION
(OURS)

SINGLE LAYER,
ZERO CONVS.

POWER-OF-2 STRIDES

NONE

2.5 M 94.0%

37.0 M 96.4%

–

–

5.4 M
40.4 M
ENSEMB.

94.6%

95.6%

77.0%

ing a new state of
the art at
the time.
Zoph &
Le (2016) used reinforcement
learning on a deeper
In their approach, a neu-
ﬁxed-length architecture.
ral network—the “discoverer”—constructs a convolutional
neural network—the “discovered”—one layer at a time. In
addition to tuning layer parameters, they add and remove
skip connections. This, together with some manual post-
processing, gets them very close to the (current) state of
the art. (Additionally, they surpassed the state of the art on
a sequence-to-sequence problem.) Baker et al. (2016) use
Q-learning to also discover a network one layer at a time,
but in their approach, the number of layers is decided by
the discoverer. This is a desirable feature, as it would allow
a system to construct shallow or deep solutions, as may be
the requirements of the dataset at hand. Different datasets
would not require specially tuning the algorithm. Compar-
isons among these methods are difﬁcult because they ex-
plore very different search spaces and have very different
initial conditions (Table 2).

Tangentially, there has also been neuro-evolution work on
LSTM structure (Bayer et al., 2009; Zaremba, 2015), but
this is beyond the scope of this paper. Also related to this
work is that of Saxena & Verbeek (2016), who embed con-
volutions with different parameters into a species of “super-
network” with many parallel paths. Their algorithm then
selects and ensembles paths in the super-network. Finally,
canonical approaches to hyper-parameter search are grid
search (used in Zagoruyko & Komodakis (2016), for ex-
ample) and random search, the latter being the better of the

two (Bergstra & Bengio, 2012).

Our approach builds on previous work, with some im-
portant differences. We explore large model-architecture
search spaces starting with basic initial conditions to avoid
priming the system with information about known good
strategies for the speciﬁc dataset at hand. Our encoding
is different from the neuro-evolution methods mentioned
above: we use a simpliﬁed graph as our DNA, which is
transformed to a full neural network graph for training and
evaluation (Section 3). Some of the mutations acting on
this DNA are reminiscent of NEAT. However, instead of
single nodes, one mutation can insert whole layers—i.e.
tens to hundreds of nodes at a time. We also allow for
these layers to be removed, so that the evolutionary process
can simplify an architecture in addition to complexifying it.
Layer parameters are also mutable, but we do not prescribe
a small set of possible values to choose from, to allow for
a larger search space. We do not use ﬁtness sharing. We
report additional results using recombination, but for the
most part, we used mutation only. On the other hand, we
do use back-propagation to optimize the weights, which
can be inherited across mutations. Together with a learn-
ing rate mutation, this allows the exploration of the space
of learning rate schedules, yielding fully trained models
at the end of the evolutionary process (Section 3). Ta-
bles 1 and 2 compare our approach with hand-designed ar-
chitectures and with other neuro-discovery techniques, re-
spectively.

Large-Scale Evolution

3. Methods

3.1. Evolutionary Algorithm

To automatically search for high-performing neural net-
work architectures, we evolve a population of models.
Each model—or individual—is a trained architecture. The
model’s accuracy on a separate validation dataset is a mea-
sure of the individual’s quality or ﬁtness. During each evo-
lutionary step, a computer—a worker—chooses two indi-
viduals at random from this population and compares their
ﬁtnesses. The worst of the pair is immediately removed
from the population—it is killed. The best of the pair is
selected to be a parent, that is, to undergo reproduction.
By this we mean that the worker creates a copy of the par-
ent and modiﬁes this copy by applying a mutation, as de-
scribed below. We will refer to this modiﬁed copy as the
child. After the worker creates the child, it trains this child,
evaluates it on the validation set, and puts it back into the
population. The child then becomes alive—i.e. free to act
as a parent. Our scheme, therefore, uses repeated pairwise
competitions of random individuals, which makes it an ex-
ample of tournament selection (Goldberg & Deb, 1991).
Using pairwise comparisons instead of whole population
operations prevents workers from idling when they ﬁnish
early. Code and more detail about the methods described
below can be found in Supplementary Section S1.

Using this strategy to search large spaces of complex im-
age models requires considerable computation. To achieve
scale, we developed a massively-parallel, lock-free infras-
tructure. Many workers operate asynchronously on differ-
ent computers. They do not communicate directly with
each other. Instead, they use a shared ﬁle-system, where
the population is stored. The ﬁle-system contains direc-
tories that represent the individuals. Operations on these
individuals, such as the killing of one, are represented as
atomic renames on the directory2. Occasionally, a worker
may concurrently modify the individual another worker is
operating on. In this case, the affected worker simply gives
up and tries again. The population size is 1000 individuals,
unless otherwise stated. The number of workers is always
1
4 of the population size. To allow for long run-times with
a limited amount of space, dead individuals’ directories are
frequently garbage-collected.

3.2. Encoding and Mutations

Individual architectures are encoded as a graph that we
refer to as the DNA. In this graph, the vertices represent
rank-3 tensors or activations. As is standard for a convo-

2The use of the ﬁle-name string to contain key information
about the individual was inspired by Breuel & Shafait (2010), and
it speeds up disk access enormously. In our case, the ﬁle name
contains the state of the individual (alive, dead, training, etc.).

lutional network, two of the dimensions of the tensor rep-
resent the spatial coordinates of the image and the third is
a number of channels. Activation functions are applied at
the vertices and can be either (i) batch-normalization (Ioffe
& Szegedy, 2015) with rectiﬁed linear units (ReLUs) or (ii)
plain linear units. The graph’s edges represent identity con-
nections or convolutions and contain the mutable numeri-
cal parameters deﬁning the convolution’s properties. When
multiple edges are incident on a vertex, their spatial scales
or numbers of channels may not coincide. However, the
vertex must have a single size and number of channels for
its activations. The inconsistent inputs must be resolved.
Resolution is done by choosing one of the incoming edges
as the primary one. We pick this primary edge to be the
one that is not a skip connection. The activations coming
from the non-primary edges are reshaped through zeroth-
order interpolation in the case of the size and through trun-
cation/padding in the case of the number of channels, as in
He et al. (2016). In addition to the graph, the learning-rate
value is also stored in the DNA.

A child is similar but not identical to the parent because of
the action of a mutation. In each reproduction event, the
worker picks a mutation at random from a predetermined
set. The set contains the following mutations:

• ALTER-LEARNING-RATE (sampling details below).
• IDENTITY (effectively means “keep training”).
• RESET-WEIGHTS (sampled as in He et al. (2015), for

example).

• INSERT-CONVOLUTION (inserts a convolution at a ran-
dom location in the “convolutional backbone”, as in Fig-
ure 1. The inserted convolution has 3 × 3 ﬁlters, strides
of 1 or 2 at random, number of channels same as input.
May apply batch-normalization and ReLU activation or
none at random).

• REMOVE-CONVOLUTION.
• ALTER-STRIDE (only powers of 2 are allowed).
• ALTER-NUMBER-OF-CHANNELS (of random conv.).
• FILTER-SIZE (horizontal or vertical at random, on ran-

dom convolution, odd values only).

• INSERT-ONE-TO-ONE (inserts a one-to-one/identity
connection, analogous to insert-convolution mutation).

• ADD-SKIP (identity between random layers).
• REMOVE-SKIP (removes random skip).

These speciﬁc mutations were chosen for their similarity
to the actions that a human designer may take when im-
proving an architecture. This may clear the way for hybrid
evolutionary–hand-design methods in the future. The prob-
abilities for the mutations were not tuned in any way.

A mutation that acts on a numerical parameter chooses the
new value at random around the existing value. All sam-
pling is from uniform distributions. For example, a muta-
tion acting on a convolution with 10 output channels will

Large-Scale Evolution

3.5. Computation cost

result in a convolution having between 5 and 20 output
channels (that is, half to twice the original value). All val-
ues within the range are possible. As a result, the models
are not constrained to a number of ﬁlters that is known to
work well. The same is true for all other parameters, yield-
ing a “dense” search space. In the case of the strides, this
applies to the log-base-2 of the value, to allow for activa-
tion shapes to match more easily3. In principle, there is also
no upper limit to any of the parameters. All model depths
are attainable, for example. Up to hardware constraints, the
search space is unbounded. The dense and unbounded na-
ture of the parameters result in the exploration of a truly
large set of possible architectures.

3.3. Initial Conditions

Every evolution experiment begins with a population of
simple individuals, all with a learning rate of 0.1. They
are all very bad performers. Each initial individual consti-
tutes just a single-layer model with no convolutions. This
conscious choice of poor initial conditions forces evolution
to make the discoveries by itself. The experimenter con-
tributes mostly through the choice of mutations that demar-
cate a search space. Altogether, the use of poor initial con-
ditions and a large search space limits the experimenter’s
impact. In other words, it prevents the experimenter from
“rigging” the experiment to succeed.

To estimate computation costs, we identiﬁed the basic
TensorFlow (TF) operations used by our model training
and validation, like convolutions, generic matrix multipli-
cations, etc. For each of these TF operations, we esti-
mated the theoretical number of ﬂoating-point operations
(FLOPs) required. This resulted in a map from TF opera-
tion to FLOPs, which is valid for all our experiments.

For each individual within an evolution experiment, we
compute the total FLOPs incurred by the TF operations in
its architecture over one batch of examples, both during its
training (Ft FLOPs) and during its validation (Fv FLOPs).
Then we assign to the individual the cost FtNt + FvNv,
where Nt and Nv are the number of training and validation
batches, respectively. The cost of the experiment is then
the sum of the costs of all its individuals.

We intend our FLOPs measurement as a coarse estimate
only. We do not take into account input/output, data prepro-
cessing, TF graph building or memory-copying operations.
Some of these unaccounted operations take place once per
training run or once per step and some have a component
that is constant in the model size (such as disk-access la-
tency or input data cropping). We therefore expect the esti-
mate to be more useful for large architectures (for example,
those with many convolutions).

3.4. Training and Validation

3.6. Weight Inheritance

Training and validation is done on the CIFAR-10 dataset.
This dataset consists of 50,000 training examples and
10,000 test examples, all of which are 32 x 32 color images
labeled with 1 of 10 common object classes (Krizhevsky &
Hinton, 2009). 5,000 of the training examples are held out
in a validation set. The remaining 45,000 examples consti-
tute our actual training set. The training set is augmented
as in He et al. (2016). The CIFAR-100 dataset has the same
number of dimensions, colors and examples as CIFAR-10,
but uses 100 classes, making it much more challenging.

Training is done with TensorFlow (Abadi et al., 2016), us-
ing SGD with a momentum of 0.9 (Sutskever et al., 2013), a
batch size of 50, and a weight decay of 0.0001. Each train-
ing runs for 25,600 steps, a value chosen to be brief enough
so that each individual could be trained in a few seconds to
a few hours, depending on model size. The loss function is
the cross-entropy. Once training is complete, a single eval-
uation on the validation set provides the accuracy to use as
the individual’s ﬁtness. Ensembling was done by majority
voting during the testing evaluation. The models used in
the ensemble were selected by validation accuracy.

3For integer DNA parameters, we actually store and mutate a
ﬂoating-point value. This allows multiple small mutations to have
a cumulative effect in spite of integer round-off.

We need architectures that are trained to completion within
an evolution experiment. If this does not happen, we are
forced to retrain the best model at the end, possibly hav-
ing to explore its hyper-parameters. Such extra explo-
ration tends to depend on the details of the model being
retrained. On the other hand, 25,600 steps are not enough
to fully train each individual. Training a large model to
completion is prohibitively slow for evolution. To resolve
this dilemma, we allow the children to inherit the par-
ents’ weights whenever possible. Namely, if a layer has
matching shapes, the weights are preserved. Consequently,
some mutations preserve all the weights (like the identity or
learning-rate mutations), some preserve none (the weight-
resetting mutation), and most preserve some but not all. An
example of the latter is the ﬁlter-size mutation: only the ﬁl-
ters of the convolution being mutated will be discarded.

3.7. Reporting Methodology

To avoid over-ﬁtting, neither the evolutionary algorithm nor
the neural network training ever see the testing set. Each
time we refer to “the best model”, we mean the model with
the highest validation accuracy. However, we always report
the test accuracy. This applies not only to the choice of the
best individual within an experiment, but also to the choice

Large-Scale Evolution

of the best experiment. Moreover, we only include ex-
periments that we managed to reproduce, unless explicitly
noted. Any statistical analysis was fully decided upon be-
fore seeing the results of the experiment reported, to avoid
tailoring our analysis to our experimental data (Simmons
et al., 2011).

4. Experiments and Results

We want to answer the following questions:

• Can a simple one-shot evolutionary process start from
trivial initial conditions and yield fully trained models
that rival hand-designed architectures?

• What are the variability in outcomes, the parallelizabil-

ity, and the computation cost of the method?

• Can an algorithm designed iterating on CIFAR-10 be ap-
plied, without any changes at all, to CIFAR-100 and still
produce competitive models?

We used the algorithm in Section 3 to perform several ex-
periments. Each experiment evolves a population in a few
days, typiﬁed by the example in Figure 1. The ﬁgure also
contains examples of the architectures discovered, which
turn out to be surprisingly simple. Evolution attempts skip
connections but frequently rejects them.

To get a sense of the variability in outcomes, we repeated
the experiment 5 times. Across all 5 experiment runs, the
best model by validation accuracy has a testing accuracy of
94.6 %. Not all experiments reach the same accuracy, but
they get close (µ = 94.1%, σ = 0.4). Fine differences in the
experiment outcome may be somewhat distinguishable by
validation accuracy (correlation coefﬁcient = 0.894). The
total amount of computation across all 5 experiments was
4×1020 FLOPs (or 9×1019 FLOPs on average per exper-
iment). Each experiment was distributed over 250 parallel
workers (Section 3.1). Figure 2 shows the progress of the
experiments in detail.

As a control, we disabled the selection mechanism, thereby
reproducing and killing random individuals. This is the
form of random search that is most compatible with our
infrastructure. The probability distributions for the pa-
rameters are implicitly determined by the mutations. This
control only achieves an accuracy of 87.3 % in the same
amount of run time on the same hardware (Figure 2). The
total amount of computation was 2×1017 FLOPs. The low
FLOP count is a consequence of random search generating
many small, inadequate models that train quickly but con-
sume roughly constant amounts of setup time (not included
in the FLOP count). We attempted to minimize this over-
head by avoiding unnecessary disk access operations, to no
avail: too much overhead remains spent on a combination
of neural network setup, data augmentation, and training
step initialization.

We also ran a partial control where the weight-inheritance
mechanism is disabled. This run also results in a lower
accuracy (92.2 %) in the same amount of time (Figure 2),
using 9×1019 FLOPs. This shows that weight inheritance
is important in the process.

Finally, we applied our neuro-evolution algorithm, with-
out any changes and with the same meta-parameters, to
CIFAR-100. Our only experiment reached an accuracy
of 77.0 %, using 2 × 1020 FLOPs. We did not attempt
other datasets. Table 1 shows that both the CIFAR-10
and CIFAR-100 results are competitive with modern hand-
designed networks.

5. Analysis

Meta-parameters. We observe that populations evolve
until they plateau at some local optimum (Figure 2). The
ﬁtness (i.e. validation accuracy) value at this optimum
varies between experiments (Figure 2, inset). Since not all
experiments reach the highest possible value, some popu-
lations are getting “trapped” at inferior local optima. This
entrapment is affected by two important meta-parameters
(i.e. parameters that are not optimized by the algorithm).
These are the population size and the number of training
steps per individual. Below we discuss them and consider
their relationship to local optima.

Effect of population size. Larger populations explore the
space of models more thoroughly, and this helps reach bet-
ter optima (Figure 3, left). Note, in particular, that a pop-
ulation of size 2 can get trapped at very low ﬁtness values.
Some intuition about this can be gained by considering the
fate of a super-ﬁt individual, i.e. an individual such that any
one architectural mutation reduces its ﬁtness (even though
a sequence of many mutations may improve it). In the case
of a population of size 2, if the super-ﬁt individual wins
once, it will win every time. After the ﬁrst win, it will pro-
duce a child that is one mutation away. By deﬁnition of
super-ﬁt, therefore, this child is inferior4. Consequently,
in the next round of tournament selection, the super-ﬁt in-
dividual competes against its child and wins again. This
cycle repeats forever and the population is trapped. Even if
a sequence of two mutations would allow for an “escape”
from the local optimum, such a sequence can never take
place. This is only a rough argument to heuristically sug-
gest why a population of size 2 is easily trapped. More
generally, Figure 3 (left) empirically demonstrates a bene-
ﬁt from an increase in population size. Theoretical analy-
ses of this dependence are quite complex and assume very
speciﬁc models of population dynamics; often larger pop-
ulations are better at handling local optima, at least beyond
a size threshold (Weinreich & Chao (2005) and references

4Except after identity or learning rate mutations, but these pro-

duce a child with the same architecture as the parent.

Large-Scale Evolution

Figure 1. Progress of an evolution experiment. Each dot represents an individual in the population. Blue dots (darker, top-right) are alive.
The rest have been killed. The four diagrams show examples of discovered architectures. These correspond to the best individual (right-
most) and three of its ancestors. The best individual was selected by its validation accuracy. Evolution sometimes stacks convolutions
without any nonlinearity in between (“C”, white background), which are mathematically equivalent to a single linear operation. Unlike
typical hand-designed architectures, some convolutions are followed by more than one nonlinear function (“C+BN +R+BN +R+...”,
orange background).

therein).
Effect of number of training steps. The other meta-
parameter is the number T of training steps for each indi-
vidual. Accuracy increases with T (Figure 3, right). Larger
T means an individual needs to undergo fewer identity mu-
tations to reach a given level of training.
Escaping local optima. While we might increase popu-
lation size or number of steps to prevent a trapped popu-
lation from forming, we can also free an already trapped
population. For example, increasing the mutation rate or
resetting all the weights of a population (Figure 4) work
well but are quite costly (more details in Supplementary
Section S3).
Recombination. None of the results presented so far
used recombination. However, we explored three forms of
recombination in additional experiments. Following Tuson
& Ross (1998), we attempted to evolve the mutation prob-
ability distribution too. On top of this, we employed a re-
combination strategy by which a child could inherit struc-
ture from one parent and mutation probabilities from an-
other. The goal was to allow individuals that progressed
well due to good mutation choices to quickly propagate

such choices to others.
In a separate experiment, we at-
tempted recombining the trained weights from two parents
in the hope that each parent may have learned different
concepts from the training data.
In a third experiment,
we recombined structures so that the child fused the ar-
chitectures of both parents side-by-side, generating wide
models fast. While none of these approaches improved our
recombination-free results, further study seems warranted.

6. Conclusion

In this paper we have shown that (i) neuro-evolution is ca-
pable of constructing large, accurate networks for two chal-
lenging and popular image classiﬁcation benchmarks; (ii)
neuro-evolution can do this starting from trivial initial con-
ditions while searching a very large space; (iii) the pro-
cess, once started, needs no experimenter participation; and
(iv) the process yields fully trained models. Completely
training models required weight inheritance (Sections 3.6).
In contrast to reinforcement learning, evolution provides a
natural framework for weight inheritance: mutations can
be constructed to guarantee a large degree of similarity be-

0.928.1256.270.222.685.394.691.8wall time (hours)test accuracy (%)InputInputOutputCC + BN + RGlobal PoolC + BN + RCC + BN + RC + BN + RBN + RC + BN + RCGlobal PoolOutputC + BN + R + BN + RC + BN + R + BN + R + BN + R + BN + RBN + RC + BN + RGlobal PoolOutputCCCInputC + BN + RC + BN + R + BN + RC + BN + R + BN + RC + BN + R + BN + R + BN + R + BN + RC + BN + RC + BN + RC + BN + RC + BN + RC + BN + RGlobal PoolOutputCCCCCInputLarge-Scale Evolution

Figure 3. Dependence on meta-parameters. In both graphs, each
circle represents the result of a full evolution experiment. Both
vertical axes show the test accuracy for the individual with the
highest validation accuracy at the end of the experiment. All pop-
ulations evolved for the same total wall-clock time. There are 5
data points at each horizontal axis value. LEFT: effect of pop-
ulation size. To economize resources, in these experiments the
number of individual training steps is only 2560. Note how the ac-
curacy increases with population size. RIGHT: effect of number
of training steps per individual. Note how the accuracy increases
with more steps.

Figure 4. Escaping local optima in two experiments. We used
smaller populations and fewer training steps per individual (2560)
to make it more likely for a population to get trapped and to re-
duce resource usage. Each dot represents an individual. The verti-
cal axis is the accuracy. TOP: example of a population of size 100
escaping a local optimum by using a period of increased mutation
rate in the middle (Section 5). BOTTOM: example of a population
of size 50 escaping a local optimum by means of three consecu-
tive weight resetting events (Section 5). Details in Supplementary
Section S3.

Figure 2. Repeatability of results and controls. In this plot, the
vertical axis at wall-time t is deﬁned as the test accuracy of the
individual with the highest validation accuracy that became alive
at or before t. The inset magniﬁes a portion of the main graph.
The curves show the progress of various experiments, as follows.
The top line (solid, blue) shows the mean test accuracy across 5
large-scale evolution experiments. The shaded area around this
top line has a width of ±2σ (clearer in inset). The next line down
(dashed, orange, main graph and inset) represents a single experi-
ment in which weight-inheritance was disabled, so every individ-
ual has to train from random weights. The lowest curve (dotted-
dashed) is a random-search control. All experiments occupied the
same amount and type of hardware. A small amount of noise in
the generalization from the validation to the test set explains why
the lines are not monotonically increasing. Note the narrow width
of the ±2σ area (main graph and inset), which shows that the high
accuracies obtained in evolution experiments are repeatable.

tween the original and mutated models—as we did. Evo-
lution also has fewer tunable meta-parameters with a fairly
predictable effect on the variance of the results, which can
be made small.

While we did not focus on reducing computation costs,
we hope that future algorithmic and hardware improvement
will allow more economical implementation. In that case,
evolution would become an appealing approach to neuro-
discovery for reasons beyond the scope of this paper. For
example, it “hits the ground running”, improving on arbi-
trary initial models as soon as the experiment begins. The
mutations used can implement recent advances in the ﬁeld
and can be introduced without having to restart an exper-
iment. Furthermore, recombination can merge improve-
ments developed by different individuals, even if they come
from other populations. Moreover, it may be possible to
combine neuro-evolution with other automatic architecture
discovery methods.

0250wall-clock time (hours)20.094.6100.0test accuracy (%)EvolutionEvolution w/oweight inheritanceRandom search1502509294100043102population size50100test accuracy (%)256256025600training steps75100test accuracy (%)Large-Scale Evolution

Acknowledgements

We wish to thank Vincent Vanhoucke, Megan Kacho-
lia, Rajat Monga, and especially Jeff Dean for their sup-
port and valuable input; Geoffrey Hinton, Samy Ben-
gio, Thomas Breuel, Mark DePristo, Vishy Tirumalashetty,
Martin Abadi, Noam Shazeer, Yoram Singer, Dumitru Er-
han, Pierre Sermanet, Xiaoqiang Zheng, Shan Carter and
Vijay Vasudevan for helpful discussions; Thomas Breuel,
Xin Pan and Andy Davis for coding contributions; and the
larger Google Brain team for help with TensorFlow and
training vision models.

References

Abadi, Mart´ın, Agarwal, Ashish, Barham, Paul, Brevdo,
Eugene, Chen, Zhifeng, Citro, Craig, Corrado, Greg S,
Davis, Andy, Dean, Jeffrey, Devin, Matthieu, et al. Ten-
sorﬂow: Large-scale machine learning on heterogeneous
distributed systems. arXiv preprint arXiv:1603.04467,
2016.

Baker, Bowen, Gupta, Otkrist, Naik, Nikhil,

and
Raskar, Ramesh. Designing neural network archi-
tectures using reinforcement learning. arXiv preprint
arXiv:1611.02167, 2016.

Bayer, Justin, Wierstra, Daan, Togelius, Julian, and
Schmidhuber, J¨urgen. Evolving memory cell structures
In International Conference on
for sequence learning.
Artiﬁcial Neural Networks, pp. 755–764. Springer, 2009.

Bergstra, James and Bengio, Yoshua. Random search
for hyper-parameter optimization. Journal of Machine
Learning Research, 13(Feb):281–305, 2012.

Goodfellow, Ian J, Warde-Farley, David, Mirza, Mehdi,
Courville, Aaron C, and Bengio, Yoshua. Maxout net-
works. International Conference on Machine Learning,
28:1319–1327, 2013.

Gruau, Frederic. Genetic synthesis of modular neural net-
works. In Proceedings of the 5th International Confer-
ence on Genetic Algorithms, pp. 318–325. Morgan Kauf-
mann Publishers Inc., 1993.

Han, Song, Pool, Jeff, Tran, John, and Dally, William.
Learning both weights and connections for efﬁcient neu-
ral network. In Advances in Neural Information Process-
ing Systems, pp. 1135–1143, 2015.

He, Kaiming, Zhang, Xiangyu, Ren, Shaoqing, and Sun,
Jian. Delving deep into rectiﬁers: Surpassing human-
In Pro-
level performance on imagenet classiﬁcation.
ceedings of the IEEE international conference on com-
puter vision, pp. 1026–1034, 2015.

He, Kaiming, Zhang, Xiangyu, Ren, Shaoqing, and Sun,
Jian. Deep residual learning for image recognition. In
Proceedings of the IEEE Conference on Computer Vi-
sion and Pattern Recognition, pp. 770–778, 2016.

Huang, Gao, Liu, Zhuang, Weinberger, Kilian Q, and
van der Maaten, Laurens. Densely connected convo-
arXiv preprint arXiv:1608.06993,
lutional networks.
2016a.

Huang, Gao, Sun, Yu, Liu, Zhuang, Sedra, Daniel, and
Weinberger, Kilian Q. Deep networks with stochastic
depth. In European Conference on Computer Vision, pp.
646–661. Springer, 2016b.

Breuel, Thomas and Shafait, Faisal. Automlp: Simple,
effective, fully automated learning rate and size adjust-
ment. In The Learning Workshop. Utah, 2010.

Ioffe, Sergey and Szegedy, Christian. Batch normalization:
Accelerating deep network training by reducing internal
covariate shift. arXiv preprint arXiv:1502.03167, 2015.

Fernando, Chrisantha, Banarse, Dylan, Reynolds, Mal-
colm, Besse, Frederic, Pfau, David, Jaderberg, Max,
Lanctot, Marc, and Wierstra, Daan. Convolution by evo-
lution: Differentiable pattern producing networks.
In
Proceedings of the 2016 on Genetic and Evolutionary
Computation Conference, pp. 109–116. ACM, 2016.

Goldberg, David E and Deb, Kalyanmoy. A comparative
analysis of selection schemes used in genetic algorithms.
Foundations of genetic algorithms, 1:69–93, 1991.

Goldberg, David E, Richardson, Jon, et al. Genetic algo-
rithms with sharing for multimodal function optimiza-
tion. In Genetic algorithms and their applications: Pro-
ceedings of the Second International Conference on Ge-
netic Algorithms, pp. 41–49. Hillsdale, NJ: Lawrence
Erlbaum, 1987.

Kim, Minyoung and Rigazio, Luca. Deep clustered convo-
lutional kernels. arXiv preprint arXiv:1503.01824, 2015.

Krizhevsky, Alex and Hinton, Geoffrey. Learning multiple

layers of features from tiny images. 2009.

Krizhevsky, Alex, Sutskever, Ilya, and Hinton, Geoffrey E.
Imagenet classiﬁcation with deep convolutional neural
networks. In Advances in Neural Information Processing
Systems, pp. 1097–1105, 2012.

LeCun, Yann, Cortes, Corinna, and Burges, Christo-
pher JC. The mnist database of handwritten digits, 1998.

Lee, Chen-Yu, Xie, Saining, Gallagher, Patrick W, Zhang,
Zhengyou, and Tu, Zhuowen. Deeply-supervised nets.
In AISTATS, volume 2, pp. 5, 2015.

Large-Scale Evolution

Lin, Min, Chen, Qiang, and Yan, Shuicheng. Network in

network. arXiv preprint arXiv:1312.4400, 2013.

Miller, Geoffrey F, Todd, Peter M, and Hegde, Shailesh U.
Designing neural networks using genetic algorithms. In
Proceedings of the third international conference on Ge-
netic algorithms, pp. 379–384. Morgan Kaufmann Pub-
lishers Inc., 1989.

Morse, Gregory and Stanley, Kenneth O. Simple evo-
lutionary optimization can rival stochastic gradient de-
scent in neural networks. In Proceedings of the 2016 on
Genetic and Evolutionary Computation Conference, pp.
477–484. ACM, 2016.

Pugh, Justin K and Stanley, Kenneth O. Evolving mul-
In Proceedings of
timodal controllers with hyperneat.
the 15th annual conference on Genetic and evolutionary
computation, pp. 735–742. ACM, 2013.

Rumelhart, David E, Hinton, Geoffrey E, and Williams,
Ronald J. Learning representations by back-propagating
errors. Cognitive Modeling, 5(3):1, 1988.

Saxena, Shreyas and Verbeek, Jakob. Convolutional neural
fabrics. In Advances In Neural Information Processing
Systems, pp. 4053–4061, 2016.

Silver, David, Huang, Aja, Maddison, Chris J, Guez,
Arthur, Sifre, Laurent, Van Den Driessche, George,
Schrittwieser, Julian, Antonoglou, Ioannis, Panneershel-
vam, Veda, Lanctot, Marc, et al. Mastering the game of
go with deep neural networks and tree search. Nature,
529(7587):484–489, 2016.

Simmons, Joseph P, Nelson, Leif D, and Simonsohn, Uri.
False-positive psychology: Undisclosed ﬂexibility in
data collection and analysis allows presenting anything
Psychological Science, 22(11):1359–
as signiﬁcant.
1366, 2011.

Simonyan, Karen and Zisserman, Andrew. Very deep con-
volutional networks for large-scale image recognition.
arXiv preprint arXiv:1409.1556, 2014.

Snoek, Jasper, Larochelle, Hugo, and Adams, Ryan P.
Practical bayesian optimization of machine learning al-
gorithms. In Advances in neural information processing
systems, pp. 2951–2959, 2012.

Springenberg, Jost Tobias, Dosovitskiy, Alexey, Brox,
Striving for sim-
arXiv preprint

Thomas, and Riedmiller, Martin.
plicity: The all convolutional net.
arXiv:1412.6806, 2014.

Srivastava, Rupesh Kumar, Greff, Klaus, and Schmid-
arXiv preprint

huber, J¨urgen. Highway networks.
arXiv:1505.00387, 2015.

Stanley, Kenneth O. Compositional pattern producing net-
works: A novel abstraction of development. Genetic pro-
gramming and evolvable machines, 8(2):131–162, 2007.

Stanley, Kenneth O and Miikkulainen, Risto. Evolving
neural networks through augmenting topologies. Evo-
lutionary Computation, 10(2):99–127, 2002.

Stanley, Kenneth O, D’Ambrosio, David B, and Gauci, Ja-
son. A hypercube-based encoding for evolving large-
scale neural networks. Artiﬁcial Life, 15(2):185–212,
2009.

Sutskever, Ilya, Martens, James, Dahl, George E, and Hin-
ton, Geoffrey E. On the importance of initialization and
momentum in deep learning. ICML (3), 28:1139–1147,
2013.

Szegedy, Christian, Liu, Wei, Jia, Yangqing, Sermanet,
Pierre, Reed, Scott, Anguelov, Dragomir, Erhan, Du-
mitru, Vanhoucke, Vincent, and Rabinovich, Andrew.
In Proceedings of
Going deeper with convolutions.
the IEEE Conference on Computer Vision and Pattern
Recognition, pp. 1–9, 2015.

Tuson, Andrew and Ross, Peter. Adapting operator settings
in genetic algorithms. Evolutionary computation, 6(2):
161–184, 1998.

Verbancsics, Phillip and Harguess, Josh.

neuroevolution for deep learning.
arXiv:1312.5355, 2013.

Generative
arXiv preprint

Weinreich, Daniel M and Chao, Lin. Rapid evolutionary
escape by large populations from local ﬁtness peaks is
likely in nature. Evolution, 59(6):1175–1182, 2005.

Weyand, Tobias, Kostrikov, Ilya, and Philbin, James.
Planet-photo geolocation with convolutional neural net-
works. In European Conference on Computer Vision, pp.
37–55. Springer, 2016.

Wu, Yonghui, Schuster, Mike, Chen, Zhifeng, Le, Quoc V.,
Norouzi, Mohammad, et al. Google’s neural machine
translation system: Bridging the gap between human and
machine translation. arXiv preprint arXiv:1609.08144,
2016.

Zagoruyko, Sergey and Komodakis, Nikos. Wide residual

networks. arXiv preprint arXiv:1605.07146, 2016.

Zaremba, Wojciech. An empirical exploration of recurrent

network architectures. 2015.

Zoph, Barret and Le, Quoc V.

search with reinforcement learning.
arXiv:1611.01578, 2016.

Neural architecture
arXiv preprint

