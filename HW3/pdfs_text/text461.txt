Zero-Shot Task Generalization with Multi-Task Deep Reinforcement Learning

Junhyuk Oh 1 Satinder Singh 1 Honglak Lee 1 2 Pushmeet Kohli 3

Abstract
As a step towards developing zero-shot task gen-
eralization capabilities in reinforcement learning
(RL), we introduce a new RL problem where the
agent should learn to execute sequences of in-
structions after learning useful skills that solve
subtasks. In this problem, we consider two types
of generalizations: to previously unseen instruc-
tions and to longer sequences of instructions. For
generalization over unseen instructions, we pro-
pose a new objective which encourages learn-
ing correspondences between similar subtasks by
making analogies. For generalization over se-
quential instructions, we present a hierarchical
architecture where a meta controller learns to use
the acquired skills for executing the instructions.
To deal with delayed reward, we propose a new
neural architecture in the meta controller that
learns when to update the subtask, which makes
learning more efﬁcient. Experimental results on
a stochastic 3D domain show that the proposed
ideas are crucial for generalization to longer in-
structions as well as unseen instructions.

1. Introduction
The ability to understand and follow instructions allows
us to perform a large number of new complex sequen-
tial tasks even without additional learning. For example,
we can make a new dish following a recipe, and explore
a new city following a guidebook. Developing the abil-
ity to execute instructions can potentially allow reinforce-
ment learning (RL) agents to generalize quickly over tasks
for which such instructions are available. For example,
factory-trained household robots could execute novel tasks
in a new house following a human user’s instructions (e.g.,
tasks involving household chores, going to a new place,
picking up/manipulating new objects, etc.). In addition to
generalization over instructions, an intelligent agent should
also be able to handle unexpected events (e.g., low bat-

1University of Michigan 2Google Brain 3Microsoft Research.

Correspondence to: Junhyuk Oh <junhyuk@umich.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

Figure 1: Example of 3D world and instructions. The agent is
tasked to execute longer sequences of instructions in the correct
order after training on short sequences of instructions; in addi-
tion, previously unseen instructions can be given during evalu-
ation (blue text). Additional reward is available from randomly
appearing boxes regardless of instructions (green circle).

tery, arrivals of reward sources) while executing instruc-
tions. Thus, the agent should not blindly execute instruc-
tions sequentially but sometimes deviate from instructions
depending on circumstances, which requires balancing be-
tween two different objectives.

Problem. To develop such capabilities, this paper intro-
duces the instruction execution problem where the agent’s
overall task is to execute a given list of instructions de-
scribed by a simple form of natural language while dealing
with unexpected events, as illustrated in Figure 1. More
speciﬁcally, we assume that each instruction can be exe-
cuted by performing one or more high-level subtasks in se-
quence. Even though the agent can pre-learn skills to per-
form such subtasks (e.g., [Pick up, Pig] in Figure 1), and the
instructions can be easily translated to subtasks, our prob-
lem is difﬁcult due to the following challenges.

• Generalization: Pre-training of skills can only be done
on a subset of subtasks, but the agent is required to per-
form previously unseen subtasks (e.g., going to a new
place) in order to execute unseen instructions during test-
ing. Thus, the agent should learn to generalize to new
subtasks in the skill learning stage. Furthermore, the
agent is required to execute previously unseen and longer
sequences of instructions during evaluation.

• Delayed reward: The agent is not told which instruction
to execute at any point of time from the environment but
just given the full list of instructions as input. In addition,
the agent does not receive any signal on completing in-

Zero-Shot Task Generalization with Multi-Task Deep Reinforcement Learning

dividual instructions from the environment, i.e., success-
reward is provided only when all instructions are exe-
cuted correctly. Therefore, the agent should keep track
of which instruction it is executing and decide when to
move on to the next instruction.

• Interruption: As described in Figure 1, there can be un-
expected events in uncertain environments, such as op-
portunities to earn bonuses (e.g., windfalls), or emergen-
cies (e.g., low battery). It can be better for the agent to in-
terrupt the ongoing subtask before it is ﬁnished, perform
a different subtask to deal with such events, and resume
executing the interrupted subtask in the instructions after
that. Thus, the agent should achieve a balance between
executing instructions and dealing with such events.

• Memory: There are loop instructions (e.g., “Pick up 3
pig”) which require the agent to perform the same sub-
task ([Pick up, Pig]) multiple times and take into account
the history of observations and subtasks in order to de-
cide when to move on to the next instruction correctly.

Due to these challenges, the agent should be able to execute
a novel subtask, keep track of what it has done, monitor
observations to interrupt ongoing subtasks depending on
circumstances, and switch to the next instruction precisely
when the current instruction is ﬁnished.

Our Approach and Technical Contributions. To ad-
dress the aforementioned challenges, we divide the learn-
ing problem into two stages: 1) learning skills to perform
a set of subtasks and generalizing to unseen subtasks, and
2) learning to execute instructions using the learned skills.
Speciﬁcally, we assume that subtasks are deﬁned by several
disentangled parameters. Thus, in the ﬁrst stage our archi-
tecture learns a parameterized skill (da Silva et al., 2012) to
perform different subtasks depending on input parameters.
In order to generalize over unseen parameters, we propose
a new objective function that encourages making analogies
between similar subtasks so that the underlying manifold of
the entire subtask space can be learned without experienc-
ing all subtasks. In the second stage, our architecture learns
a meta controller on top of the parameterized skill so that
it can read instructions and decide which subtask to per-
form. The overall hierarchical RL architecture is shown in
Figure 3. To deal with delayed reward as well as interrup-
tion, we propose a novel neural network (see Figure 4) that
learns when to update the subtask in the meta controller.
This not only allows learning to be more efﬁcient under de-
layed reward by operating at a larger time-scale but also al-
lows interruptions of ongoing subtasks when an unexpected
event is observed.

Main Results. We developed a 3D visual environment
using Minecraft based on Oh et al. (2016) where the
agent can interact with many objects. Our results on mul-
tiple sets of parameterized subtasks show that our pro-

posed analogy-making objective can generalize success-
fully. Our results on multiple instruction execution prob-
lems show that our meta controller’s ability to learn when
to update the subtask plays a key role in solving the over-
all problem and outperforms several hierarchical base-
lines. The demo videos are available at the following
website: https://sites.google.com/a/umich.
edu/junhyuk-oh/task-generalization.

The rest of the sections are organized as follows. Section 2
presents related work. Section 3 presents our analogy-
making objective for generalization to parameterized tasks
and demonstrates its application to different generalization
scenarios. Section 4 presents our hierarchical architecture
for the instruction execution problem with our new neural
network that learns to operate at a large time-scale. In addi-
tion, we demonstrate our agent’s ability to generalize over
sequences of instructions, as well as provide a comparison
to several alternative approaches.

2. Related Work
Hierarchical RL. A number of hierarchical RL ap-
proaches are designed to deal with sequential tasks. Typi-
cally these have the form of a meta controller and a set of
lower-level controllers for subtasks (Sutton et al., 1999; Di-
etterich, 2000; Parr and Russell, 1997; Ghavamzadeh and
Mahadevan, 2003; Konidaris et al., 2012; Konidaris and
Barto, 2007). However, much of the previous work as-
sumes that the overall task is ﬁxed (e.g., Taxi domain (Di-
etterich, 2000)). In other words, the optimal sequence of
subtasks is ﬁxed during evaluation (e.g., picking up a pas-
senger followed by navigating to a destination in the Taxi
domain). This makes it hard to evaluate the agent’s ability
to compose pre-learned policies to solve previously unseen
sequential tasks in a zero-shot fashion unless we re-train the
agent on the new tasks in a transfer learning setting (Singh,
1991; 1992; McGovern and Barto, 2002). Our work is also
closely related to Programmable HAMs (PHAMs) (Andre
and Russell, 2000; 2002) in that a PHAM is designed to
execute a given program. However, the program explicitly
speciﬁes the policy in PHAMs which effectively reduces
the state-action search space. In contrast, instructions are a
description of the task in our work, which means that the
agent should learn to use the instructions to maximize its
reward.

Hierarchical Deep RL. Hierarhical RL has been re-
cently combined with deep learning. Kulkarni et al. (2016)
proposed hierarchical Deep Q-Learning and demonstrated
improved exploration in a challenging Atari game. Tessler
et al. (2017) proposed a similar architecture, but the high-
level controller is allowed to choose primitive actions di-
rectly. Bacon et al. (2017) proposed the option-critic ar-
chitecture, which learns options without pseudo reward
and demonstrated that it can learn distinct options in Atari

Zero-Shot Task Generalization with Multi-Task Deep Reinforcement Learning

Figure 2: Architecture of parameterized skill. See text for details.

games. Heess et al. (2016) formulated the actions of the
meta controller as continuous variables that are used to
modulate the behavior of the low-level controller. Florensa
et al. (2017) trained a stochastic neural network with mu-
tual information regularization to discover skills. Most of
these approaches build an open-loop policy at the high-
level controller that waits until the previous subtask is ﬁn-
ished once it is chosen. This approach is not able to inter-
rupt ongoing subtasks in principle, while our architecture
can switch its subtask at any time.

Zero-Shot Task Generalization. There have been a few
papers on zero-shot generalization to new tasks. For exam-
ple, da Silva et al. (2012) introduced parameterized skills
that map sets of task descriptions to policies. Isele et al.
(2016) achieved zero-shot task generalization through dic-
tionary learning with sparsity constraints. Schaul et al.
(2015) proposed universal value function approximators
(UVFAs) that learn value functions for state and goal pairs.
Devin et al. (2017) proposed composing sub-networks that
are shared across tasks and robots in order to achieve gen-
eralization to unseen conﬁgurations of them. Unlike the
above prior work, we propose a ﬂexible metric learning
method which can be applied to various generalization sce-
narios. Andreas et al. (2016) proposed a framework to learn
the underlying subtasks from a policy sketch which speci-
ﬁes a sequence of subtasks, and the agent can generalize
over new sequences of them in principle. In contrast, our
work aims to generalize over unseen subtasks as well as un-
seen sequences of them. In addition, the agent should han-
dle unexpected events in our problem that are not described
by the instructions by interrupting subtasks appropriately.

Instruction Execution. There has been a line of work for
building agents that can execute natural language instruc-
tions: Tellex et al. (2011; 2014) for robotics and MacMa-
hon et al. (2006); Chen and Mooney (2011); Mei et al.
(2015) for a simulated environment. However, these ap-
proaches focus on natural language understanding to map
instructions to actions or groundings in a supervised set-
ting. In contrast, we focus on generalization to sequences
of instructions without any supervision for language under-
standing or for actions. Although Branavan et al. (2009)
also tackle a similar problem, the agent is given a single
instruction at a time, while our agent needs to learn how to
align instructions and state given a full list of instructions.

3. Learning a Parameterized Skill
In this paper, a parameterized skill is a multi-task policy
corresponding to multiple tasks deﬁned by categorical in-
put task parameters, e.g., [Pick up, X]. More formally, we
deﬁne a parameterized skill as a mapping O × G → A × B,
where O is a set of observations, G is a set of task pa-
rameters, A is a set of primitive actions, and B = {0, 1}
indicates whether the task is ﬁnished or not. A space of
tasks is deﬁned using the Cartesian product of task param-
eters: G = G(1) × ... × G(n), where G(i) is a set of the
i-th parameters (e.g., G = {Visit, Pick up}×{X, Y, Z}).
Given an observation xt ∈ O at time t and task parameters
g = (cid:2)g(1), ..., g(n)(cid:3) ∈ G, where g(i) is a one-hot vector, the
parameterized skill is the following functions:

Policy: πφ(at|xt, g)
Termination: βφ(bt|xt, g),

where πφ is the policy optimized for the task g, and βφ is a
termination function (Sutton et al., 1999) which is the prob-
ability that the state is terminal at time t for the given task
g. The parameterized skill is represented by a non-linear
function approximator φ(·), a neural network in this paper.
The neural network architecture of our parameterized skill
is illustrated in Figure 2. The network maps input task pa-
rameters into a task embedding space ϕ(g), which is com-
bined with the observation followed by the output layers.
More details are described in the supplementary material.

3.1. Learning to Generalize by Analogy-Making
Only a subset of tasks (G(cid:48) ⊂ G) are available during train-
ing, and so in order to generalize to unseen tasks during
evaluation the network needs to learn knowledge about the
relationship between different task parameters when learn-
ing the task embedding ϕ(g).

To this end, we propose an analogy-making objective in-
spired by Reed et al. (2015). The main idea is to learn
correspondences between tasks. For example, if target ob-
jects and ‘Visit/Pick up’ actions are independent (i.e., each
action can be applied to any target object), we can enforce
the analogy [Visit, X] : [Visit, Y] :: [Pick up, X] : [Pick up,
Y] for any X and Y in the embedding space, which means
that the difference between ‘Visit’ and ‘Pick up’ is consis-
tent regardless of target objects and vice versa. This allows
the agent to generalize to unseen combinations of actions
and target objects, such as performing [Pick up, Y] after it
has learned to perform [Pick up, X] and [Visit, Y].

More speciﬁcally, we deﬁne several constraints as follows:

(cid:107)∆ (gA, gB) − ∆ (gC, gD)(cid:107) ≈ 0
(cid:107)∆ (gA, gB) − ∆ (gC, gD)(cid:107) ≥ τdis
(cid:107)∆ (gA, gB)(cid:107) ≥ τdif f
(cid:104)
k , ..., g(n)

where gk =

k , g(2)
g(1)

(cid:105)

k

if gA : gB :: gC : gD
if gA : gB (cid:54)= gC : gD
if gA (cid:54)= gB,

∈ G are task parameters,

ObservationTaskparametersActionTermination?TaskembeddingZero-Shot Task Generalization with Multi-Task Deep Reinforcement Learning

∆ (gA, gB) = ϕ(gA) − ϕ(gB) is the difference vector be-
tween two tasks in the embedding space, and τdis and τdif f
are constant threshold distances. Intuitively, the ﬁrst con-
straint enforces the analogy (i.e., parallelogram structure
in the embedding space; see Mikolov et al. (2013); Reed
et al. (2015)), while the other constraints prevent trivial so-
lutions. We incorporate these constraints into the following
objectives based on contrastive loss (Hadsell et al., 2006):
Lsim = EgA...D∼Gsim
(cid:104)
Ldis = EgA...D∼Gdis

(cid:2)(cid:107)∆ (gA, gB) − ∆ (gC, gD) (cid:107)2(cid:3)
(τdis − (cid:107)∆ (gA, gB) − ∆ (gC, gD) (cid:107))2
(cid:104)
(τdif f − (cid:107)∆ (gA, gB) (cid:107))2

Ldif f = EgA,B ∼Gdif f

(cid:105)

,

+

(cid:105)

+

where (·)+ = max(0, ·) and Gsim, Gdis, Gdif f are sets of
task parameters that satisfy corresponding conditions in the
above three constraints. The ﬁnal analogy-making objec-
tive is the weighted sum of the above three objectives.

3.2. Training
The parameterized skill is trained on a set of tasks (G(cid:48) ⊂ G)
through the actor-critic method with generalized advantage
estimation (Schulman et al., 2016). We also found that
pre-training through policy distillation (Rusu et al., 2016;
Parisotto et al., 2016) gives slightly better results as dis-
cussed in Tessler et al. (2017). Throughout training, the
parameterized skill is also made to predict whether the cur-
rent state is terminal or not through a binary classiﬁcation
objective, and the analogy-making objective is applied to
the task embedding separately. The full details of the learn-
ing objectives are described in the supplementary material.

3.3. Experiments

Environment. We developed a 3D visual environment
using Minecraft based on Oh et al. (2016) as shown in
Figure 1. An observation is represented as a 64 × 64
pixel RGB image. There are 7 different types of objects:
Pig, Sheep, Greenbot, Horse, Cat, Box, and Ice. The
topology of the world and the objects are randomly gen-
erated for every episode. The agent has 9 actions: Look
(Left/Right/Up/Down), Move (Forward/Backward), Pick
up, Transform, and No operation. Pick up removes the ob-
ject in front of the agent, and Transform changes the object
in front of the agent to ice (a special object).

Implementation Details. The network architecture of
the parameterized skill consists of 4 convolution layers
and one LSTM (Hochreiter and Schmidhuber, 1997) layer.
We conducted curriculum training by changing the size
of the world, the density of object and walls according
to the agent’s success rate. We implemented actor-critic
method with 16 CPU threads based on Sukhbaatar et al.
(2015). The parameters are updated after 8 episodes for
each thread. The details of architectures and hyperparame-
ters are described in the supplementary material.

Scenario

Independent

Object-dependent

Inter/Extrapolation

Analogy
×
(cid:88)
×
(cid:88)
×
(cid:88)

Train
0.3 (99.8%)
0.3 (99.8%)
0.3 (99.7%)
0.3 (99.8%)
-0.7 (97.5%)
-0.7 (97.5%)

Unseen
-3.7 (34.8%)
0.3 (99.5%)
-5.0 (2.2%)
0.3 (99.7%)
-2.2 (24.9%)
-1.7 (94.5%)

Table 1: Performance on parameterized tasks. Each entry shows
‘Average reward (Success rate)’. We assume an episode is suc-
cessful only if the agent successfully ﬁnishes the task and its ter-
mination predictions are correct throughout the whole episode.

Results. To see how useful analogy-making is for gen-
eralization to unseen parameterized tasks, we trained and
evaluated the parameterized skill on three different sets of
parameterized tasks deﬁned below1.

• Independent: The task space is deﬁned as G = T × X ,
where T = {Visit, Pick up, Transform} and X is the set
of object types. The agent should move on top of the
target object given ‘Visit’ task and perform the corre-
sponding actions in front of the target given ‘Pick up’
and ‘Transform’ tasks. Only a subset of tasks are en-
countered during training, so the agent should generalize
over unseen conﬁgurations of task parameters.

• Object-dependent: The task space is deﬁned as G =
T (cid:48) × X , where T (cid:48) = T ∪ {Interact with}. We divided
objects into two groups, each of which should be either
picked up or transformed given ‘Interact with’ task. Only
a subset of target object types are encountered during
training, so there is no chance for the agent to generalize
without knowledge of the group of each object. We ap-
plied analogy-making so that analogies can be made only
within the same group. This allows the agent to perform
object-dependent actions even for unseen objects.

• Interpolation/Extrapolation: The task space is deﬁned
as G = T × X × C, where C = {1, 2, ..., 7}. The
agent should perform a task for a given number of times
(c ∈ C). Only {1, 3, 5} ⊂ C is given during training,
and the agent should generalize over unseen numbers
{2, 4, 6, 7}. Note that the optimal policy for a task can be
derived from T × X , but predicting termination requires
generalization to unseen numbers. We applied analogy-
making based on arithmetic (e.g., [Pick up, X, 2] : [Pick
up, X, 5] :: [Transform, Y, 3] : [Transform, Y, 6]).

As summarized in Table 1, the parameterized skill with
our analogy-making objective can successfully generalize
to unseen tasks in all generalization scenarios. This sug-
gests that when learning a representation of task parame-
ters, it is possible to inject prior knowledge in the form of
the analogy-making objective so that the agent can learn to

1The sets of subtasks used for training and evaluation are de-

scribed in the supplementary material.

Zero-Shot Task Generalization with Multi-Task Deep Reinforcement Learning

Figure 3: Overview of our hierarchical architecture.

generalize over unseen tasks in various ways depending on
semantics or context without needing to experience them.

4. Learning to Execute Instructions using

Parameterized Skill

We now consider the instruction execution problem where
the agent is given a sequence of simple natural language
instructions, as illustrated in Figure 1. We assume an al-
ready trained parameterized skill, as described in Section 3.
Thus, the main remaining problem is how to use the pa-
rameterized skill to execute instructions. Although the re-
quirement that instructions be executed sequentially makes
the problem easier (than, e.g., conditional-instructions), the
agent still needs to make complex decisions because it
should deviate from instructions to deal with unexpected
events (e.g., low battery) and remember what it has done to
deal with loop instructions, as discussed in Section 1.

To address the above challenges, our hierarchical RL archi-
tecture (see Figure 3) consists of two modules: meta con-
troller and parameterized skill. Speciﬁcally, a meta con-
troller reads the instructions and passes subtask parameters
to a parameterized skill which executes the given subtask
and provides its termination signal back to the meta con-
troller. Section 4.1 describes the overall architecture of the
meta controller for dealing with instructions. Section 4.2
describes a novel neural architecture that learns when to
update the subtask in order to better deal with delayed re-
ward signal as well as unexpected events.

4.1. Meta Controller Architecture

As illustrated in Figure 4, the meta controller is a mapping
O × M × G × B → G, where M is a list of instructions.
Intuitively, the meta controller decides subtask parameters
gt ∈ G conditioned on the observation xt ∈ O, the list of
instructions M ∈ M, the previously selected subtask gt−1,
and its termination signal (b ∼ βφ).

In contrast to recent hierarchical deep RL approaches
where the meta controller can update its subtask (or option)
only when the previous one terminates or only after a ﬁxed
number of steps, our meta controller can update the subtask
at any time and takes the termination signal as additional
input. This gives more ﬂexibility to the meta controller and

Figure 4: Neural network architecture of meta controller.

enables interrupting ongoing tasks before termination.

In order to keep track of the agent’s progress on instruction
execution, the meta controller maintains its internal state by
computing a context vector (Section 4.1.1) and determines
which subtask to execute by focusing on one instruction at
a time from the list of instructions (Section 4.1.2).

4.1.1. CONTEXT
Given the sentence embedding rt−1 retrieved at the pre-
vious time-step from the instructions (described in Sec-
tion 4.1.2), the previously selected subtask gt−1, and the
(cid:1), the meta con-
subtask termination bt ∼ βφ
troller computes the context vector (ht) as follows:

(cid:0)bt|st, gt−1

ht = LSTM (st, ht−1)
st = f (cid:0)xt, rt−1, gt−1, bt

(cid:1) ,

where f is a neural network. Intuitively, gt−1 and bt pro-
vide information about which subtask was being solved by
the parameterized skill and whether it has ﬁnished or not.
Thus, st is a summary of the current observation and the
ongoing subtask. ht takes the history of st into account
through the LSTM, which is used by the subtask updater.

4.1.2. SUBTASK UPDATER
The subtask updater constructs a memory structure from
the list of instructions, retrieves an instruction by maintain-
ing a pointer into the memory, and computes the subtask
parameters.

Instruction Memory. Given instructions as a list of sen-
tences M = (m1, m2, ..., mK), where each sentence con-
sists of a list of words, mi = (cid:0)w1, ..., w|mi|
(cid:1), the subtask
updater constructs memory blocks M ∈ RE×K (i.e., each
column is an E-dimensional embedding of a sentence).
The subtask updater maintains an instruction pointer (pt ∈
RK) which is non-negative and sums up to 1 indicating
which instruction the meta controller is executing. Mem-
ory construction and retrieval can be written as:

Memory: M = [ϕw (m1) , ϕw (m2) , ..., ϕw (mK)]
Retrieval: rt = Mpt,

(1)

(2)

ObservationContextSubtaskparametersSubtaskparametersRetrieved instructionSubtasktermination?InstructionmemorySubtaskupdaterUpdateYesNoInstructionsRecurrenceZero-Shot Task Generalization with Multi-Task Deep Reinforcement Learning

Figure 5: Unrolled illustration of the meta controller with a
learned time-scale. The internal states (p, r, h) and the subtask
(g) are updated only when c = 1. If c = 0, the meta controller
continues the previous subtask without updating its internal states.

where ϕw (mi) ∈ RE is the embedding of the i-th sentence
(e.g., Bag-of-words), and rt ∈ RE is the retrieved sentence
embedding which is used for computing the subtask pa-
rameters. Intuitively, if pt is a one-hot vector, rt indicates
a single instruction from the whole list of instructions. The
meta controller should learn to manage pt so that it can
focus on the correct instruction at each time-step.

Since instructions should be executed sequentially, we use
a location-based memory addressing mechanism (Zaremba
and Sutskever, 2015; Graves et al., 2014) to manage the
instruction pointer. Speciﬁcally, the subtask updater shifts
the instruction pointer by [−1, 1] as follows:

pt = lt ∗ pt−1 where lt = Softmax (cid:0)ϕshif t(ht)(cid:1) ,

(3)

where ∗ is a convolution operator, ϕshif t is a neural net-
work, and lt ∈ R3 is a soft-attention vector over the three
shift operations {−1, 0, +1}. The optimal policy should
keep the instruction pointer unchanged while executing an
instruction and increase the pointer by +1 precisely when
the current instruction is ﬁnished.

Subtask Parameters. The subtask updater takes the con-
text (ht), updates the instruction pointer (pt), retrieves an
instruction (rt), and computes subtask parameters as:

πθ (gt|ht, rt) =

(cid:89)

(cid:16)

πθ

g(i)
t

|ht, rt

(cid:17)

,

(4)

i

(cid:16)

g(i)
t

(cid:17)

where πθ
is a neural network for the i-th subtask parameter.

(ht, rt)

∝ exp

|ht, rt

(cid:16)

ϕgoal
i

(cid:17)

, and ϕgoal

i

4.2. Learning to Operate at a Large Time-Scale

Although the meta controller can learn an optimal policy by
updating the subtask at each time-step in principle, making
a decision at every time-step can be inefﬁcient because sub-
tasks do not change frequently. Instead, having temporally-
extended actions can be useful for dealing with delayed
reward by operating at a larger time-scale (Sutton et al.,
1999). While it is reasonable to use the subtask termination
signal to deﬁne the temporal scale of the meta controller as
in many recent hierarchical deep RL approaches (see Sec-
tion 2), this approach would result in a mostly open-loop

meta-controller policy that is not able to interrupt ongo-
ing subtasks before termination, which is necessary to deal
with unexpected events not speciﬁed in the instructions.

To address this dilemma, we propose to learn the time-scale
of the meta controller by introducing an internal binary de-
cision which indicates whether to invoke the subtask up-
dater to update the subtask or not, as illustrated in Figure 5.
This decision is deﬁned as: ct ∼ σ (cid:0)ϕupdate (st, ht−1)(cid:1)
where σ is a sigmoid function. If ct = 0, the meta con-
troller continues the current subtask without updating the
subtask updater. Otherwise, if ct = 1, the subtask updater
updates its internal states (e.g., instruction pointer) and the
subtask parameters. This allows the subtask updater to op-
erate at a large time-scale because one decision made by
the subtask updater results in multiple actions depending
on c values. The overall meta controller architecture with
this update scheme is illustrated in Figure 4.

of

the

ease

optimization

Soft-Update. To
non-
differentiable variable (ct), we propose a soft-update
rule by using ct = σ (cid:0)ϕupdate (st, ht−1)(cid:1) instead of
sampling it. The key idea is to take the weighted sum of
both ‘update’ and ‘copy’ scenarios using ct as the weight.
This method is described in Algorithm 1. We found that
training the meta controller using soft-update followed
by ﬁne-tuning by sampling ct is crucial for training the
meta controller. Note that the soft-update rule reduces to
the original formulation if we sample ct and lt from the
Bernoulli and multinomial distributions, which justiﬁes
our initialization trick.

Algorithm 1 Subtask update (Soft)
Input: st, ht−1, pt−1, rt−1, gt−1
Output: ht, pt, rt, gt
ct ← σ (cid:0)ϕupdate (st, ht−1)(cid:1)
˜ht ← LSTM (st, ht−1)
lt ← Softmax (cid:0)ϕshif t (cid:0)˜ht
˜pt ← lt ∗ pt−1
˜rt ← M˜pt
# Merge two scenarios (update/copy) using ct as weight
[pt, rt, ht] ← ct[˜pt, ˜rt, ˜ht] + (1 − ct) [pt−1, rt−1, ht−1]
g(i)
t ∼ ctπθ

# Decide update weight
# Update the context
# Decide shift operation
# Shift the instruction pointer
# Retrieve instruction

+ (1 − ct) g(i)

(cid:16)
g(i)
t

|˜ht, ˜rt

t−1∀i

(cid:1)(cid:1)

(cid:17)

Integrating with Hierarchical RNN. The idea of learn-
ing the time-scale of a recurrent neural network is closely
related to hierarchical RNN approaches (Koutnik et al.,
2014; Chung et al., 2017) where different groups of recur-
rent hidden units operate at different time-scales to capture
both long-term and short-term temporal information. Our
idea can be naturally integrated with hierarchical RNNs by
applying the update decision (c value) only for a subset of
recurrent units instead of all the units. Speciﬁcally, we di-
(cid:105)
vide the context vector into two groups: ht =
.
The low-level units (h(l)

t ) are updated at every time-step,

(cid:104)
h(l)
t

, h(h)
t

UpdateSubtaskUpdateSubtaskCopyCopyCopyUpdateZero-Shot Task Generalization with Multi-Task Deep Reinforcement Learning

while the high-level units (h(h)
) are updated depending on
t
the value of c. This simple modiﬁcation leads to a form of
hierarchical RNN where the low-level units focus on short-
term temporal information while the high-level units cap-
ture long-term dependencies.

Test (Seen) Test (Unseen)

Train
4
-7.1 (1%)

Length of instructions
Flat

20
-63.6 (0%)
Hierarchical-Long -5.8 (31%) -59.2 (0%)
Hierarchical-Short -3.3 (83%) -53.4 (23%)
Hierarchical-Dynamic -3.1 (95%) -30.3 (75%)

20
-62.0 (0%)
-59.2 (0%)
-53.6 (18%)
-38.0 (56%)

4.3. Training

The meta controller is trained on a training set of lists of
instructions. Given a pre-trained and ﬁxed parameterized
skill, the actor-critic method is used to update the parame-
ters of the meta controller. Since the meta controller also
learns a subtask embedding ϕ(gt−1) and has to deal with
unseen subtasks during evaluation, analogy-making objec-
tive is also applied. The details of the objective function
are provided in the supplementary material.

4.4. Experiments

The experiments are designed to explore the following
questions: (1) Will the proposed hierarchical architecture
outperform a non-hierarchical baseline? (2) How beneﬁ-
cial is the meta controller’s ability to learn when to update
the subtask? We are also interested in understanding the
qualitative properties of our agent’s behavior.2

Environment. We used the same Minecraft domain used
in Section 3.3. The agent receives a time penalty (−0.1)
for each step and receives +1 reward when it ﬁnishes the
entire list of instructions in the correct order. Throughout
an episode, a box (including treasures) randomly appears
with probability of 0.03 and transforming a box gives +0.9
reward.

The subtask space is deﬁned as G = T ×X , and the seman-
tics of each subtask are the same as the ‘Independent’ case
in Section 3.3. We used the best-performing parameterized
skill throughout this experiment.

There are 7 types of instructions: {Visit X, Pick up X,
Transform X, Pick up 2 X, Transform 2 X, Pick up 3 X,
Transform 3 X} where ‘X’ is the target object type. Note
that the parameterized skill used in this experiment was
not trained on loop instructions (e.g., Pick up 3 X), so the
last four instructions require the meta controller to learn to
repeat the corresponding subtask for the given number of
times. To see how the agent generalizes to previously un-
seen instructions, only a subset of instructions and subtasks
was presented during training.

Implementation Details. The meta controller consists of
3 convolution layers and one LSTM layer. We also con-
ducted curriculum training by changing the size of the
world, the density of object and walls, and the number of
instructions according to the agent’s success rate. We used

Table 2: Performance on instruction execution. Each entry shows
average reward and success rate. ‘Hierarchical-Dynamic’ is our
approach that learns when to update the subtask. An episode is
successful only when the agent solves all instructions correctly.

the actor-critic implementation described in Section 3.3.

Baselines. To understand the advantage of using the hi-
erarchical structure and the beneﬁt of our meta controller’s
ability to learn when to update the subtask, we trained three
baselines as follows.
• Flat: identical to our meta controller except that it di-
rectly chooses primitive actions without using the pa-
rameterized skill. It is also pre-trained on the training
set of subtasks.

• Hierarchical-Long: identical to our architecture except
that the meta controller can update the subtask only when
the current subtask is ﬁnished. This approach is similar
to recent hierarchical deep RL methods (Kulkarni et al.,
2016; Tessler et al., 2017).

• Hierarchical-Short:

identical to our architecture ex-
cept that the meta controller updates the subtask at every
time-step.

Overall Performance. The results on the instruction ex-
ecution are summarized in Table 2 and Figure 6. It shows
that our architecture (‘Hierarchical-Dynamic’) can han-
dle a relatively long list of seen and unseen instructions of
length 20 with reasonably high success rates, even though
it is trained on short instructions of length 4. Although
the performance degrades as the number of instructions
increases, our architecture ﬁnishes 18 out of 20 seen in-
structions and 14 out of 20 unseen instructions on aver-
age. These results show that our agent is able to generalize
to longer compositions of seen/unseen instructions by just
learning to solve short sequences of a subset of instructions.

Flat vs. Hierarchy. Table 2 shows that the ﬂat baseline
completely fails even on training instructions. The ﬂat con-
troller tends to struggle with loop instructions (e.g., Pick up
3 pig) so that it learned a sub-optimal policy which moves
to the next instruction with a small probability at each step
regardless of its progress. This implies that it is hard for the
ﬂat controller to detect precisely when a subtask is ﬁnished,
whereas hierarchical architectures can easily detect when a
subtask is done, because the parameterized skill provides a
termination signal to the meta controller.

2For further analysis, we also conducted comprehensive ex-
periments on a 2D grid-world domain. However, due to space
limits, those results are provided in the supplementary material.

Effect of Learned Time-Scale. As shown in Table 2 and
Figure 6, ‘Hierarchical-Long’ baseline performs signiﬁ-
cantly worse than our architecture. We found that whenever

Zero-Shot Task Generalization with Multi-Task Deep Reinforcement Learning

Figure 6: Performance per number of instructions. From left to right, the plots show reward, success rate, the number of steps, and the
average number of instructions completed respectively.

Figure 7: Analysis of the learned policy. ‘Update’ shows our agent’s internal update decision. ‘Shift’ shows our agent’s instruction-shift
decision (-1, 0, and +1 from top to bottom). The bottom text shows the instruction indicated by the instruction pointer, while the top text
shows the subtask chosen by the meta controller. (A) the agent picks up the pig to ﬁnish the instruction and moves to the next instruction.
(B) When the agent observes a box that randomly appeared while executing ‘Pick up 2 pig’ instruction, it immediately changes its subtask
to [Transform, Box]. (C) After dealing with the event (transforming a box), the agent resumes executing the instruction (‘Pick up 2 pig’).
(D) The agent ﬁnishes the ﬁnal instruction.

a subtask is ﬁnished, this baseline puts a high probability
to switch to [Transform, Box] regardless of the existence
of box because transforming a box gives a bonus reward if
a box exists by chance. However, this leads to wasting too
much time ﬁnding a box until it appears and results in a
poor success rate due to the time limit. This result implies
that an open-loop policy that has to wait until a subtask ﬁn-
ishes can be confused by such an uncertain event because
it cannot interrupt ongoing subtasks before termination.

On the other hand, we observed that ‘Hierarchical-Short’
often fails on loop instructions by moving on to the next
instruction before it ﬁnishes such instructions. This base-
line should repeat the same subtask while not changing the
instruction pointer for a long time and the reward is even
more delayed given loop instructions. In contrast, the sub-
task updater in our architecture makes fewer decisions by
operating at a large time-scale so that it can get more direct
feedback from the long-term future. We conjecture that this
is why our architecture performs better than this baseline.
This result shows that learning when to update the subtask
using the neural network is beneﬁcial for dealing with de-
layed reward without compromising the ability to interrupt.

Analysis of The Learned Policy. We visualized our
agent’s behavior given a long list of instructions in Fig-
ure 7. Interestingly, when the agent sees a box, the meta
controller immediately changes its subtask to [Transform,
Box] to get a positive reward even though its instruction

pointer is indicating ‘Pick up 2 pig’ and resumes execut-
ing the instruction after dealing with the box. Through-
out this event and the loop instruction, the meta controller
keeps the instruction pointer unchanged as illustrated in
In addition, the agent learned to up-
(B-C) in Figure 7.
date the instruction pointer and the subtask almost only
when it is needed, which provides the subtask updater with
temporally-extended actions. This is not only computation-
ally efﬁcient but also useful for learning a better policy.

5. Conclusion
In this paper, we explored a type of zero-shot task gener-
alization in RL with a new problem where the agent is re-
quired to execute and generalize over sequences of instruc-
tions. We proposed an analogy-making objective which
enables generalization over unseen parameterized tasks in
various scenarios. We also proposed a novel way to learn
the time-scale of the meta controller that proved to be more
efﬁcient and ﬂexible than alternative approaches for inter-
rupting subtasks and for dealing with delayed sequential
decision problems. Our empirical results on a stochastic
3D domain showed that our architecture generalizes well
to longer sequences of instructions as well as unseen in-
structions. Although our hierarchical RL architecture was
demonstrated in the simple setting where the set of instruc-
tions should be executed sequentially, we believe that our
key ideas are not limited to this setting but can be extended
to richer forms of instructions.

5101520Num of instructions−70−60−50−40−30−20−100Reward5101520Num of instructions0.00.20.40.60.81.0Success rate5101520Num of instructions0100200300400500600#steps5101520Num of instructions024681012141618#instructions completedFlat (Seen)Flat (Unseen)Hierarchical-Long (Seen)Hierarchical-Long (Unseen)Hierarchical-Short (Seen)Hierarchical-Short (Unseen)Hierarchical-Dynamic (Seen)Hierarchical-Dynamic (Unseen)UpdateShiftABCDABCD-10+1SubtaskInstructionZero-Shot Task Generalization with Multi-Task Deep Reinforcement Learning

Acknowledgement

This work was supported by NSF grant IIS-1526059. Any
opinions, ﬁndings, conclusions, or recommendations ex-
pressed here are those of the authors and do not necessarily
reﬂect the views of the sponsor.

References

D. Andre and S. J. Russell. Programmable reinforcement

learning agents. In NIPS, 2000.

D. Andre and S. J. Russell.
programmable reinforcement
AAAI/IAAI, 2002.

State abstraction for
In

learning agents.

J. Andreas, D. Klein, and S. Levine. Modular multitask
reinforcement learning with policy sketches. CoRR,
abs/1611.01796, 2016.

P.-L. Bacon, J. Harb, and D. Precup. The option-critic ar-

chitecture. In AAAI, 2017.

S. R. K. Branavan, H. Chen, L. S. Zettlemoyer, and
R. Barzilay. Reinforcement learning for mapping in-
structions to actions. In ACL/IJCNLP, 2009.

D. L. Chen and R. J. Mooney. Learning to interpret natural
language navigation instructions from observations. In
AAAI, 2011.

J. Chung, S. Ahn, and Y. Bengio. Hierarchical multiscale

recurrent neural networks. In ICLR, 2017.

B. C. da Silva, G. Konidaris, and A. G. Barto. Learning

parameterized skills. In ICML, 2012.

N. Heess, G. Wayne, Y. Tassa, T. P. Lillicrap, M. A. Ried-
miller, and D. Silver. Learning and transfer of modulated
locomotor controllers. arXiv preprint arXiv:1610.05182,
2016.

S. Hochreiter and J. Schmidhuber. Long short-term mem-

ory. Neural computation, 9(8):1735–1780, 1997.

D. Isele, M. Rostami, and E. Eaton. Using task features
for zero-shot knowledge transfer in lifelong learning. In
IJCAI, 2016.

G. Konidaris and A. G. Barto. Building portable options:
Skill transfer in reinforcement learning. In IJCAI, 2007.

G. Konidaris, I. Scheidwasser, and A. G. Barto. Transfer
in reinforcement learning via shared features. Journal of
Machine Learning Research, 13:1333–1371, 2012.

J. Koutnik, K. Greff, F. Gomez, and J. Schmidhuber. A

clockwork rnn. In ICML, 2014.

T. D. Kulkarni, K. R. Narasimhan, A. Saeedi, and J. B.
Tenenbaum. Hierarchical deep reinforcement learning:
Integrating temporal abstraction and intrinsic motiva-
tion. arXiv preprint arXiv:1604.06057, 2016.

M. MacMahon, B. Stankiewicz, and B. Kuipers. Walk
the talk: Connecting language, knowledge, and action
in route instructions. In AAAI, 2006.

A. McGovern and A. G. Barto. Autonomous discovery of
temporal abstractions from interaction with an environ-
ment. PhD thesis, University of Massachusetts, 2002.

H. Mei, M. Bansal, and M. R. Walter. Listen, attend, and
walk: Neural mapping of navigational instructions to ac-
tion sequences. arXiv preprint arXiv:1506.04089, 2015.

C. Devin, A. Gupta, T. Darrell, P. Abbeel, and S. Levine.
Learning modular neural network policies for multi-task
and multi-robot transfer. In ICRA, 2017.

T. Mikolov, Q. V. Le, and I. Sutskever. Exploiting simi-
larities among languages for machine translation. arXiv
preprint arXiv:1309.4168, 2013.

T. G. Dietterich. Hierarchical reinforcement learning with
the maxq value function decomposition. Journal of Ar-
tiﬁcial Intelligence Research, 13:227–303, 2000.

J. Oh, V. Chockalingam, S. Singh, and H. Lee. Memory-
based control of active perception and action in
minecraft. In ICML, 2016.

C. Florensa, Y. Duan, and P. Abbeel. Stochastic neural net-
works for hierarchical reinforcement learning. In ICLR,
2017.

M. Ghavamzadeh and S. Mahadevan. Hierarchical policy

gradient algorithms. In ICML, 2003.

A. Graves, G. Wayne, and I. Danihelka. Neural turing ma-

chines. arXiv preprint arXiv:1410.5401, 2014.

R. Hadsell, S. Chopra, and Y. LeCun. Dimensionality re-
In CVPR,

duction by learning an invariant mapping.
2006.

E. Parisotto, J. L. Ba, and R. Salakhutdinov. Actor-mimic:
Deep multitask and transfer reinforcement learning. In
ICLR, 2016.

R. Parr and S. J. Russell. Reinforcement learning with hi-

erarchies of machines. In NIPS, 1997.

S. E. Reed, Y. Zhang, Y. Zhang, and H. Lee. Deep visual

analogy-making. In NIPS, 2015.

A. A. Rusu, S. G. Colmenarejo, C. Gulcehre, G. Des-
J. Kirkpatrick, R. Pascanu, V. Mnih,
Policy distilla-

jardins,
K. Kavukcuoglu, and R. Hadsell.
tion. In ICLR, 2016.

Zero-Shot Task Generalization with Multi-Task Deep Reinforcement Learning

T. Schaul, D. Horgan, K. Gregor, and D. Silver. Universal

value function approximators. In ICML, 2015.

J. Schulman, P. Moritz, S. Levine, M. Jordan, and
P. Abbeel. High-dimensional continuous control using
generalized advantage estimation. In ICLR, 2016.

S. P. Singh. The efﬁcient learning of multiple task se-

quences. In NIPS, 1991.

S. P. Singh. Transfer of learning by composing solutions of
elemental sequential tasks. Machine Learning, 8(3-4):
323–339, 1992.

S. Sukhbaatar, A. Szlam, G. Synnaeve, S. Chintala, and
R. Fergus. Mazebase: A sandbox for learning from
games. arXiv preprint arXiv:1511.07401, 2015.

R. S. Sutton, D. Precup, and S. Singh. Between mdps
and semi-mdps: A framework for temporal abstraction
in reinforcement learning. Artiﬁcial intelligence, 112(1):
181–211, 1999.

S. Tellex, T. Kollar, S. Dickerson, M. R. Walter, A. G.
Banerjee, S. J. Teller, and N. Roy. Understanding nat-
ural language commands for robotic navigation and mo-
bile manipulation. In AAAI, 2011.

S. Tellex, R. A. Knepper, A. Li, D. Rus, and N. Roy. Asking

for help using inverse semantics. In RSS, 2014.

C. Tessler, S. Givony, T. Zahavy, D. J. Mankowitz, and
S. Mannor. A deep hierarchical approach to lifelong
learning in minecraft. In AAAI, 2017.

W. Zaremba and I. Sutskever. Reinforcement learning neu-
ral turing machines. arXiv preprint arXiv:1505.00521,
2015.

