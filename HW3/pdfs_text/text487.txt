Robust Adversarial Reinforcement Learning

Lerrel Pinto 1 James Davidson 2 Rahul Sukthankar 3 Abhinav Gupta 1 3

Abstract

Deep neural networks coupled with fast simula-
tion and improved computation have led to re-
cent successes in the ﬁeld of reinforcement learn-
ing (RL). However, most current RL-based ap-
proaches fail to generalize since: (a) the gap be-
tween simulation and real world is so large that
policy-learning approaches fail to transfer; (b)
even if policy learning is done in real world, the
data scarcity leads to failed generalization from
training to test scenarios (e.g., due to different
Inspired from H∞
friction or object masses).
control methods, we note that both modeling er-
rors and differences in training and test scenar-
ios can be viewed as extra forces/disturbances in
the system. This paper proposes the idea of ro-
bust adversarial reinforcement learning (RARL),
where we train an agent to operate in the pres-
ence of a destabilizing adversary that applies dis-
turbance forces to the system. The jointly trained
adversary is reinforced – that is, it learns an op-
timal destabilization policy. We formulate the
policy learning as a zero-sum, minimax objec-
tive function. Extensive experiments in multiple
environments (InvertedPendulum, HalfCheetah,
Swimmer, Hopper, Walker2d and Ant) conclu-
sively demonstrate that our method (a) improves
training stability; (b) is robust to differences in
training/test conditions; and c) outperform the
baseline even in the absence of the adversary.

1. Introduction

High-capacity function approximators such as deep neu-
ral networks have led to increased success in the ﬁeld of
reinforcement learning (Mnih et al., 2015; Silver et al.,
2016; Gu et al., 2016; Lillicrap et al., 2015; Mordatch
et al., 2015). However, a major bottleneck for such

1Carnegie Mellon University 2Google Brain 3Google Re-
search. Correspondence to: Lerrel Pinto <lerrelp@cs.cmu.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

train-
policy-learning methods is their reliance on data:
ing high-capacity models requires huge amounts of train-
ing data/trajectories. While this training data can be easily
obtained for tasks like games (e.g., Doom, Montezuma’s
Revenge) (Mnih et al., 2015), data-collection and policy
learning for real-world physical tasks are signiﬁcantly more
challenging.

There are two possible ways to perform policy learning for
real-world physical tasks:

• Real-world Policy Learning: The ﬁrst approach is to
learn the agent’s policy in the real-world. However,
training in the real-world is too expensive, dangerous
and time-intensive leading to scarcity of data. Due to
scarcity of data, training is often restricted to a limited
set of training scenarios, causing overﬁtting.
If the
test scenario is different (e.g., different friction coef-
ﬁcient), the learned policy fails to generalize. There-
fore, we need a learned policy that is robust and gen-
eralizes well across a range of scenarios.

• Learning in simulation: One way of escaping the
data scarcity in the real-world is to transfer a policy
learned in a simulator to the real world. However the
environment and physics of the simulator are not ex-
actly the same as the real world. This reality gap often
results in unsuccessful transfer if the learned policy
isn’t robust to modeling errors (Christiano et al., 2016;
Rusu et al., 2016).

Both the test-generalization and simulation-transfer issues
that many policy-
are further exacerbated by the fact
learning algorithms are stochastic in nature. For many hard
physical tasks such as Walker2D (Erez et al., 2011), only a
small fraction of runs leads to stable walking policies. This
makes these approaches even more time and data-intensive.
What we need is an approach that is signiﬁcantly more sta-
ble/robust in learning policies across different runs and ini-
tializations while requiring less data during training.

So, how can we model uncertainties and learn a pol-
icy robust to all uncertainties? How can we model the
gap between simulations and real-world? We begin with
the insight that modeling errors can be viewed as ex-
tra forces/disturbances in the system (Bas¸ar & Bernhard,
2008). For example, high friction at test time might be
modeled as extra forces at contact points against the di-

Robust Adversarial Reinforcement Learning

Figure 1. We evaluate RARL on a variety of OpenAI gym problems. The adversary learns to apply destabilizing forces on speciﬁc points
(denoted by red arrows) on the system, encouraging the protagonist to learn a robust control policy. These policies also transfer better to
new test environments, with different environmental conditions and where the adversary may or may not be present.

rection of motion. Inspired by this observation, this paper
proposes the idea of modeling uncertainties via an adver-
sarial agent that applies disturbance forces to the system.
Moreover, the adversary is reinforced – that is, it learns an
optimal policy to thwart the original agent’s goal. Our pro-
posed method, Robust Adversarial Reinforcement Learn-
ing (RARL), jointly trains a pair of agents, a protagonist
and an adversary, where the protagonist learns to fulﬁl the
original task goals while being robust to the disruptions
generated by its adversary.

We perform extensive experiments to evaluate RARL on
multiple OpenAI gym environments like InvertedPendu-
lum, HalfCheetah, Swimmer, Hopper, Walker2d and Ant
(see Figure 1). We demonstrate that our proposed approach
is: (a) Robust to model initializations: The learned policy
performs better given different model parameter initializa-
tions and random seeds. This alleviates the data scarcity
(b) Robust to
issue by reducing sensitivity of learning.
modeling errors and uncertainties: The learned policy
generalizes signiﬁcantly better to different test environment
settings (e.g., with different mass and friction values).

1.1. Overview of RARL

Our goal is to learn a policy that is robust to modeling er-
rors in simulation or mismatch between training and test
scenarios. For example, we would like to learn policy for
Walker2D that works not only on carpet (training scenario)
but also generalizes to walking on ice (test scenario). Simi-
larly, other parameters such as the mass of the walker might
vary during training and test. One possibility is to list all
such parameters (mass, friction etc.) and learn an ensem-
ble of policies for different possible variations (Rajeswaran
et al., 2016). But explicit consideration of all possible pa-
rameters of how simulation and real world might differ or
what parameters can change between training/test is infea-
sible.

Our core idea is to model the differences during training
and test scenarios via extra forces/disturbances in the sys-
tem. Our hypothesis is that if we can learn a policy that

is robust to all disturbances, then this policy will be robust
to changes in training/test situations; and hence generalize
well. But is it possible to sample trajectories under all pos-
sible disturbances? In unconstrained scenarios, the space
of possible disturbances could be larger than the space of
possible actions, which makes sampled trajectories even
sparser in the joint space.

To overcome this problem, we advocate a two-pronged ap-
proach:

(a) Adversarial agents for modeling disturbances: In-
stead of sampling all possible disturbances, we jointly train
a second agent (termed the adversary), whose goal is to im-
pede the original agent (termed the protagonist) by apply-
ing destabilizing forces. The adversary is rewarded only
for the failure of the protagonist. Therefore, the adversary
learns to sample hard examples: disturbances which will
make original agent fail; the protagonist learns a policy that
is robust to any disturbances created by the adversary.

(b) Adversaries that incorporate domain knowledge:
The naive way of developing an adversary would be to sim-
ply give it the same action space as the protagonist – like
a driving student and driving instructor ﬁghting for control
of a dual-control car. However, our proposed approach is
much richer and is not limited to symmetric action spaces –
we can exploit domain knowledge to: focus the adversary
on the protagonist’s weak points; and since the adversary
is in a simulated environment, we can give the adversary
“super-powers” – the ability to affect the robot or environ-
ment in ways the protagonist cannot (e.g., suddenly change
a physical parameter like frictional coefﬁcient or mass).

2. Background

Before we delve into the details of RARL, we ﬁrst out-
line our terminology, standard reinforcement learning set-
ting and two-player zero-sum games from which our paper
is inspired.

InvertedPendulumHalfCheetahSwimmerHopperWalker2dAnt2.1. Standard reinforcement learning on MDPs

ble transition functions as well. Therefore,

Robust Adversarial Reinforcement Learning

In this paper we examine continuous space MDPs that are
represented by the tuple: (S, A, P, r, γ, s0), where S is a
set of continuous states and A is a set of continuous actions,
P : S × A × S → R is the transition probability, r :
S × A → R is the reward function, γ is the discount factor,
and s0 is the initial state distribution.

Batch policy algorithms like REINFORCE (Williams,
1992), NPG (Kakade, 2002) and TRPO (Schulman et al.,
2015) attempt to learn a stochastic policy πθ
: S ×
A → R that maximizes the cumulative discounted reward
(cid:80)T −1
t=0 γtr(st, at). Here, θ denotes the parameters for the
policy π which takes action at given state st at timestep t.

2.2. Two-player zero-sum discounted games

The adversarial setting we propose can be expressed as a
two player γ discounted zero-sum Markov game (Littman,
1994; Perolat et al., 2015). This game MDP can be ex-
pressed as the tuple: (S, A1, A2, P, r, γ, s0) where A1 and
A2 are the continuous set of actions the players can take.
P : S ×A1 ×A2 ×S → R is the transition probability den-
sity and r : S ×A1 ×A2 → R is the reward of both players.
If player 1 (protagonist) is playing strategy µ and player 2
(adversary) is playing the strategy ν, the reward function
is rµ,ν = Ea1∼µ(.|s),a2∼ν(.|s)[r(s, a1, a2)]. A zero-sum
two-player game can be seen as player 1 maximizing the
γ discounted reward while player 2 is minimizing it.

3. Robust Adversarial RL

3.1. Robust Control via Adversarial Agents

Our goal is to learn the policy of the protagonist (denoted
by µ) such that it is better (higher reward) and robust (gen-
eralizes better to variations in test settings). In the standard
reinforcement learning setting, for a given transition func-
tion P, we can learn policy parameters θµ such that the
expected reward is maximized where expected reward for
policy µ from the start s0 is

ρ(µ; θµ, P) = E

γtr(st, at)|s0, µ, P

.

(1)

(cid:35)

(cid:34) T

(cid:88)

t=0

Note that in this formulation the expected reward is con-
ditioned on the transition function since the the transition
function deﬁnes the roll-out of states. In standard-RL set-
tings, the transition function is ﬁxed (since the physics en-
gine and parameters such as mass, friction are ﬁxed). How-
ever, in our setting, we assume that the transition function
will have modeling errors and that there will be differences
between training and test conditions. Therefore, in our gen-
eral setting, we should estimate policy parameters θµ such
that we maximize the expected reward over different possi-

ρ(µ; θµ) = E
P

(cid:34)

E

(cid:34) T

(cid:88)

t=0

γtr(st, at)|s0, µ, P

.

(2)

(cid:35)(cid:35)

Optimizing for the expected reward over all transition func-
tions optimizes mean performance, which is a risk neutral
formulation that assumes a known distribution over model
parameters. A large fraction of policies learned under such
a formulation are likely to fail in a different environment.
Instead, inspired by work in robust control (Tamar et al.,
2014; Rajeswaran et al., 2016), we choose to optimize for
conditional value at risk (CVaR):

ρRC = E [ρ|ρ ≤ Qα(ρ)]

(3)

where Qα(ρ) is the α-quantile of ρ-values. Intuitively, in
robust control, we want to maximize the worst-possible ρ-
values. But how do you tractably sample trajectories that
are in worst α-percentile? Approaches like EP-Opt (Ra-
jeswaran et al., 2016) sample these worst percentile trajec-
tories by changing parameters such as friction, mass of ob-
jects, etc. during rollouts.

Instead, we introduce an adversarial agent that applies
forces on pre-deﬁned locations, and this agent tries to
change the trajectories such that reward of the protago-
nist is minimized. Note that since the adversary tries to
minimize the protagonist’s reward, it ends up sampling tra-
jectories from worst-percentile leading to robust control-
learning for the protagonist. If the adversary is kept ﬁxed,
the protagonist could learn to overﬁt to its adversarial ac-
tions. Therefore, instead of using either a random or a
ﬁxed-adversary, we advocate generating the adversarial ac-
tions using a learned policy ν. We would also like to point
out the connection between our proposed approach and the
practice of hard-example mining (Sung & Poggio, 1994;
Shrivastava et al., 2016). The adversary in RARL learns to
sample hard-examples (worst-trajectories) for the protag-
onist to learn. Finally, instead of using α as percentile-
parameter, RARL is parameterized by the magnitude of
force available to the adversary. As the adversary becomes
stronger, RARL optimizes for lower percentiles. However,
very high magnitude forces lead to very biased sampling
and make the learning unstable. In the extreme case, an un-
reasonably strong adversary can always prevent the protag-
onist from achieving the task. Analogously, the traditional
RL baseline is equivalent to training with an impotent (zero
strength) adversary.

3.2. Formulating Adversarial Reinforcement Learning

In our adversarial game, at every timestep t both play-
ers observe the state st and take actions a1
t ∼ µ(st) and
a2
t ∼ ν(st). The state transitions st+1 = P(st, a1
t , a2
t )

Robust Adversarial Reinforcement Learning

and a reward rt = r(st, a1
t , a2
t ) is obtained from the en-
vironment. In our zero-sum game, the protagonist gets a
reward r1
t =
−rt. Hence each step of this MDP can be represented as
(st, a1

t = rt while the adversary gets a reward r2

t , st+1).

t , a2

t , r2

t , r1

The protagonist seeks to maximize the following reward
function,

R1 = Es0∼ρ,a1∼µ(s),a2∼ν(s)[

r1(s, a1, a2)].

(4)

T −1
(cid:88)

t=0

Since, the policies µ and ν are the only learnable compo-
nents, R1 ≡ R1(µ, ν). Similarly the adversary attempts to
maximize its own reward: R2 ≡ R2(µ, ν) = −R1(µ, ν).
One way to solve this MDP game is by discretizing the
continuous state and action spaces and using dynamic pro-
gramming to solve. Perolat et al. (2015) and Patek (1997)
show that notions of minimax equilibrium and Nash equi-
librium are equivalent for this game with optimal equilib-
rium reward:

R1∗ = min

max
µ

ν

R1(µ, ν) = max

min
ν

µ

R1(µ, ν)

(5)

However solutions to ﬁnding the Nash equilibria strategies
often involve greedily solving N minimax equilibria for a
zero-sum matrix game, with N equal to the number of ob-
served datapoints. The complexity of this greedy solution
is exponential in the cardinality of the action spaces, which
makes it prohibitive (Perolat et al., 2015).

Most Markov Game approaches require solving for the
equilibrium solution for a multiplayer value or minimax-Q
function at each iteration. This requires evaluating a typ-
ically intractable minimax optimization problem. Instead,
we focus on learning stationary policies µ∗ and ν∗ such that
R1(µ∗, ν∗) → R1∗. This way we can avoid this costly op-
timization at each iteration as we just need to approximate
the advantage function and not determine the equilibrium
solution at each iteration.

3.3. Proposed Method: RARL

Our algorithm (RARL) optimizes both of the agents using
the following alternating procedure. In the ﬁrst phase, we
learn the protagonist’s policy while holding the adversary’s
policy ﬁxed. Next, the protagonist’s policy is held constant
and the adversary’s policy is learned. This sequence is re-
peated until convergence.

Algorithm 1 outlines our approach in detail. The initial pa-
rameters for both players’ policies are sampled from a ran-
dom distribution. In each of the Niter iterations, we carry
out a two-step (alternating) optimization procedure. First,
for Nµ iterations, the parameters of the adversary θν are
held constant while the parameters θµ of the protagonist

Algorithm 1 RARL (proposed algorithm)

Input: Environment E; Stochastic policies µ and ν
Initialize: Learnable parameters θµ
for i=1,2,..Niter do

0 for µ and θν

0 for ν

t , r2i

t , a2i

i ← θµ
θµ
i−1
for j=1,2,..Nµ do
{(si
t , r1i
t, a1i
θµ
i ← policyOptimizer({(si
end for
i ← θν
θν
i−1
for j=1,2,..Nν do
{(si
t , r1i
t, a1i
θν
i ← policyOptimizer({(si
end for

t , a2i

t , r2i

end for
Return: θµ

, θν

Niter

Niter

t )} ← roll(E, µθµ
t , r1i
t, a1i

, Ntraj)
, νθν
t )}, µ, θµ
i )

i−1

i

t )} ← roll(E, µθµ
t , r2i
t, a2i

, Ntraj)
, νθν
t )}, ν, θν
i )

i

i

t, a1i

are optimized to maximize R1 (Equation 4). The roll func-
tion samples Ntraj trajectories given the environment deﬁ-
nition E and the policies for both the players. Note that E
contains the transition function P and the reward functions
r1 and r2 to generate the trajectories. The tth element of
the ith trajectory is of the form (si
t ). These
trajectories are then split such that the tth element of the ith
trajectory is of the form (si
t, ai
t ). The pro-
tagonist’s parameters θµ are then optimized using a policy
optimizer. For the second step, player 1’s parameters θµ are
held constant for the next Nν iterations. Ntraj Trajectories
are sampled and split into trajectories such that tth element
of the ith trajectory is of the form (si
t ).
Player 2’s parameters θν are then optimized. This alternat-
ing procedure is repeated for Niter iterations.

t = a2i

t = a1i

t = r2i

t = r1i

t , a2i

t , r2i

t , r1i

t , ri

t , ri

t, ai

4. Experimental Evaluation

We now demonstrate the robustness of the RARL algo-
rithm: (a) for training with different initializations; (b) for
testing with different conditions; (c) for adversarial dis-
turbances in the testing environment. But ﬁrst we will
describe our implementation and test setting followed by
evaluations and results of our algorithm.

4.1. Implementation

Our implementation of the adversarial environments build
on OpenAI Gym’s (Brockman et al., 2016) control environ-
ments with the MuJoCo (Todorov et al., 2012) physics sim-
ulator. Details of the environments and their corresponding
adversarial disturbances are (also see Figure 1):

InvertedPendulum: The inverted pendulum is mounted
on a pivot point on a cart, with the cart restricted to lin-
ear movement in a plane. The state space is 4D: position

Robust Adversarial Reinforcement Learning

and both TRPO and RARL show similar performance and
similar rewards. As we can see from the ﬁgure, for all the
four tasks RARL learns a better policy in terms of mean
reward and variance as well. This clearly shows that the
policy learned by RARL is better than the policy learned
by TRPO even when there is no disturbance or change of
settings between training and test conditions. Table 1 re-
ports the average rewards with their standard deviations for
the best learned policy.

and velocity for both the cart and the pendulum. The pro-
tagonist can apply 1D forces to keep the pendulum upright.
The adversary applies a 2D force on the center of pendulum
in order to destabilize it.

HalfCheetah: The half-cheetah is a planar biped robot
with 8 rigid links, including two legs and a torso, along
with 6 actuated joints. The 17D state space includes joint
angles and joint velocities. The adversary applies a 6D ac-
tion with 2D forces on the torso and both feet in order to
destabilize it.

Swimmer: The swimmer is a planar robot with 3 links and
2 actuated joints in a viscous container, with the goal of
moving forward. The 8D state space includes joint angles
and joint velocities. The adversary applies a 3D force to
the center of the swimmer.

Hopper: The hopper is a planar monopod robot with 4
rigid links, corresponding to the torso, upper leg, lower leg,
and foot, along with 3 actuated joints. The 11D state space
includes joint angles and joint velocities. The adversary
applies a 2D force on the foot.

Walker2D: The walker is a planar biped robot consisting
of 7 links, corresponding to two legs and a torso, along with
6 actuated joints. The 17D state space includes joint angles
and joint velocities. The adversary applies a 4D action with
2D forces on both the feet.

Ant: The ant is a quadruped robot with a torso and 4 legs
that contain 8 joints. The 111D observation space includes
joint angles, joint velocities and contact forces. The adver-
sary applies a 8D action with 2D forces on each foot.

Our implementation of RARL is built on top of rllab (Duan
et al., 2016) and uses Trust Region Policy Optimization
(TRPO) (Schulman et al., 2015) as the policy optimizer.
For all the tasks and for both the protagonist and adversary,
we use a policy network with two hidden layers with 64
neurons each. We train both RARL and the baseline for
100 iterations on InvertedPendulum and for 500 iterations
on the other tasks. Hyperparameters of TRPO are selected
by grid search.

4.2. Evaluating Learned Policies

We evaluate the robustness of our RARL approach com-
pared to the strong TRPO baseline. Since our policies are
stochastic in nature and the starting state is also drawn from
a distribution, we learn 50 policies for each task with dif-
ferent seeds/initializations. First, we report the mean and
variance of cumulative reward (over 50 policies) as a func-
tion of the training iterations. Figure 2 shows the mean and
variance of the rewards of learned policies for the task of
HalfCheetah, Swimmer, Hopper and Walker2D. We omit
the graph for InvertedPendulum because the task is easy

Figure 2. Cumulative reward curves for RARL trained policies
versus the baseline (TRPO) when tested without any disturbance.
For all the tasks, RARL achieves a better mean than the base-
line. For tasks like Hopper, we also see a signiﬁcant reduction of
variance across runs.

However, the primary focus of this paper is to show robust-
ness in training these control policies. One way of visual-
izing this is by plotting the average rewards for the nth per-
centile of trained policies. Figure 3 plots these percentile
curves and highlight the signiﬁcant gains in robustness for
training for the HalfCheetah, Swimmer and Hopper tasks.

4.3. Robustness under Adversarial Disturbances

While deploying controllers in the real world, unmodeled
environmental effects can cause controllers to fail. One
way of measuring robustness to such effects is by measur-
ing the performance of our learned control polices in the
presence of an adversarial disturbance. For this purpose,
we train an adversary to apply a disturbance while holding
the protagonist’s policy constant. We again show the per-
centile graphs as described in the section above. RARL’s
control policy, since it was trained on similar adversaries,
performs better, as seen in Figure 4.

Baseline (TRPO)RARLSwimmerHalfCheetah00100200300400500100020003000400050006000IterationsReward050100150200250300350400Hopper05001000150020002500300035004000RewardRewardWalker2d0100020003000400050006000RewardIterationsIterationsIterations010020030040050001002003004005000100200300400500Robust Adversarial Reinforcement Learning

Table 1. Comparison of the best policy learned by RARL and the baseline (mean±one standard deviation)
Ant
5299 ± 91
5482 ± 28

InvertedPendulum HalfCheetah
5093 ± 44
5444 ± 97

Hopper
3614 ± 2.16
3590 ± 7.4

Walker2d
5418 ± 87
5854 ± 159

Swimmer
358 ± 2.4
354 ± 1.5

1000 ± 0.0
1000 ± 0.0

Baseline
RARL

4.4. Robustness to Test Conditions

Finally, we evaluate the robustness and generalization of
the learned policy with respect to varying test conditions.
In this section, we train the policy based on certain mass
and friction values; however at test time we evaluate the
policy when different mass and friction values are used in
the environment. Note we omit evaluation of Swimmer
since the policy for the swimming task is not signiﬁcantly
impacted by a change mass or friction.

4.4.1. EVALUATION WITH CHANGING MASS

We describe the results of training with the standard mass
variables in OpenAI Gym while testing it with differ-
ent mass. Speciﬁcally, the mass of InvertedPendulum,
HalfCheetah, Hopper and Walker2D were 4.89, 6.36, 3.53
and 3.53 respectively. At test time, we evaluated the
learned policies by changing mass values and estimating
the average cumulative rewards. Figure 5 plots the average
rewards and their standard deviations against a given torso
mass (horizontal axis). As seen in these graphs, RARL
policies generalize signiﬁcantly better.

Figure 3. We show percentile plots without any disturbance to
show the robustness of RARL compared to the baseline. Here
the algorithms are run on multiple initializations and then sorted
to show the nth percentile of cumulative ﬁnal reward.

Figure 4. Percentile plots with a learned adversarial distur-
bance show the robustness of RARL compared to the baseline
in the presence of an adversary. Here the algorithms are run on
multiple initializations followed by learning an adversarial distur-
bance that is applied at test time.

Figure 5. The graphs show robustness of RARL policies to
changing mass between training and testing. For the Inverted-
Pendulum the mass of the pendulum is varied, while for the other
tasks, the mass of the torso is varied. We exclude the results of
Ant since it’s policies aren’t signiﬁcantly affected by changing
mass.

Baseline (TRPO)RARLSwimmerHalfCheetah0020406080100100020003000400050006000PercentileReward0020406080100Percentile50100150200250300350400Hopper020406080100Percentile05001000150020002500300035004000RewardRewardWalker2d0020406080100Percentile100020003000400050006000RewardBaseline (TRPO)RARLSwimmerHalfCheetah0020406080100100020003000400050006000PercentileReward0020406080100Percentile50100150200250300350400Hopper020406080100PercentileRewardRewardWalker2d0020406080100Percentile100020003000400050006000Reward10002000300040000Baseline (TRPO)RARLInvertedPendulumHalfCheetah005010015020025020040060080010001200Mass of pendulumReward0345678Mass of torsoHopper2.02.53.03.54.04.5Mass of torso05001000150020002500300035004000RewardRewardWalker2d0012345Mass of torso100020003000400050006000Reward1000200030004000500060003009105.0678Robust Adversarial Reinforcement Learning

4.4.2. EVALUATION WITH CHANGING FRICTION

Since several of the control tasks involve contacts and fric-
tion (which is often poorly modeled), we evaluate robust-
ness to different friction coefﬁcients in testing. Similar to
the evaluation of robustness to mass, the model is trained
with the standard variables in OpenAI Gym. Figure 6
shows the average reward values with different friction co-
efﬁcients at test time. It can be seen that the baseline poli-
cies fail to generalize and the performance falls signiﬁ-
cantly when the test friction is different from training. On
the other hand RARL shows more resilience to changing
friction values.

Figure 7. The heatmaps show robustness of RARL policies to
changing both friction and mass between training and testing. For
both the tasks of Hopper and HalfCheetah, we observe a signiﬁ-
cant increase in robustness.

cart to stabilize the pole.

Figure 6. The graphs show robustness of RARL policies to
changing friction between training and testing. Note that we ex-
clude the results of InvertedPendulum and the Swimmer because
friction is not relevant to those tasks.

We visualize the increased robustness of RARL in Fig-
ure 7, where we test with jointly varying both mass and
friction coefﬁcient. As observed from the ﬁgure, for most
combinations of mass and friction values RARL leads sig-
niﬁcantly higher reward values compared to the baseline.

4.5. Visualizing the Adversarial Policy

Finally, we visualize the adversarial policy for the case of
InvertedPendulum and Hopper to see whether the learned
policies are human interpretable. As shown in Figure 8,
the direction of the force applied by the adversary agrees
with human intuition: speciﬁcally, when the cart is station-
ary and the pole is already tilted (top row), the adversary
attempts to accentuate the tilt. Similarly, when the cart is
moving swiftly and the pole is vertical (bottom row), the
adversary applies a force in the direction of the cart’s mo-
tion. The pole will fall unless the cart speeds up further
(which can also cause the cart to go out of bounds). Note
that the naive policy of pushing in the opposite direction
would be less effective since the protagonist could slow the

Figure 8. Visualization of forces applied by the adversary on In-
vertedPendulum. In (a) and (b) the cart is stationary, while in (c)
and (d) the cart is moving with a vertical pendulum.

Similarly for the Hopper task in Figure 9, the adversary ap-
plies horizontal forces to impede the motion when the Hop-
per is in the air (left) while applying forces to counteract
gravity and reduce friction when the Hopper is interacting
with the ground (right).

5. Related Research

Recent applications of deep reinforcement learning (deep
RL) have shown great success in a variety of tasks rang-

Baseline (TRPO)RARLHalfCheetah0.200.30.40.50.60.7100020003000400050006000Friction coefficientRewardHopperFriction coefficient05001000150020002500300035004000RewardWalker2d0Friction coefficient100020003000400050006000Reward0.80.40.60.81.01.21.41.60.50.60.70.80.91.01.41.11.21.3Ant01000200030004000500060000.60.81.01.21.4Friction coefficientRewardHalfCheetahHopperBaseline (TRPO)RARL0.20.350.50.65Friction coefficient0.86.03.09.04.57.5Mass of torso0.20.350.50.65Friction coefficient0.86.03.09.04.57.5Mass of torso0.70.851.01.15Friction coefficient1.33.52.54.53.04.0Mass of torso0.70.851.01.15Friction coefficient1.33.52.54.53.04.0Mass of torso200032004000480060003600400200028001800(a)(b)(c)(d)adversarial disturbancecart velocityRobust Adversarial Reinforcement Learning

the game optimization problem. Sharma & Gopal (2007)
extend the Markov game formulation using a trained neu-
ral network for the policy and approximating the game to
continue using LP to solve the game. Wiesemann et al.
(2013) present an enhancement to standard MDP that pro-
vides probabilistic guarantees to unknown model parame-
ters. Other approaches are risk-based including Tamar et al.
(2014) and Delage & Mannor (2010), which formulate var-
ious mechanisms of percentile risk into the formulation.
Our approach focuses on continuous space problems and
is a model-free approach that requires explicit parametric
formulation of model uncertainty.

Adversarial methods have been used in other learning prob-
lems including Goodfellow et al. (2015), which leverages
adversarial examples to train a more robust classiﬁers and
Goodfellow et al. (2014); Dumoulin et al. (2016), which
uses an adversarial loss function for a discriminator to train
a generative model. In Pinto et al. (2017) two supervised
agents were trained with one acting as an adversary for self-
supervised learning which showed improved robot grasp-
ing. Other adversarial multiplayer approaches have been
proposed including Heinrich & Silver (2016) to perform
self-play or ﬁctitious play. Refer to Bus¸oniu et al. (2010)
for an review of multiagent RL techniques.

Recent deep RL approaches to the problem focus on ex-
plicit parametric model uncertainty. Heess et al. (2015)
use recurrent neural networks to perform direct adaptive
control. Indirect adaptive control was applied in Yu et al.
(2017) for online parameter identiﬁcation. Rajeswaran
et al. (2016) learn a robust policy by sampling the worst
case trajectories from a class of parametrized models, to
learn a robust policy.

6. Conclusion

We have presented a novel adversarial reinforcement learn-
ing framework, RARL, that is: (a) robust to training ini-
tializations; (b) generalizes better and is robust to environ-
mental changes between training and test conditions; (c)
robust to disturbances in the test environment that are hard
to model during training. Our core idea is that modeling
errors should be viewed as extra forces/disturbances in the
system. Inspired by this insight, we propose modeling un-
certainties via an adversary that applies disturbances to the
system. Instead of using a ﬁxed policy, the adversary is re-
inforced and learns an optimal policy to optimally thwart
the protagonist. Our work shows that the adversary effec-
tively samples hard examples (trajectories with worst re-
wards) leading to a more robust control strategy.

ACKNOWLEDGEMENTS: This work was supported
by ONR MURI, NSF IIS-1320083 and Google Focused
Award. AG was supported by Sloan Research Fellowship.

Figure 9. Visualization of forces applied by the adversary on Hop-
per. On the left, the Hopper’s foot is in the air while on the right
the foot is interacting with the ground.

ing from games (Mnih et al., 2015; Silver et al., 2016),
robot control (Gu et al., 2016; Lillicrap et al., 2015; Mor-
datch et al., 2015), to meta learning (Zoph & Le, 2016). An
overview of recent advances in deep RL is presented in Li
(2017) and Kaelbling et al. (1996); Kober & Peters (2012)
provide a comprehensive history of RL research.

Learned policies should be robust to uncertainty and pa-
rameter variation to ensure predicable behavior, which is
essential for many practical applications of RL includ-
ing robotics. Furthermore, the process of learning poli-
cies should employ safe and effective exploration with im-
proved sample efﬁciency to reduce risk of costly failure.
These issues have long been recognized and investigated
in reinforcement learning (Garcıa & Fern´andez, 2015) and
have an even longer history in control theory research
(Zhou & Doyle, 1998). These issues are exacerbated in
deep RL by using neural networks, which while more ex-
pressible and ﬂexible, often require signiﬁcantly more data
to train and produce potentially unstable policies.

In terms of taxonomy (Garcıa & Fern´andez, 2015), our
approach lies in the class of worst-case formulations.
We model the problem as an H∞ optimal control prob-
lem (Bas¸ar & Bernhard, 2008).
In this formulation, na-
ture (which may represent input, transition or model uncer-
tainty) is treated as an adversary in a continuous dynamic
zero-sum game. We attempt to ﬁnd the minimax solution to
the reward optimization problem. This formulation was in-
troduced as robust RL (RRL) in Morimoto & Doya (2005).
RRL proposes a model-free actor-disturber-critic method.
Solving for the optimal strategy for general nonlinear sys-
tems is often analytically infeasible for most problems. To
address this, we extend RRL’s model-free formulation us-
ing deep RL via TRPO (Schulman et al., 2015) with neural
networks as the function approximator.

Other worst-case formulations have been introduced.
Nilim & El Ghaoui (2005) solve ﬁnite horizon tabular
MDPs using a minimax form of dynamic programming.
Using a similar game theoretic formulation Littman (1994)
introduces the notion of a Markov Game to solve tabu-
lar problems, which involves linear program (LP) to solve

adversarial disturbanceRobust Adversarial Reinforcement Learning

References

Bas¸ar, Tamer and Bernhard, Pierre. H-inﬁnity optimal con-
trol and related minimax design problems: a dynamic
game approach. Springer Science & Business Media,
2008.

Brockman, Greg, Cheung, Vicki, Pettersson, Ludwig,
Schneider, Jonas, Schulman, John, Tang, Jie, and
arXiv preprint
Zaremba, Wojciech. OpenAI gym.
arXiv:1606.01540, 2016.

Bus¸oniu, Lucian, Babuˇska, Robert, and De Schutter, Bart.
Multi-agent reinforcement learning: An overview. In In-
novations in multi-agent systems and applications-1, pp.
183–221. Springer, 2010.

Christiano, Paul, Shah, Zain, Mordatch, Igor, Schneider,
Jonas, Blackwell, Trevor, Tobin, Joshua, Abbeel, Pieter,
and Zaremba, Wojciech. Transfer from simulation to real
world through learning deep inverse dynamics model.
arXiv preprint arXiv:1610.03518, 2016.

Delage, Erick and Mannor, Shie. Percentile optimization
for Markov decision processes with parameter uncer-
tainty. Operations research, 58(1):203–213, 2010.

Duan, Yan, Chen, Xi, Houthooft, Rein, Schulman, John,
and Abbeel, Pieter. Benchmarking deep reinforcement
In Proceedings of the
learning for continuous control.
33rd International Conference on Machine Learning
(ICML), 2016.

Dumoulin, Vincent, Belghazi, Ishmael, Poole, Ben, Lamb,
Alex, Arjovsky, Martin, Mastropietro, Olivier, and
Courville, Aaron. Adversarially learned inference. arXiv
preprint arXiv:1606.00704, 2016.

Erez, Tom, Tassa, Yuval, and Todorov, Emanuel. Inﬁnite
horizon model predictive control for nonlinear periodic
tasks. Manuscript under review, 4, 2011.

Garcıa, Javier and Fern´andez, Fernando. A comprehensive
survey on safe reinforcement learning. Journal of Ma-
chine Learning Research, 16(1):1437–1480, 2015.

Goodfellow, Ian, Pouget-Abadie, Jean, Mirza, Mehdi, Xu,
Bing, Warde-Farley, David, Ozair, Sherjil, Courville,
Aaron, and Bengio, Yoshua. Generative adversarial nets.
In Neural Information Processing Systems (NIPS), 2014.

Goodfellow, Ian J, Shlens, Jonathon, and Szegedy, Chris-
tian. Explaining and harnessing adversarial examples.
International Conference on Learning Representations
(ICLR), 2015.

Gu, Shixiang, Lillicrap, Timothy, Sutskever,

and Levine, Sergey.
with model-based acceleration.
arXiv:1603.00748, 2016.

Ilya,
Continuous deep Q-learning
arXiv preprint

Heess, Nicolas, Hunt, Jonathan J, Lillicrap, Timothy P,
and Silver, David. Memory-based control with recur-
rent neural networks. arXiv preprint arXiv:1512.04455,
2015.

Heinrich, Johannes and Silver, David. Deep reinforcement
learning from self-play in imperfect-information games.
arXiv preprint arXiv:1603.01121, 2016.

Kaelbling, Leslie Pack, Littman, Michael L, and Moore,
Andrew W. Reinforcement learning: A survey. Journal
of artiﬁcial intelligence research, 4:237–285, 1996.

Kakade, Sham. A natural policy gradient. Advances in neu-
ral information processing systems, 2:1531–1538, 2002.

Kober, Jens and Peters, Jan. Reinforcement learning in
robotics: A survey. In Reinforcement Learning, pp. 579–
610. Springer, 2012.

Li, Yuxi. Deep reinforcement learning: An overview. arXiv

preprint arXiv:1701.07274, 2017.

Lillicrap, Timothy P, Hunt, Jonathan J, Pritzel, Alexander,
Heess, Nicolas, Erez, Tom, Tassa, Yuval, Silver, David,
and Wierstra, Daan. Continuous control with deep re-
inforcement learning. arXiv preprint arXiv:1509.02971,
2015.

Littman, Michael L. Markov games as a framework for
In Proceedings of
multi-agent reinforcement learning.
the eleventh international conference on machine learn-
ing, volume 157, pp. 157–163, 1994.

Mnih, Volodymyr et al. Human-level control through deep
reinforcement learning. Nature, 518(7540):529–533,
2015.

Mordatch, Igor, Lowrey, Kendall, Andrew, Galen, Popovic,
Zoran, and Todorov, Emanuel V. Interactive control of
diverse complex characters with neural networks. In Ad-
vances in Neural Information Processing Systems, pp.
3132–3140, 2015.

Morimoto, Jun and Doya, Kenji. Robust reinforcement
learning. Neural computation, 17(2):335–359, 2005.

Nilim, Arnab and El Ghaoui, Laurent. Robust control of
Markov decision processes with uncertain transition ma-
trices. Operations Research, 53(5):780–798, 2005.

Patek, Stephen David. Stochastic and shortest path games:
theory and algorithms. PhD thesis, Massachusetts Insti-
tute of Technology, 1997.

Perolat, Julien, Scherrer, Bruno, Piot, Bilal, and Pietquin,
Olivier. Approximate dynamic programming for two-
player zero-sum games. In ICML, 2015.

Robust Adversarial Reinforcement Learning

Pinto, Lerrel, Davidson, James, and Gupta, Abhinav. Su-
pervision via competition: Robot adversaries for learn-
ing tasks. ICRA, 2017.

Zoph, Barret and Le, Quoc V.

search with reinforcement learning.
arXiv:1611.01578, 2016.

Neural architecture
arXiv preprint

Rajeswaran, Aravind, Ghotra, Sarvjeet, Ravindran, Balara-
man, and Levine, Sergey. EPOpt: Learning robust neural
network policies using model ensembles. arXiv preprint
arXiv:1610.01283, 2016.

Rusu, Andrei A, Vecerik, Matej, Roth¨orl, Thomas, Heess,
Nicolas, Pascanu, Razvan, and Hadsell, Raia. Sim-to-
real robot learning from pixels with progressive nets.
arXiv preprint arXiv:1610.04286, 2016.

Schulman, John, Levine, Sergey, Moritz, Philipp, Jordan,
Michael I, and Abbeel, Pieter. Trust region policy opti-
mization. CoRR, abs/1502.05477, 2015.

Sharma, Rajneesh and Gopal, Madan. A robust Markov
game controller for nonlinear systems. Applied Soft
Computing, 7(3):818–827, 2007.

Shrivastava, Abhinav, Gupta, Abhinav, and Girshick,
Ross B. Training region-based object detectors with on-
line hard example mining. CoRR, abs/1604.03540, 2016.

Silver, David et al. Mastering the game of Go with deep
neural networks and tree search. Nature, 529(7587):
484–489, 2016.

Sung, K. and Poggio, T. Learning and example selection
for object and pattern detection. MIT A.I. Memo, 1521,
1994.

Tamar, Aviv, Glassner, Yonatan, and Mannor, Shie. Op-
arXiv preprint

timizing the CVaR via sampling.
arXiv:1404.3862, 2014.

Todorov, Emanuel, Erez, Tom, and Tassa, Yuval. Mujoco:
In Intelli-
A physics engine for model-based control.
gent Robots and Systems (IROS), 2012 IEEE/RSJ Inter-
national Conference on, pp. 5026–5033. IEEE, 2012.

Wiesemann, Wolfram, Kuhn, Daniel, and Rustem, Berc¸.
Robust Markov decision processes. Mathematics of Op-
erations Research, 38(1):153–183, 2013.

Williams, Ronald J. Simple statistical gradient-following
learning.

algorithms for connectionist reinforcement
Machine learning, 8(3-4):229–256, 1992.

Yu, Wenhao, Liu, C. Karen, and Turk, Greg. Preparing for
the unknown: Learning a universal policy with online
system identiﬁcation. arXiv preprint arXiv:1702.02453,
2017.

Zhou, Kemin and Doyle, John Comstock. Essentials of
robust control, volume 104. Prentice hall Upper Saddle
River, NJ, 1998.

