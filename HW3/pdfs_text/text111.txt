Deep Tensor Convolution on Multicores

David Budden 1 Alexander Matveev 1 Shibani Santurkar 1 Shraman Ray Chaudhuri 1 Nir Shavit 1

Abstract

Deep convolutional neural networks (ConvNets)
of 3-dimensional kernels allow joint modeling of
spatiotemporal features. These networks have
improved performance of video and volumetric
image analysis, but have been limited in size due
to the low memory ceiling of GPU hardware. Ex-
isting CPU implementations overcome this con-
straint but are impractically slow. Here we ex-
tend and optimize the faster Winograd-class of
convolutional algorithms to the N -dimensional
case and speciﬁcally for CPU hardware. First,
we remove the need to manually hand-craft al-
gorithms by exploiting the relaxed constraints
and cheap sparse access of CPU memory. Sec-
ond, we maximize CPU utilization and multi-
core scalability by transforming data matrices to
be cache-aware, integer multiples of AVX vector
widths. Treating 2D ConvNets as a special case,
we demonstrate a 5 to 25-fold improvement in
throughput compared to previous state-of-the-art.

1. Introduction

Although convolutional neural networks (ConvNets) have
been successfully applied to solve non-trivial image pro-
cessing problems since the 1990s (LeCun et al., 1989;
2012),
their adoption as a de facto standard for im-
age classiﬁcation (Russakovsky et al., 2015) and seg-
mentation (Long et al., 2015) is due largely to recent
breakthroughs in network architecture. Beginning with
AlexNet in 2012 (Krizhevsky et al., 2012), the annual Im-
ageNet classiﬁcation challenge (ILSVRC) has been dom-
inated by progressively deeper networks with smaller ker-
nels (Szegedy et al., 2015; Simonyan & Zisserman, 2014b).
Recent solutions to the issues of vanishing and exploding
gradients (Glorot & Bengio, 2010) have allowed these net-
works to extend even deeper, with the ILSVRC15 winner
(ResNet (He et al., 2016)) being 8-fold deeper than VGG.

1Massachusetts Institute of Technology. Correspondence to:

David Budden <budden@csail.mit.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

It is easy to see why the “deeper is better” trend has led to
better performing ConvNets. Constructing even a modest
7 x 7 receptive ﬁeld with stacked k = 3 kernels requires
45% fewer parameters than a single kernel of size k = 7.
Intuitively it also captures a richer set of features due to ad-
ditional non-linearity. Recent studies have begun to formal-
ize the expressive power of deep versus shallow networks,
ﬁnding that classiﬁcation boundaries acquire local curva-
ture and expressivity as an exponential function of network
depth but not breadth (Poole et al., 2016). The only obvious
trade-off to this performance is the extra memory necessary
to store the intermediate activations in deeper networks.

Motivated by the success of these models in image pro-
cessing tasks, researchers have begun to investigate Con-
vNet applications in the video processing domain. Ex-
ample applications include video classiﬁcation (Karpathy
et al., 2014), segmentation (Couprie et al., 2013) and de-
noising (Shi et al., 2016b). An important observation
that has emerged from these studies is the importance of
3D convolutional primitives for modelling joint spatio-
temporal features; the na¨ıve application of traditional 2D
ConvNets frame-by-frame does not capture motion con-
tinuity or other rich temporal correlations (Ledig et al.,
2016; Tran et al., 2015). It is thus unsurprising that simple
3D ConvNets have yielded state-of-the-art performance on
video classiﬁcation benchmarks (Tran et al., 2015) and vol-
umetric image segmentation, e.g. tracing neurons between
electron microscopy samples (Lee et al., 2015).

Given the early success and conceptual simplicity of 3D
ConvNets, it is interesting to note that many popular deep
learning libraries (e.g. Caffe (Jia et al., 2014)) do not pro-
vide native support. One simple explanation is that these
libraries are optimized for execution on GPUs, and higher-
order convolutions require prohibitively large volumes of
data with respect to the 16 GB ceiling of today’s most ad-
vanced GPU hardware. These limitations are clear in pre-
vious studies, which either (a) limit the network size (Tran
et al., 2015), (b) down-sample images to lower resolu-
tion (Ji et al., 2013), or (c) include 3D primitives for only a
subset of network layers (Lee et al., 2015).

There are many potential options for circumventing the is-
sue of ConvNet memory usage. The ﬁrst is to split the
network across multiple GPUs, which requires the careful

Deep Tensor Convolution on Multicores

coordination of activation and gradient ﬂow (Dean et al.,
2012). Even in the case of the most successful distributed
frameworks for ConvNets (Abadi et al., 2016), GPU mem-
ory management is largely unresolved. The TensorFlow
authors propose two partial solutions warranting further in-
vestigation: (a) re-computing versus storing large tensors;
and (b) transferring long-lived tensors from GPU to host
CPU memory. Instead, we propose an alternative to hori-
zontal scalability for overcoming GPU memory constraints
– a fast implementation of N -dimension convolution op-
timized for multicore CPU systems, which have access to
practically unbounded memory on a single node.

2. Prior Art

Algorithms for fast convolution have existed in signal pro-
cessing literature since the 1980s (Winograd, 1980). The
general recipe is to transform both data and kernel into
a new space, where expensive sliding window-style con-
volutions reduce to cheaper element-wise products. The
ﬁrst examples of this approach in ConvNet literature in-
volved Fast Fourier Transforms (FFTs) exploiting the con-
volution theorem (Mathieu et al., 2013; Vasilache et al.,
2014). More recently, Lavin and Gray have pioneered
the use of the more general class of Winograd-style al-
gorithms (Lavin & Gray, 2016; Winograd, 1980). Their
implementation and its cuDNN derivatives (Chetlur et al.,
2014) have produced state-of-the-art GPU performance on
deep networks of small kernels. In this Section we provide
a brief overview of the theory underlying this approach, fo-
cusing on the aspects that are important for exploiting the
architecture of multicore CPUs.

2.1. Fast Vector Convolution

Consider the 1-dimension convolution s = g ∗d, where the
kernel and data vectors are of length G and D. This prob-
lem can be rephrased as one of polynomial multiplication
by introducing the associated polynomials d(x), g(x) and
s(x) = g(x)d(x), where the coefﬁcients si = (cid:80)
k gi−kdk
of xi are the solution to the desired convolution. This com-
putation can be distributed across a set of efﬁcient local
computations by considering the Chinese Remainder The-
orem (CRT) (Ding et al., 1996), as summarized in Theorem
1. By observing that s(x) = [g(x)d(x)] mod m(x) for any
polynomial m(x) of sufﬁciently high degree, we can ex-
ploit Theorem 1 to efﬁciently calculate s(x), as shown in
Algorithm 1, which can be conveniently rephrased in terms
matrix-vector products:

s = A [ (Cg) (cid:12) (Bd) ] ,

(1)

where C, B and A are introduced as the kernel, data and
inverse transforms respectively. With respect to Algorithm
1, Step (1) is implemented by the kernel and data trans-

forms, Step (2) by their transformed element-wise product
and Step (3) by the ﬁnal inverse transform.

Theorem 1 (CRT for Polynomials)
Let m(x) = Πr
k=1m(k)(x), where m(k)(x) are pairwise
coprime. If b(1)(x), ..., b(r)(x) are a set of polynomials then
there must exist a unique polynomial s(x) which satisﬁes
the set of congruences:

s(x) ≡ b(1)(x) mod m(1)(x)
s(x) ≡ b(2)(x) mod m(2)(x)

...

s(x) ≡ b(r)(x) mod m(r)(x),

provided the degree of m(x) is not less than that of s(x).

Algorithm 1 Fast Vector Convolution

Input: g(x), d(x), m(x)
for k = 1 to r do

(1) Compute residual polynomials for g(x) and d(x):

g(k)(x) ≡ g(x) mod m(k)(x)
d(k)(x) ≡ d(x) mod m(k)(x)

(2) Compute residual polynomial multiplications:

s(k)(x) =

(cid:105)
(cid:104)
g(k)(x)d(k)(x)

mod m(k)(x)

end for
(3) Reduce partial convolutions to solve s(x):

s(x) =

s(k)(x)a(k)(x)

r
(cid:88)

k=1

2.2. Minimal Winograd Algorithms

In the above formulation (1), the matrices C and B are the
remainders of the polynomial divisions g(x) and d(x) by
m(k)(x) respectively. The derivation of A is more involved
and is omitted for brevity. Importantly, the only parameter
required to synthesize these matrices (in addition to the ker-
nel g(x) and data d(x)) is the polynomial m(x).

Traditionally, the selection of m(x) has been subject to
many constraints. First, it should be chosen such that the
transform matrices contain only degree-1 (scalar) values.
Lavin has published code that automates this procedure us-
ing the Cook-Toom algorithm to produce transformed ker-
nels and data both of length D (Lavin, 2016). For an un-
padded convolution s = g ∗ d of length S = D − G + 1
and ignoring the cost of applying the transforms, this fast
algorithm therefore requires SG/D fewer computations to

Deep Tensor Convolution on Multicores

calculate than the standard sliding-window approach. Inap-
propriate selection of m(x) would yield matrices of poly-
nomials (degree > 1) that require considerably more scalar
multiplications to compute.

In reality, the transformations themselves require expensive
matrix multiplications that can outweigh the above saving.
Accordingly, existing implementations of fast convolution
aim to synthesize matrices enriched for “simple” (e.g. in-
teger) values. There are two motivations for this. First,
it improves numeric stability which can have an impact
on double-precision convolutions (Lavin & Gray, 2016).
More importantly, it supports the hand-crafting of minimal
algorithms. These algorithms reduce the cost of applying
transform matrices by identifying and eliminating redun-
dant sub-expressions. A famous instance of this approach
was documented by Winograd (Winograd, 1980). Consider
the following matrices:

A =

(cid:20)1 1
0
1
0 1 −1 −1

(cid:21)

B =


0
0 −1
1
0
1
0
1


1
0 −1
0

0 −1
1
0







C =

1
1
2
1








0
1
2

2 − 1
2
0
0








0
1
2
1
2
1

.

By substituting these matrices into (1) and factoring out re-
dundant computations, we arrive at the following minimal
algorithm for vector convolution:

d ∗ g =

(cid:34)

m1 + m2 + m3
m2 − m3 − m4

(cid:35)

,

where:

m1 = (d0 − d2)g0, m2 = (d1 + d2)

m4 = (d1 − d3)g2, m3 = (d2 − d1)

g0 + g1 + g2
2
g0 − g1 + g2
2

,

.

This is a so-called F (S, G) algorithm for vector convolu-
tion, here for S = 2 and G = 3. Importantly, this algo-
rithm only works for ﬁxed length kernel and data vectors
(here D = 4). Generating F (S, G) algorithms for different
combinations requires both (a) searching over the space of
possible m(x) polynomials as input to Lavin’s or similar
code (Lavin, 2016), and (b) reducing the matrix multiplica-
tions to a minimal set of addition, multiplication and shift-
ing operations. To our knowledge there are no automated
solutions to either step and thus only a small set of hand-
crafted Winograd-style algorithms (e.g. F (2, 3), F (3, 4)
and F (2, 5)) have been released as fast CPU (Dukhan,
2016) or GPU primitives (Chetlur et al., 2014).

3. Deep Tensor Convolution

Below we present an alternative approach to fast convo-
lution that removes the need to hand-craft minimal algo-
rithms. This new approach is better suited to video and
volumetric image processing for two main reasons. First,
the number of terms involved in a closed-form solution for
3 and higher-dimensional convolutions makes Winograd-
style refactoring impractical. Second, by removing nu-
meric simplicity as a constraint we are instead able to
synthesize transforms optimized to CPU architectural con-
straints, e.g. data that are integer multiples of the AVX
register width. This is made possible by the relaxed mem-
ory constraints of CPUs and allows us to close the previous
CPU-GPU performance gap by a full order-of-magnitude.

We ﬁrst deﬁne N -dimensional convolution and describe
how existing fast algorithms can be extended to this gen-
eral case. Instead of crafting a minimal algorithm, we show
how relaxed memory constraints and efﬁcient sparse linear
algebra of CPU systems can be leveraged to amortize trans-
form costs. Later we show how architecture-aware trans-
form synthesis can lead to further acceleration.

3.1. Convolution in N -Dimensions

Mathematically, the standard convolutional layer used in
2D ConvNets extends trivially to higher-dimensional ten-
sors. Consider a network where for each layer i, kernel j
and channel m, the kernel weights G(i,j,m) = (g p,q,r) and
resulting feature map D(i,j) = (d x,y,z) are both 3D ten-
sors. This calculation can be expressed element-wise as:

d (i+1,j)

x,y,z = f

b(i,j) +

p,q,r d (i, j)
g (i,j,m)

x+p, y+q, z+r

,

(cid:32)

(cid:88)

(cid:88)

m

p,q,r

(cid:33)

(2)
where b(i,j) is the bias term and f is a ReLU or other non-
linear activation function. This extends to higher dimen-
sions by looping over additional subscripts on g and d.

The dimensionality of feature maps is clearly preserved in
(2), e.g. a video at the input produces a video at the out-
put. The triple (p, q, r)-loop ranges from 0 to the layer-i
kernel size to perform sliding-window convolution, and the
m-loop is a reduction over the previous layer’s output chan-
nels. This differs from previous studies where the temporal
axis is encoded as network channels and ﬂattened after the
ﬁrst layer (Karpathy et al., 2014; Simonyan & Zisserman,
2014a), producing a single 2D image or class label at the
output. These methods have been shown to produce less
accurate results on a broad range of video processing tasks
when compared to true 3D ConvNets (Tran et al., 2015).

It is also evident from (2) why higher-dimensional Con-
vNets suffer from issues of impractical memory consump-
tion. Each layer of an N -dimensional network requires G

Deep Tensor Convolution on Multicores

and D to be stored as N +2 and N +1–dimensional tensors,
owing to their operation over multiple kernels and chan-
nels. We believe that this multiplicative effect has likely
stalled the adoption of the deeper network architectures that
dominate image processing tasks, with recent studies in-
stead compromising on network expressiveness to ﬁt within
the 16 GB memory constraints of today’s top-end GPUs (Ji
et al., 2013; Lee et al., 2015; Tran et al., 2015).

3.2. Accelerating Tensor Convolution

Sidestepping memory constraints by shifting from GPU
to CPU hardware is conceptually trivial, as most popu-
lar ConvNet frameworks support execution on both CPU
and GPU environments. However, the issue preventing the
widespread adoption of CPU implementations is not a lack
of software support but the large perceived gap between
CPU and GPU performance. This is reminiscent of a large
ongoing CPU-vs-GPU debate, with various studies claim-
ing that GPUs provide anywhere from 100-to-1000x speed-
up across broad problem domains (Lee et al., 2010). A re-
cent review has demonstrated a similar performance gap in
the order of 50x across the most popular ConvNet frame-
works (Shi et al., 2016a). Even if distributed GPU solu-
tions like TensorFlow require tensors to be re-computed
or swapped between GPU and host CPU memory (Abadi
et al., 2016), this overhead is easy to justify if the alterna-
tive is a 50-fold increase in single-node execution time.

Here we describe how fast algorithms for convolution can
be extended to the general case of N -dimensional tensors,
where the theoretical speed-up is a substantial (SG/D)N .
Although recent studies have begun to explore extensions
of FFT-based convolution to 3-dimensions (Zlateski et al.,
2016), to our knowledge there have been no attempts to
extend Lavin and Gray’s Winograd-style approach (Lavin
& Gray, 2016). In order to extend the fast vector algorithm
to 1 to N -dimensions, we consider the n-mode product of
a tensor, X ∈ RI1×I2×···×IN , with a matrix, U ∈ RJ×In ,
herein denoted as X ×n U (Kolda & Bader, 2009):

(X ×n U)i1,...,in−1,j,in+1,...,iN =

xi1,...,iN uj,in . (3)

In(cid:88)

in=1

In our case U is sparse and X is dense, so we implement
(3) such that U is traversed in the outermost two loops. We
also introduce the following notation for brevity:

X ×N

n=1 Un = X ×1 U1 ×2 · · · ×N UN .

The fast algorithm for tensor convolution applies the trans-
forms Cn, Bn and An separately to each dimension n of
the kernel and data tensors, G and D:

S = (cid:2) (G ×N

n=1 Cn) (cid:12) (D ×N

n=1 Bn) (cid:3) ×N

n=1 An.

(4)

It is straightforward to show that (1) is a special case of (4)
by considering the following equivalence:

Y = X ×n U ⇔ Y(n) = UX(n),

where the matrix X(n) is the mode-n major unfolding of
tensor X (Kolda & Bader, 2009).
In the 1-dimensional
case, X(1) is simply x and thus X ×1 U = Ux. Likewise
in 2D, as X ×1 U = UX and X ×2 U = UX(cid:62) then (4)
reduces to the case reported by (Lavin & Gray, 2016):

S = A (cid:2) (CGC(cid:62)) (cid:12) (BDB(cid:62)) (cid:3) A(cid:62).

3.3. Amortizing Transform Costs

Manually reducing transform costs via Winograd-style
minimal algorithms is important for 2-dimensional GPU
implementations. However, this is less important for a CPU
implementation of higher-dimensional convolution. The
reasons are two-fold: (a) the matrix multiplication cost can
be amortized across a larger number of kernels and chan-
nels due to relaxed memory constraints; and (b) CPUs are
able to directly leverage the sparse structure of these matri-
ces for further acceleration. Although efﬁcient sparse linear
algebra is possible on GPUs, this typically involves reshuf-
ﬂing sparse matrices into a dense representation (e.g. COO,
CSR or ELLPACK (Grewe & Lokhmotov, 2011)) and in-
troduces unnecessary computational overhead.

As a simple example, consider Winograd’s minimal F(2,3)
algorithm presented in Section 2.2. Computing the output
s of length S = 2 requires a total of 6 multiplications –
4 between the data and kernel, and 2 by a constant factor
of 0.5. The 4 additions are ignored as modern CPUs can
compute fused multiply-accumulate operations in a single
cycle. By contrast, computing s explicitly by equation (1)
requires 28 multiplications – 4 for the element-wise prod-
uct, 16 for the data transform and 8 for the inverse trans-
form (assuming transformed kernels are cached at training
time). Even leveraging sparsity in the transform matrices
requires 19 multiplications, which is more than triple that
required for Winograd’s minimal algorithm.

The game changes when one considers these approaches
in the context of a ConvNet layer with multiple channels
and kernels. Without loss of generality, assume the num-
bers of kernels and channels are both equal to M . As the
inverse transform can be applied once over the reduced out-
put and the data transform once across all kernels, the re-
quired number of multiplications is just 4M 2 + 24M (ver-
sus 6M 2 for Winograd). This can be reduced further to
4M 2 + 15M by exploiting the sparsity of A and B.

Although it is also possible to restructure Winograd’s al-
gorithm to exploit the size of the network, for larger net-
works the 4M 2 multiplications required by the element-
wise product quickly renders the linear transform cost neg-

Deep Tensor Convolution on Multicores

fast algorithm is best suited for networks of small kernels,
which is fortunately well-aligned with recent trends in deep
ConvNet architecture (He et al., 2016; Simonyan & Zisser-
man, 2014b; Szegedy et al., 2015). Sparsity and numeri-
cal precision also decrease as a function of D. In practice,
the data matrix D is not the full feature map (e.g. an Im-
ageNet image) but rather one of many small, overlapping
input tiles (each of size D × D, stepping by S along both
axes) whose S × S outputs are stitched together to form the
ﬁnal convolution result. In Section 4.2 we discuss how the
fully-automated nature of our implementation can leverage
this property for further performance improvement.

4. Optimizing for CPU Architecture

There are a myriad of algorithmic tricks that can be applied
to reduce the number of computations required for con-
volution. Consider the special case where our transforms
are the discrete Fourier transform (DFT) and inverse DFT
matrices. As the Fourier transform of a real-valued signal
has Hermitian symmetry, the number of unique terms in
the element-wise product can be reduced (Mathieu et al.,
2013). More generally, one could also apply the Strassen
algorithm to reduce the number of steps required for matrix
multiplication (Cong & Xiao, 2014).

In practice, the merit of any of these approaches depends
intimately on whether they can be implemented to effec-
tively leverage hardware. Consider the 50-to-1 perfor-
mance ratio observed between existing GPU and CPU im-
plementations (Shi et al., 2016a). For the devices used
in this study (Titan X versus Xeon E7-8890), the ratio of
theoretical throughput is actually less than to 5-to-1. This
seems to suggest that current CPU performance limitations
are largely issues of software rather than hardware.

Although some previous studies have discussed CPU-
speciﬁc performance optimizations
for neural net-
works (Vanhoucke et al., 2011), these guidelines have not
necessarily translated to optimal implementations. For
example, the Eigen 3.2 linear algebra library (used until
recently by TensorFlow) does not provide native support
for AVX (vectorized) instructions,
introducing a tight
bottleneck on theoretical throughput. Looking beyond a
single core, a recent review demonstrates poor multicore
scalability across all major ConvNet frameworks (Shi et al.,
2016a). Solving these two issues alone has the potential to
close the CPU-GPU gap by a full order-of-magnitude, and
this improvement is multiplicative with the algorithmic
savings described earlier.

4.1. Single-Core Utilization

Although our fast algorithm requires theoretically fewer
computations to execute than na¨ıve convolution (e.g. 8-fold

Figure 1. Reduction in computations achieved by fast tensor con-
volution (forward pass) for a C3D kernel (3 × 3 × 3) as a function
of number of layer channels and kernels. Dashed line indicates
direct convolution baseline.

ligible.
It is also impractical to construct similar mini-
mal algorithms in higher dimensions. Consider the C3D
network of 3 × 3 × 3 kernels that has yielded state-of-
the-art performance across many video processing bench-
marks (Tran et al., 2015). As an example, we synthesize the
following transform matrices such that convolution reduces
to a 6 × 6 × 6 element-wise product:

A =

B =

















1
9
1

1 1
1
0 1 −1
1
0 1
0 1 −1
1
0 − 10
9
9
0 − 1
9 − 1
9
− 1
1
0
9
9
0 − 1
3 −1
1
0
3
1
0
9

1
1
1
3 − 1

3

1
9







0
0
0
1

27



27 − 1
0
1 0
1
1 0


−1
1 0


1
1 0

3

−1 − 1
0
1

3
− 10
0
0
1
9
16 − 81
16 − 81
16 − 27
16 − 9

16 − 9

27
16

16

16

16

9

9

0
0
1

C =

16 − 9


9
0

0

9
16
9

9
16

(cid:62)





.

The theoretical ceiling on speed-up obtainable using these
matrices is 8-fold, ignoring the cost of the matrix-tensor
products required when applying (4). Figure 1 demon-
strates the actual reduction in computations as a function
of kernels and channels. For a network of just 100 kernels
and 100 channels, it is possible to obtain greater than 6-fold
acceleration with respect to direct sliding-window convo-
lution. This is triple the performance margin that could be
gained if the network was constrained to 10 kernels and
channels due to a lower memory ceiling.

We can further improve this performance margin by ex-
ploiting the sparsity of the matrices themselves, as it
is comparatively straightforward to implement efﬁcient
sparse linear algebra for CPUs. One might worry that the
transform matrix sparsity is inversely proportional to the
degree of m(x). However, this simply suggests that our

0246050100channelsspeed-up1 kernel10 kernels100 kernelskernels∞Deep Tensor Convolution on Multicores

Algorithm 2 N -Dimensional Convolution with SIMD

for i = 1 by W to DN do
for m = 1 to M do

FMA

(cid:16)
ˆs(i : i+W )
t, k

, ˆd(i : i+W )
t, m

, ˆg(i : i+W )
m, k

(cid:17)

end for

end for

for C3D kernels), it is considerably more difﬁcult to imple-
ment with high CPU utilization. Consider the element-wise
product G(cid:48) (cid:12) D(cid:48), summed for each channel m = 1 . . . , M
to produce the N -dimensional tensor S (cid:48). We can compute
the ratio of computations, i.e. 1 multiply and 1 accumulate
operation per (g, d)-pair, to the volume of memory loaded:

computations
memory accesses

=

2DN M
2DN M

= 1.

Little’s Law shows this is problematic for effective CPU
utilization, as convolution expressed in this form is bottle-
necked by memory bandwidth (Little, 1961). To solve this
problem, recall that D is one of many small, overlapping
tiles that span the full-size feature map. Considering T of
these tiles, we introduce the following matrices:

ˆS(i) = ˆD(i) × ˆG(i),

(5)

where ˆD(i) ∈ RT ×M (tiles-by-channels) and ˆG(i) ∈
RM ×K (channels-by-kernels). Each matrix i ∈ 1, . . . , DN
captures a single (x, y) coordinate in the earlier G(cid:48) (cid:12) D(cid:48)
element-wise product, which is fused with the channel-
wise reduction into end-to-end matrix multiplications:

computations
memory accesses

=

2DN M T K
DN (M T + M K)

=

2 T K
T + K

.

As T can be any number of the small DN input tiles, we
can select T = K to demonstrate a compute-to-memory
ratio that grows linearly in the number of kernels.

The fast convolutional form in (5) is also well-suited
to a number of other practical CPU performance opti-
mizations (Vanhoucke et al., 2011).
Foremost among
these is the effective use of AVX (vectorized) and FMA
(fused multiply-accumulate) ﬂoating-point SIMD opera-
tions. Consider the function FMA(x, y, z), which calcu-
lates the sum of vector x with the element-wise product
y (cid:12) z and stores the result in x, all in a single CPU cycle.
This function can be leveraged for an efﬁcient practical im-
plementation of (5), as presented in Algorithm 2 for a sin-
gle tile-kernel pair s(i)
t, k ∈ ˆS(i) and an AVX vector of width
W . An illustration of the 2-dimensional case is provided
in Figure 2. On our Xeon CPU with 256-bit AVX regis-
ters and two dedicated FMA units, this optimization alone
can yield a 32-fold speed-up over na¨ıve implementations.

Figure 2. Illustration of Algorithm 2 using 2-dimensional Con-
vNets as an example. Both the element-wise product G(cid:48) (cid:12) D(cid:48)
and reduction down M channels are captured within matrix mul-
tiplication. Multiple elements in ˆs t, k can be calculated simul-
taneously by ﬁlling AVX registers into-the-page. This technique
generalizes trivially to N -dimensions by substituting D2 for DN .

This margin is expected to double with the introduction of
512-bit AVX registers for Intel Skylake and Xeon Phi.

We benchmarked the performance of our fast convolution
algorithm on a 1.44 TFLOP/s Xeon E7-8890 CPU and ob-
serve that it executes at ∼70% maximum utilization. This
includes all steps from input to output, including all neces-
sary data reshufﬂing. As a point of comparison, Intel’s own
MKL convolutional primitive runs at just 20% (excluding
reshufﬂing) on the same processor. The Eigen 3.2. linear
algebra library is lower utilization still, capped at just 3.5%
due to a lack of AVX and FMA support. Both of these li-
braries have been widely used by popular ConvNet frame-
works including Caffe, CNTK, TensorFlow and Torch.

4.2. AVX-Aware Transform Synthesis

The fully automated nature of our transform generation al-
lows for the synthesis of transform matrices that optimize
for CPU architectural constraints. From Figure 2, it is clear
the full utilization can only be achieved if DN is an integer
multiple of the AVX vector width W . This is an important
optimization, as data volumes are constantly small (invari-
ant of numbers of channels and kernels) and thus there is
little opportunity to amortize padding overhead.

Table 1 summarizes statistics for example transforms that
we have generated for square 2 and 3-dimensional ker-
nels, enumerated automatically using (Lavin, 2016).
In
each case, we generate transforms for the smallest possible
D ∈ RD×D such that SG/D > 1 and D2 mod W = 0.
The matrices are provided in the Supplementary Materials.

4.3. Multicore Scalability

Single-core utilization is just one dimension of perfor-
mance optimization. Many modern systems contain both
multiple CPU chips, with shared access to host RAM; and
multiple cores per chip, with shared access to faster L3
cache. We adopt a relatively simple parallelization scheme
where threads simultaneously operate on different subsets

TMTMKKD2D2D2DˆGˆSˆreshuffle×=WDDDeep Tensor Convolution on Multicores

Table 1. Size, transform sparsity and algorithmic speed-up statis-
tics for example transforms matrices. Associated matrices are
provided in the Supplementary Materials.

size

D G S A
0.33
4
0.25
4
0.20
8
0.19
8
0.17
8

2
3
4
5
6

3
2
5
4
3

sparsity
B
0.50
0.50
0.31
0.31
0.31

D
0.25
0.33
0.19
0.20
0.21

speed-up
3D
2D
3.38
2.25
3.38
2.25
15.63
6.25
15.63
6.25
11.39
5.06

(a)
(b)
(c)
(d)
(e)

of T input tiles. To avoid memory contention and other
concurrency issues we adopt the Cilk Plus work-stealing
scheduler supported by GCC 4.8 (Blumofe et al., 1996; Ro-
bison, 2013), simply applying its fork-join primitive to all
for-loops with no iteration dependencies. The number of
tiles T per thread is empirically tuned to simultaneously
maximize L3 cache utilization (T cannot be too large) and
compute-to-memory ratio (T cannot be too small).

We observe that even this simple parallelization scheme
yields near-optimal linear scalability.
In Figure 3 we
present ConvNet throughput as a function of processor
cores for both (a) our fast algorithm, and (b) our own mul-
ticore implementation of na¨ıve convolution (which is com-
paratively simple to implement). Scalability is measured
across a single convolution layer for a 1024 × 1024 im-
age with kernels of size 4 × 4. To avoid NUMA issues
relating to expensive inter-chip communication, we spawn
independent instances for each CPU in our 4-socket shared-
memory server such that all 18 threads in Figure 3 are
bound to a single chip. When using all 18 cores of our
Intel Xeon E7-8890 CPU the scalability of (a) is 95% the-
oretically optimal. As a point of comparison, a recent re-
view examined the scalability of popular ConvNet frame-
works Caffe, CNTK, TensorFlow and Torch on a similar
16-core Xeon E5-2630 CPU (Shi et al., 2016a). They re-
ported multicore scalability ranging from 16% (Caffe) to
42% (TensorFlow), which is equivalent to a 2.3 to 5.9-fold
improvement with our implementation.

4.4. Performance Benchmarking

The most popular ConvNet benchmarks focus exclusively
on GPU performance (Chintala, 2015). The only study we
could ﬁnd presenting thorough CPU benchmarking is that
of Shi et al., comparing the throughput of Caffe, CNTK,
Tensorﬂow and Torch for the AlexNet and ResNet archi-
tectures (Shi et al., 2016a). Although this is a useful study
for ball-parking our multicore scalability, it is difﬁcult to
extrapolate fair comparisons to our overall system through-
put for many reasons. Foremost is that the authors do not
select CPU-optimized implementations. They adopt an ear-

Figure 3. Multicore scalability of our cache-aware and Cilk-
optimized implementations of (a) fast convolution, and (b) na¨ıve
convolution. Dashed line indicates theoretical scalability limit
with respect to a single-core implementation. Executed on 18-
core Intel Xeon E7-8890 processor with 45 MB L3-cache.

lier version of TensorFlow that uses the Eigen 3.2 library
(no AVX/FMA support), and otherwise use the default
framework-speciﬁc implementations of convolution rather
than linking to optimized packages such as Intel MKL.

We benchmark 2D ConvNet performance against two pop-
ular frameworks: TensorFlow, using the newer Eigen 3.3
library (with AVX support); and Caffe, compiled to use In-
tel’s optimized MKL library. We consider the propagation
time of a 224×224 ImageNet image through three convolu-
tion layers to capture any necessary inter-layer reshufﬂing.
We choose this simple architecture over a named network
because we are not interested in comparing execution times
of pooling, fully-connected or other layers. We also select
an obscure kernel size (4 × 4) for which there have been
no Winograd-style fast algorithms published, in order to
demonstrate the generality of our implementation to arbi-
trary kernels. Each layer contains a modest 32 channels
and 32 kernels for spreading the cost associated with ap-
plying transform matrices. Results presented are the fastest
across batch sizes of 1, 20 and 200. An important innova-
tion of our approach is that it is batch size-agnostic, making
it suitable for single-image autoregressive models common
in generative modelling and deep reinforcement learning.

Our performance benchmarks are presented in Figure 4.
The single-core throughput of (a) our fast algorithm is 0.89
MVox/s, compared to (b) 0.18 for TensorFlow and (c) 0.19
for Caffe. Increasing cores from 1 to 18, our throughput
improves to 10.9 MVox/s compared to 1.77 for TensorFlow
and 0.41 for Caffe. This is equivalent to an approximate 5
to 25-fold improvement in overall performance. In terms
of multicore scalability, this is (a) 68% versus (b) 55% and
(c) 12%. We note that our performance here is lower than
the 95% presented in Figure 3 for a larger input size (i.e. T
is much larger, yielding a better compute-to-memory ratio),

speed-upcores2468101214161842681012141618(a)(b)Deep Tensor Convolution on Multicores

et al., 2016b). Efﬁcient CPU implementations of ConvNets
and other deep learning algorithms will play a fundamental
role in this transition.

At the opposite end of the spectrum, some “big data”
problems in the image processing domain are, counter-
intuitively, too big to be solved in a distributed setting.
Consider the emerging ﬁeld of high-throughput connec-
tomics (Meirovitch et al., 2016). Multi-beam electron mi-
croscopes image cross-sectional slices of neural tissue at
nanometer-resolution, which are then segmented by Con-
vNets to reconstruct the 3-dimensional morphology and in-
terconnectivity of individual neurons (Ronneberger et al.,
2015). The major issue here is simply one of scale – a
seemingly modest cubic millimeter volume of neural tissue
takes several months to image at the TB/hr pace of mod-
ern electron microscopes, which exceeds maximum data
transfer rates. To avoid introducing communication bot-
tlenecks to the connectomics pipeline, it is necessary that
segmentation can execute in real-time on a server physi-
cally co-located in the same room as the microscope (Licht-
man et al., 2014; Matveev et al., 2017). Shared-memory
CPU systems can support hundreds of cores and terabytes
of memory in a single server, and it is critical that systems
be implemented to exploit these valuable resources.

Treating 2D ConvNets as a special case of tensor convo-
lution, our implementation yields 5 to 25-fold improved
throughput compared to previous state-of-the-art on CPU.
This is an important step toward bridging the performance
gap between CPU and GPU hardware and is particularly
important in the context of emerging hardware trends, e.g.
Intel announcing that future generations of CPUs will con-
tain dedicated deep learning accelerators. More impor-
tantly, we believe that removing constraints on 3D Con-
vNet size will herald new opportunities in the machine
learning community; particularly in the context of gen-
erative models (Denton et al., 2015; Goodfellow et al.,
2014), where rich temporal correlations are currently ig-
nored when learning latent manifolds (Ledig et al., 2016).

Acknowledgements

Support is gratefully acknowledged from the National Sci-
ence Foundation (NSF) under grants IIS-1447786 and
CCF-1563880, and the Intelligence Advanced Research
Projects Activity (IARPA) under grant 138076-5093555.

References

Abadi, Martın, Agarwal, Ashish, Barham, Paul, Brevdo,
Eugene, Chen, Zhifeng, Citro, Craig, Corrado, Greg S,
Davis, Andy, Dean, Jeffrey, Devin, Matthieu, et al. Ten-
sorﬂow: Large-scale machine learning on heterogeneous
distributed systems. arXiv preprint arXiv:1603.04467,

Figure 4. Measured throughput (megavoxels per second) of (a)
our fast 2D convolution implementation (as a special case of our
N -dimensional algorithm), (b) TensorFlow, using the latest Eigen
3.3, and (c) Caffe, using Intel MKL. Throughput is calculated by
propagating 224 × 224 images through 3 convolutional layers.

and that the scalability for TensorFlow and Caffe are both
similar to those reported in (Shi et al., 2016a).

5. Discussion

Motivated by the recent success of 3-dimensional Con-
vNets in video and volumetric image processing (Lee et al.,
2015; Tran et al., 2015), we have proposed a transition to
CPU hardware to overcome the memory constraints lim-
iting the size and expressivity of these networks. Key to
this transition is overcoming the impractical performance
gap between existing CPU and GPU implementations. To
achieve this, we extended previous algorithms of fast con-
volution to the N -dimensional case, yielding an order-of-
magnitude reduction in computations for popular networks
such as C3D. Importantly, our implementation diverges
from previous studies that focus on the hand-crafting of
minimal Winograd-style algorithms. We instead exploit
the relaxed memory constraints, efﬁcient sparse access and
other architectural considerations of CPU hardware to over-
come the cost of applying transform matrices.

The obvious alternative to our approach is to overcome
memory constraints by splitting large networks across mul-
tiple GPU devices. Distributed frameworks such as Ten-
sorFlow are valuable for a broad class of machine learning
problems, e.g. many of the data mining tasks faced by large
organizations where the data itself is often sharded across
different machines. However, it is important to recognize
that the horizontal scalability paradigm is not a one-size-
ﬁts-all solution. Consider the increasing demand for real-
time CPU solutions to image and video processing, par-
ticularly on mobile devices. Moving forward, we expect
that intensive ConvNet-driven tasks such as video classi-
ﬁcation and de-noising will continue to migrate from the
realm of academic research to practical realization (Shi

throughputcores24681012141618(a)(c)1(b)2468100Deep Tensor Convolution on Multicores

2016.

Blumofe, Robert D, Joerg, Christopher F, Kuszmaul,
Bradley C, Leiserson, Charles E, Randall, Keith H, and
Zhou, Yuli. Cilk: An efﬁcient multithreaded runtime
system. Journal of parallel and distributed computing,
37(1):55–69, 1996.

Chetlur, Sharan, Woolley, Cliff, Vandermersch, Philippe,
Cohen, Jonathan, Tran, John, Catanzaro, Bryan, and
Shelhamer, Evan. cudnn: Efﬁcient primitives for deep
learning. arXiv preprint arXiv:1410.0759, 2014.

Chintala,

Soumith.

Convnet

benchmarks.

github.com/soumith/convnet-benchmarks, 2015.

Cong, Jason and Xiao, Bingjun. Minimizing computa-
tion in convolutional neural networks. In International
Conference on Artiﬁcial Neural Networks, pp. 281–290.
Springer, 2014.

Couprie, Camille, Farabet, Cl´ement, Najman, Laurent, and
LeCun, Yann. Indoor semantic segmentation using depth
information. arXiv preprint arXiv:1301.3572, 2013.

Dean, Jeffrey, Corrado, Greg, Monga, Rajat, Chen, Kai,
Devin, Matthieu, Mao, Mark, Senior, Andrew, Tucker,
Paul, Yang, Ke, Le, Quoc V, et al. Large scale distributed
deep networks. In Advances in neural information pro-
cessing systems, pp. 1223–1231, 2012.

Denton, Emily L, Chintala, Soumith, Fergus, Rob, et al.
Deep generative image models using a laplacian pyramid
of adversarial networks. In Advances in neural informa-
tion processing systems, pp. 1486–1494, 2015.

Ding, Cunsheng, Pei, Dingyi, and Salomaa, Arto. Chinese
remainder theorem: applications in computing, coding,
cryptography. World Scientiﬁc, 1996.

Dukhan, M.

Nnpack.

https://github.com/

Maratyszcza/NNPACK, 2016.

Glorot, Xavier and Bengio, Yoshua. Understanding the dif-
ﬁculty of training deep feedforward neural networks. In
Aistats, volume 9, pp. 249–256, 2010.

Goodfellow, Ian, Pouget-Abadie, Jean, Mirza, Mehdi, Xu,
Bing, Warde-Farley, David, Ozair, Sherjil, Courville,
Aaron, and Bengio, Yoshua. Generative adversarial nets.
In Advances in Neural Information Processing Systems,
pp. 2672–2680, 2014.

Grewe, Dominik and Lokhmotov, Anton. Automatically
generating and tuning gpu code for sparse matrix-vector
multiplication from a high-level representation. In Pro-
ceedings of the Fourth Workshop on General Purpose
Processing on Graphics Processing Units, pp. 12. ACM,
2011.

He, Kaiming, Zhang, Xiangyu, Ren, Shaoqing, and Sun,
Jian. Deep residual learning for image recognition. In
The IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), June 2016.

Ji, Shuiwang, Xu, Wei, Yang, Ming, and Yu, Kai. 3d con-
volutional neural networks for human action recognition.
IEEE transactions on pattern analysis and machine in-
telligence, 35(1):221–231, 2013.

Jia, Yangqing, Shelhamer, Evan, Donahue, Jeff, Karayev,
Sergey, Long, Jonathan, Girshick, Ross, Guadarrama,
Sergio, and Darrell, Trevor. Caffe: Convolutional ar-
chitecture for fast feature embedding. In Proceedings of
the 22nd ACM international conference on Multimedia,
pp. 675–678. ACM, 2014.

Karpathy, Andrej, Toderici, George, Shetty, Sanketh, Le-
ung, Thomas, Sukthankar, Rahul, and Fei-Fei, Li. Large-
scale video classiﬁcation with convolutional neural net-
works. In Proceedings of the IEEE conference on Com-
puter Vision and Pattern Recognition, pp. 1725–1732,
2014.

Kolda, Tamara G and Bader, Brett W. Tensor decompo-
sitions and applications. SIAM review, 51(3):455–500,
2009.

Krizhevsky, Alex, Sutskever, Ilya, and Hinton, Geoffrey E.
Imagenet classiﬁcation with deep convolutional neural
networks. In Advances in neural information processing
systems, pp. 1097–1105, 2012.

Lavin, A.

Wincnn.

https://github.com/

andravin/wincnn, 2016.

Lavin, Andrew and Gray, Scott. Fast algorithms for con-
volutional neural networks. In The IEEE Conference on
Computer Vision and Pattern Recognition (CVPR), June
2016.

LeCun, Yann, Boser, Bernhard, Denker, John S, Hender-
son, Donnie, Howard, Richard E, Hubbard, Wayne, and
Jackel, Lawrence D. Backpropagation applied to hand-
written zip code recognition. Neural computation, 1(4):
541–551, 1989.

LeCun, Yann A, Bottou, L´eon, Orr, Genevieve B, and
M¨uller, Klaus-Robert. Efﬁcient backprop. In Neural net-
works: Tricks of the trade, pp. 9–48. Springer, 2012.

Ledig, Christian, Theis, Lucas, Husz´ar, Ferenc, Caballero,
Jose, Aitken, Andrew, Tejani, Alykhan, Totz, Johannes,
Wang, Zehan, and Shi, Wenzhe. Photo-realistic sin-
gle image super-resolution using a generative adversarial
network. arXiv preprint arXiv:1609.04802, 2016.

Deep Tensor Convolution on Multicores

Lee, Kisuk, Zlateski, Aleksandar, Ashwin, Vishwanathan,
and Seung, H Sebastian. Recursive training of 2d-3d
convolutional networks for neuronal boundary predic-
tion. In Advances in Neural Information Processing Sys-
tems, pp. 3573–3581, 2015.

Lee, Victor W, Kim, Changkyu, Chhugani, Jatin, Deisher,
Michael, Kim, Daehyun, Nguyen, Anthony D, Satish,
Nadathur, Smelyanskiy, Mikhail, Chennupaty, Srinivas,
Hammarlund, Per, et al. Debunking the 100x gpu vs. cpu
myth: an evaluation of throughput computing on cpu and
gpu. ACM SIGARCH Computer Architecture News, 38
(3):451–460, 2010.

Lichtman, Jeff W, Pﬁster, Hanspeter, and Shavit, Nir. The
big data challenges of connectomics. Nature neuro-
science, 17(11):1448–1454, 2014.

Little, John DC. A proof for the queuing formula: L= λ w.

Operations research, 9(3):383–387, 1961.

Long, Jonathan, Shelhamer, Evan, and Darrell, Trevor.
Fully convolutional networks for semantic segmentation.
In Proceedings of the IEEE Conference on Computer Vi-
sion and Pattern Recognition, pp. 3431–3440, 2015.

Mathieu, Michael, Henaff, Mikael, and LeCun, Yann. Fast
training of convolutional networks through FFTs. arXiv
preprint arXiv:1312.5851, 2013.

Matveev, Alexander, Meirovitch, Yaron, Saribekyan,
Hayk, Jakubiuk, Wiktor, Kaler, Tim, Odor, Gergely,
Budden, David, Zlateski, Aleksandar, and Shavit, Nir. A
multicore path to connectomics-on-demand. In Proceed-
ings of the 22nd ACM SIGPLAN Symposium on Princi-
ples and Practice of Parallel Programming. ACM, 2017.

Meirovitch, Yaron, Matveev, Alexander, Saribekyan,
Hayk, Budden, David, Rolnick, David, Odor, Gergely,
Jones, Seymour Knowles-Barley Thouis Raymond, Pﬁs-
ter, Hanspeter, Lichtman, Jeff William, and Shavit,
Nir. A multi-pass approach to large-scale connectomics.
arXiv preprint arXiv:1612.02120, 2016.

Russakovsky, Olga, Deng, Jia, Su, Hao, Krause, Jonathan,
Satheesh, Sanjeev, Ma, Sean, Huang, Zhiheng, Karpa-
thy, Andrej, Khosla, Aditya, Bernstein, Michael, et al.
Imagenet large scale visual recognition challenge. Inter-
national Journal of Computer Vision, 115(3):211–252,
2015.

Shi, Shaohuai, Wang, Qiang, Xu, Pengfei, and Chu, Xi-
aowen. Benchmarking state-of-the-art deep learning
software tools. arXiv preprint arXiv:1608.07249, 2016a.

Shi, Wenzhe, Caballero, Jose, Husz´ar, Ferenc, Totz, Jo-
hannes, Aitken, Andrew P, Bishop, Rob, Rueckert,
Daniel, and Wang, Zehan. Real-time single image and
video super-resolution using an efﬁcient sub-pixel con-
volutional neural network. In Proceedings of the IEEE
Conference on Computer Vision and Pattern Recogni-
tion, pp. 1874–1883, 2016b.

Simonyan, Karen and Zisserman, Andrew. Two-stream
convolutional networks for action recognition in videos.
In Advances in Neural Information Processing Systems,
pp. 568–576, 2014a.

Simonyan, Karen and Zisserman, Andrew. Very deep con-
volutional networks for large-scale image recognition.
arXiv preprint arXiv:1409.1556, 2014b.

Szegedy, Christian, Liu, Wei, Jia, Yangqing, Sermanet,
Pierre, Reed, Scott, Anguelov, Dragomir, Erhan, Du-
mitru, Vanhoucke, Vincent, and Rabinovich, Andrew.
In Proceedings of
Going deeper with convolutions.
the IEEE Conference on Computer Vision and Pattern
Recognition, pp. 1–9, 2015.

Tran, Du, Bourdev, Lubomir, Fergus, Rob, Torresani,
Lorenzo, and Paluri, Manohar. Learning spatiotemporal
features with 3d convolutional networks. In 2015 IEEE
International Conference on Computer Vision (ICCV),
pp. 4489–4497. IEEE, 2015.

Vanhoucke, Vincent, Senior, Andrew, and Mao, Mark Z.
Improving the speed of neural networks on CPUs. 2011.

Poole, Ben, Lahiri, Subhaneil, Raghu, Maithra, Sohl-
Dickstein, Jascha, and Ganguli, Surya. Exponential
expressivity in deep neural networks through transient
chaos. arXiv preprint arXiv:1606.05340, 2016.

Vasilache, Nicolas, Johnson, Jeff, Mathieu, Michael, Chin-
tala, Soumith, Piantino, Serkan, and LeCun, Yann. Fast
convolutional nets with fbfft: A gpu performance evalu-
ation. arXiv preprint arXiv:1412.7580, 2014.

Robison, Arch D. Composable parallel patterns with intel
cilk plus. Computing in Science and Engineering, 15(2):
66–71, 2013.

Ronneberger, Olaf, Fischer, Philipp, and Brox, Thomas. U-
net: Convolutional networks for biomedical image seg-
mentation. In International Conference on Medical Im-
age Computing and Computer-Assisted Intervention, pp.
234–241. Springer, 2015.

Winograd, Shmuel. Arithmetic complexity of computations,

volume 33. Siam, 1980.

Zlateski, Aleksandar, Lee, Kisuk, and Seung, H Sebastian.
Znni-maximizing the inference throughput of 3d convo-
lutional networks on multi-core cpus and gpus. arXiv
preprint arXiv:1606.05688, 2016.

