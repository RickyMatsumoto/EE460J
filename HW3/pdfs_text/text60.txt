Strongly-Typed Agents are Guaranteed to Interact Safely

David Balduzzi 1

Abstract

As artiﬁcial agents proliferate, it is becoming in-
creasingly important to ensure that their interac-
tions with one another are well-behaved. In this
paper, we formalize a common-sense notion of
when algorithms are well-behaved: an algorithm
is safe if it does no harm. Motivated by recent
progress in deep learning, we focus on the spe-
ciﬁc case where agents update their actions ac-
cording to gradient descent. The paper shows
that that gradient descent converges to a Nash
equilibrium in safe games. The main contribu-
tion is to deﬁne strongly-typed agents and show
they are guaranteed to interact safely, thereby
providing sufﬁcient conditions to guarantee safe
interactions. A series of examples show that
strong-typing generalizes certain key features of
convexity, is closely related to blind source sepa-
ration, and introduces a new perspective on clas-
sical multilinear games based on tensor decom-
position.

1. Introduction

“First, do no harm”

Recent years have seen rapid progress on core problems
in artiﬁcial intelligence such as object and voice recog-
nition (Hinton & et al, 2012; Krizhevsky et al., 2012),
playing video and board games (Mnih et al., 2015; Sil-
ver et al., 2016), and driving autonomous vehicles (Zhang
et al., 2016). As artiﬁcial agents proliferate, it is increas-
ingly important to ensure their interactions with one an-
other, with humans, and with their environment are safe.

Concretely, the number of neural networks being trained
and used is growing rapidly. There are enormous and in-
creasing economies of scale that can likely be derived from
treating them as populations – rather than as isolated algo-
rithms. How to ensure interacting neural networks cooper-
ate effectively? When can weights trained on one problem

1Victoria University of Wellington, New Zealand. Correspon-

dence to: David Balduzzi <dbalduzzi@gmail.com>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

be adapted to another without adverse effects? The prob-
lems fall under mechanism design, a branch of game theory
(Nisan et al., 2007). However, neural nets differ from hu-
mans in that they optimize clear objectives using gradient
descent. The setting is thus more structured than traditional
mechanism design.

Safety. The ﬁrst contribution of the paper is formalize
safety as a criterion on how agents interact. We propose
a basic notion of safety based on the common-sense prin-
ciple that agents should do no harm to one another. More
formally, each agent optimizes an objective whose value
depends on the actions of the agent and the actions of the
rest of the population. A game is safe if the actions chosen
by each agent do no (inﬁnitesimal) harm to any other agent,
where harm is measured as increased loss.

The key simplifying assumption in the paper is to take gra-
dient descent as a computational primitive (Balduzzi,
2016). Questions about mechanism design are sharp-
ened under the assumption that agents use gradient de-
scent. The assumption holds broadly since the key driver
of progress in artiﬁcial intelligence is deep learning, which
uses gradient descent to optimize complicated objective
functions composed from simple differentiable modules
(LeCun et al., 2015).

A weakness of the approach is that it conceives safety more
narrowly than, for example, Amodei et al. (2016) which is
concerned with societal risks arising from artiﬁcial intelli-
gence. We argue that a necessary foundational component
of the broader AI-safety project is to clarify exactly what
safety entails when the objectives of the agents and the al-
gorithms they employ are precisely speciﬁed.

Strongly-typed games. The second contribution is to in-
troduce type systems suited to multi-agent optimization
problems (that is, games). We build on the typed linear
algebra introduced in Balduzzi & Ghifary (2016). The
nomenclature is motivated by an analogy with types in the
theory of programming. Type systems are used to prevent
untrapped errors (errors that go unnoticed and cause arbi-
trary behavior later on) when running a program (Cardelli,
1997). A program is safe if it does not cause untrapped er-
rors. Type systems can enforce safety by statically rejecting
all programs that are potentially unsafe.

Strongly-Typed Agents are Guaranteed to Interact Safely

The idea underlying types in programming is that “like
should interact with like”. Typed linear algebra, deﬁni-
tion 1, formalizes “like interacts with like” in the simplest
possible way – by ﬁxing an orthogonal basis. Section 2 in-
troduces a wider class of games than in the literature and
deﬁnes safety. Theorem 1 shows that gradient descent con-
verges to a Nash equilibrium in safe games. Section 3 ex-
tracts the key ingredients required for safe gradients from
two warmup examples. The ingredients are simultaneous
diagonalization, i.e.
the existence of a shared latent or-
thogonal basis, and monotonic covariation, i.e.
that the
derivatives of the objectives have the same sign in the la-
tent coordinate system. The main result, theorem 2, is that
strongly-typed games are guaranteed to be safe.

Implications. Safety and strong-typing generalize key
properties of convexity. Convexity is of course the gold
standard for well-behaved gradients. We uncover latent
types and demonstrate safety of Newton’s method, natural
gradient and mirror descent; see sections 3.2, A2 and A3.

The main theme of sections 4 and 5 is disentangling latent
factors. We show that strong-typing in quadratic games is
closely related to blind source separation. Section 5 ana-
lyzes classical N -player games. The analysis yields a new
perspective on classical games based on tensor-SVD that is
closely related to independent component analysis.

Sections 6 and A6 switch to neural networks and ana-
lyze two biologically plausible variants of backpropagation
(Balduzzi et al., 2015; Lillicrap et al., 2016). We show that
the main results of the papers are to prove the respective
algorithms are safe.

Scope and related work. This paper lays the foundations
of safety in gradient-based optimization. Applications are
deferred to future work.

The literature on safety is mostly focused on problems aris-
ing in reinforcement learning, for example ensuring agents
avoid dangerous outcomes (Turchetta et al., 2016; Amodei
et al., 2016; Berkenkamp et al., 2016). Gradients are typi-
cally not available in reinforcement learning problems. We
study interactions between algorithms with clearly deﬁned
objectives that utilize gradient-based optimization, which
gives a more technical perspective.

The idea of a population of neural networks solving mul-
tiple related tasks is developed in Fernando et al. (2017),
which uses genetic algorithms to adapt components to new
tasks. However, they repeatedly reinitialize components to
undo the damage done by the genetic algorithm. Our work
is intended, ultimately, to help design algorithms that detect
and avoid damaging updates. A recent survey paper argues
the brain optimizes a family of complementary loss func-
tions (Marblestone et al., 2016) without considering how

the complementarity of the loss functions could be checked
or enforced.

The idea of investigating game-theoretic and mechanism
design questions speciﬁc to certain classes of algorithms is
introduced in Rakhlin & Sridharan (2013); Syrgkanis et al.
(2015). The papers consider how convergence in games can
be accelerated if the players use variants of mirror descent.

If α ≥ 0 then α is positive; if α > 0 then it
Terminology.
is strictly positive. A (not necessarily square) matrix D is
diagonal if dij = 0 for all i (cid:54)= j and similarly for tensors.
Vectors are columns. The inner product is (cid:104)v, w(cid:105) = v(cid:124)w.

2. Safety

2.1. Types and orthogonal projections

Let us recall some basic facts about orthogonal projections.
Let (V, (cid:104)•, •(cid:105)) be a vector space equipped with an inner
product. An orthogonal projection is a linear transform
π : V → V that is

O1. idempotent, π2 = π, and

O2. self-adjoint, (cid:104)πv, v(cid:48)(cid:105) = (cid:104)v, πv(cid:48)(cid:105) for any v, v(cid:48) ∈ V .

Lemma 1. Let P denote an (n × k)-matrix with orthogo-
nal columns p1, . . . , pk. Then the (n × n)-matrix PP(cid:124) =
(cid:124)
(cid:80)k
i is an (orthogonal) projec-
i=1 pip

i=1 pi(cid:104)pi, •(cid:105) = (cid:80)k

tion.

Lemma 2. If two orthogonal projections π and τ commute
then their product is an orthogonal projection.

Proof. Let q := πτ . If πτ = τ π then

q2 = πτ · πτ = ππ · τ τ = πτ = q.

Checking self-adjointness is an exercise.
Deﬁnition 1. A type TV = (cid:0)V, (cid:104)•, •(cid:105), {πr}R
(cid:1) is a D-
dimensional vector space with an inner product and or-
thogonal projections πr : V → V such that πrπs = 0
for r (cid:54)= s and (cid:80)R
r=1 πr = IV is the identity. Type TV has
dimension D and rank R.

r=1

A full rank type, D = R, is equivalent to a vector space
equipped with an orthogonal basis. Lower rank types are
less rigid, and can be thought of as vector spaces equipped
with generalized orthogonal coordinates.

2.2. Safe games

Deﬁnition 2. A game consists of a type TV , feasible set
H ⊂ V , players [N ] := {1, . . . , N }, losses (cid:96)n : H → R,
and an assignment ρ : [N ] → [R] of players to projections.

Strongly-Typed Agents are Guaranteed to Interact Safely

The type structure and assignments specify the coordinates
controlled by each player. On round t, player n chooses
ξt
n ∈ V and updates the joint action via

wt+1 = wt − πρ(n)(ξt

n) where wt, wt+1 ∈ H.

Updates leaving the feasible set can be mapped back into
it, see section A1. The projection πρ(n) speciﬁes the coor-
dinates of the joint-action vector that player n can modify.
Example 1. In a block game actions w ∈ V = (cid:81)N
RDn
decompose as w = (w1, . . . , wN ) where the nth player
can modify the coordinates in wn. The orthogonal pro-
jections πn(w) = (0, . . . , wn, . . . , 0) form a rank-N type
with ρ(n) = n for all n ∈ [N ].
Example 2. In an open game the type has rank(TV ) = 1
so the single projection is the identity and ρ(n) = 1 for all
n. Every player can modify all the coordinates.

n=1

Block games coincide with the standard deﬁnition of a
game in the literature. Open games arise below when con-
sidering Newton’s method, natural gradients, mirror de-
scent and neural networks.

The goal of each player is to minimize its loss. Safety is the
condition that no player’s updates harm any other player.
Deﬁnition 3. It is safe for player m to choose ξt
it does no inﬁnitesimal harm to any player

m ∈ V if

(cid:10)πρ(m)(ξt

m), ∇ (cid:96)n(wt)(cid:11) ≥ 0 for all n ∈ [N ].

A game is safe if it is safe for players to use gradient de-
scent: i.e. if choosing ξt

m := ∇ (cid:96)m(wt) is safe for all m.

It is worth getting a degenerate case out of the way. A block
game is decomposable if player m’s loss only depends on
the actions it controls. Intuitively, a decomposable game is
N independent optimization problems. More formally:
Lemma 3. A block game is decomposable if (cid:96)m(w) =
(cid:96)m(πmw) for all w and m. Decomposable games are safe.

Proof. Since πm is self-adjoint, we have that (cid:104)πmξ, η(cid:105) =
(cid:104)πmξ, πmη(cid:105). Decomposability implies πm(∇ (cid:96)n) = 0
when m (cid:54)= n, so

(cid:10)πm(∇ (cid:96)m), πm(∇ (cid:96)n)(cid:11) =

(cid:40)

(cid:107)πm(∇ (cid:96)m)(cid:107)2
2
0

if m = n
else

which is always positive.

2.3. Convergence

(Daskalakis et al., 2009). We show gradient descent con-
verges to a Nash equilibrium in safe convex games.

Theorem 1. Gradient descent converges to a Nash equi-
librium in safe convex games with smooth losses.

Proof. Introduce potential function Φ(w) = (cid:80)N
(cid:96)n(w) where αn > 0 are strictly positive. Then

n=1 αn ·

(cid:104)πm(∇ Φ), ∇ (cid:96)m(cid:105) =

αn

πm(∇ (cid:96)n), ∇ (cid:96)m

(1)

(cid:69)

(cid:68)

N
(cid:88)

n=1

≥ αm · (cid:107)πm(∇ (cid:96)m)(cid:107)2

2 ≥ 0

since safety implies the cross-terms are nonnegative. The
players’ updates therefore converge to either a critical point
of Φ or to the boundary of the feasible set. Suppose gradi-
ent descent converges to the interior of H. Eq (1) implies
that if ∇ Φ = 0 then πm(∇ (cid:96)m) = 0 for all m. By convex-
ity of the losses, the critical point is a minimizer of each
loss with respect to that player’s actions, implying it is a
Nash equilibrium. A similar argument holds if gradient de-
scent converges to the boundary, see section A1.

Example 3 (convergence in a safe constrained game). Con-
sider a two-player block game with (cid:96)1(x, y) = x + 2y and
(cid:96)2(x, y) = 2x + y where player-1 controls x and player-
2 controls y. Introduce feasible set H = {(x, y) ∈ R2 :
x2 + y2 ≤ 1}. The game is convex and safe. The set of
Nash equilibria is the bottom-left quadrant of the bound-
ary {(x, y) ∈ H : x, y ≤ 0 and x2 + y2 = 1}. Gradient
descent with positive combinations of π1(∇ (cid:96)1) = ∂
∂x and
π2(∇ (cid:96)2) = ∂

∂y always converges to a Nash equilibrium.

A simple game that does not converge is the following zero-
sum game, which is related to generative adversarial net-
works (Goodfellow, 2017).
Example 4 (convergence requires positivity). Consider the
two-player block game (cid:96)1(x, y) = xy and (cid:96)2(x, y) = −xy
where player-1 controls x and player-2 controls y. The
Nash equilibrium is the origin (x, y) = (0, 0). However,
gradient descent does not converge. Observe that ∇ (cid:96)1 =
y ∂
∂y so π1(∇ (cid:96)1) = y ∂
∂x + x ∂
∂x
and π2(∇ (cid:96)2) = −x ∂
∂y . The ﬂow π1(∇ (cid:96)1) + π2(∇ (cid:96)2)
rotates around the origin. No positive combination of
π1(∇ (cid:96)1) and π2(∇ (cid:96)2) converges to the origin.

∂y and ∇ (cid:96)2 = −y ∂

∂x − x ∂

3. Strongly-Typed Games

Strong-typing is based two key ideas: diagonalization and
positivity. Diagonalization is an important tool in applied
mathematics. The Fourier transform simultaneously diag-
onalizes differentiation and convolution:

= 2πiωF(f )

and F(f ∗ g) = F(f ) · F(g)

A block game is convex if the feasible set H is compact
and convex and the losses (cid:96)n : H → R are convex in
the coordinates controlled by the respective players. Nash
equilibria are guaranteed to exist in convex block games
(Nash, 1950). However, ﬁnding them is often intractable

F

(cid:17)

(cid:16) df
dx

Strongly-Typed Agents are Guaranteed to Interact Safely

The SVD diagonalizes any matrix: Q(cid:124)MP = D. Finally,
the Legendre transform f ∗(η) = maxθ{η(cid:124)θ − f (θ)} di-
agonalizes the inﬁmal convolution

(f (cid:3)g)∗ = f ∗+g∗ for (f (cid:3)g)(θ) = min
ϑ

{f (ϑ)+g(θ−ϑ)}.

Diagonalization ﬁnds a latent orthogonal basis that is more
mathematically amenable than the naturally occurring co-
ordinate system. Strong-typing is based on an extension of
diagonalization to nonlinear functions. Before diving in,
we recall the basics of simultaneous diagonalization.

Symmetric matrices. Any symmetric matrix A factor-
izes as A = P(cid:124)DP where P is orthogonal and D is di-
agonal. A collection A1, . . . , AN of symmetric matrices
is simultaneously diagonalizable iff the matrices commute,
in which case Ai = P(cid:124)DiP where Di is diagonal and P
determines a common latent coordinate system (or type).

Arbitrary matrices. The diagonalization of an (m × n)-
matrix A is A = PDQ(cid:124) where P and Q are orthogonal
(m × m) and (n × n) matrices and D is positive diagonal.
A collection of matrices is simultaneously diagonalizable
if Ai = PDiQ(cid:124) for all i. A necessary condition for simul-
taneous diagonalizability is that

A

(cid:124)
i Aj and AiA

(cid:124)
j are symmetric for all i, j.

(2)

Next, we work through two examples where diagonaliza-
tion and a positivity condition imply safety.

3.1. Warmup: When are two-player games safe?

To orient the reader, we consider a minimal example which
illustrates most of the main ideas of the paper: two-player
bilinear games (von Neumann & Morgenstern, 1944). Con-
sider a two-player block game with loss functions

(cid:96)1(v, w) = v(cid:124)Aw and

(cid:96)2(v, w) = v(cid:124)Bw

and projections π1/2(v, w) = (v, 0) and (0, w). The
gradients are ∇ (cid:96)1 = (cid:80)
) =
(w(cid:124)A(cid:124), v(cid:124)A) and ∇ (cid:96)2 = (w(cid:124)B(cid:124), v(cid:124)B). The game is
safe if

ij(wjAij

+ viAij

∂
∂wj

∂
∂vi

(cid:104)π1(∇ (cid:96)1), ∇ (cid:96)2(cid:105) = w(cid:124)A(cid:124)Bw ≥ 0
(cid:104)∇ (cid:96)1, π2(∇ (cid:96)2)(cid:105) = v(cid:124)BA(cid:124)v ≥ 0

and
for all v and w.

Safety requires that A(cid:124)B and BA(cid:124) are positive semidef-
inite. Any square matrix decomposes into symmetric and
antisymmetric components M = Ms + Ma = 1
2 (M +
M(cid:124)) + 1
2 (M − M(cid:124)) where w(cid:124)Maw = 0 for all w. Thus,
a square matrix is positive semideﬁnite iff its symmetric
component is positive semideﬁnite.

We therefore restrict to when A(cid:124)B and BA(cid:124) are symmet-
ric. Recalling (2), we further suppose that A and B are
simultaneously diagonalizable and obtain:
Lemma 4. A two-player game is safe if A = PDQ(cid:124) and
B = PEQ(cid:124) where P and Q are orthogonal matrices, D
and E are diagonal, and DE ≥ 0.

Proof. The assumptions imply that

(cid:104)π1 ∇ (cid:96)1, ∇ (cid:96)2(cid:105) = w(cid:124)A(cid:124)Bw = w(cid:124)Q(D(cid:124)E)Q(cid:124)w ≥ 0

and (cid:104)∇ (cid:96)1, π2 ∇ (cid:96)2(cid:105) = w(cid:124)P(E(cid:124)D)P(cid:124)w ≥ 0.

3.2. Warmup: When is Newton’s method safe?

It was observed in Dauphin et al. (2014) that applying New-
ton’s method to neural networks is problematic because it
is attracted to saddle points and can increase the loss on
nonconvex problems. We reformulate their observation in
the language of safety.

Consider a single player open game with twice differen-
tiable loss (cid:96) : V → R and projection π = IV . Newton’s
method optimizes (cid:96) via weight updates

wt+1 = wt − ξt with ξt = ηt · H−1(wt) · ∇ (cid:96)(wt),

where Hij(w) = ∂2(cid:96)
Lemma 5. If (cid:96) is strictly convex then Newton’s method is
safe, i.e. (cid:104)H−1 ∇ (cid:96), ∇ (cid:96)(cid:105) ≥ 0 for all w.

(w) is the Hessian and ηt > 0.

∂wi∂wj

Proof. Factorize the Hessian at wt as H = PDP(cid:124). If (cid:96) is
strictly convex then D > 0 and so

(cid:104)H−1 ∇ (cid:96), ∇ (cid:96)(cid:105) = (cid:104)D−1P(cid:124) ∇ (cid:96), P(cid:124) ∇ (cid:96)(cid:105) ≥ 0

as required.

Two features are noteworthy: (i) the transform η = P(cid:124)ξ
diagonalizes the second-order Taylor expansion of (cid:96),

compare (cid:96)(w + ξ) = (cid:96)(w) + ξ(cid:124) · ∇ (cid:96) +

ξ(cid:124)Hξ

with (cid:96)(w + Pη) = (cid:96)(w) + η(cid:124)(P(cid:124) ∇ (cid:96)) +

η(cid:124)Dη,

1
2

1
2

and (ii) the proof hinges on the positivity of D. Sections A2
and A3 extend the approach to show the natural gradient
(Amari, 1998) and mirror descent (Raskutti & Mukherjee,
2015) are safe using the Legendre transform.

3.3. Strongly-typed games are safe

We apply the lessons from the warmups to deﬁne a factor-
ization of nonlinear functions.

Strongly-Typed Agents are Guaranteed to Interact Safely

Deﬁnition 4. The functions {(cid:96)n : V → R}N
ously factorize if there is a triple

n=1 simultane-

(cid:16)

{Pl}L

l=1, {fl : Rpl → R}L

l=1, {gn : RL → R}N

n=1

(cid:17)
,

notation, a block game is a weighted potential game if there
exists a potential function Φ and scalar weights αn > 0
satisfying

(cid:96)n(w) − (cid:96)n(w + πnv) = αn ·

Φ(w) − Φ(w + πnv)

(cid:16)

(cid:17)

satisfying

(cid:96)n(w) = gn

(cid:124)
1 w), . . . , fL(P
f1(P

(cid:124)
Lw)

(cid:16)

(cid:17)

for all n

for all w, v ∈ V and n ∈ [N ].

where Pl are (D×pl)-matrices whose columns jointly form
an orthogonal basis of V and fl and gn are differentiable,
and the gn’s co-vary monotonically: ∂gm
∂fl

∂gn
∂fl

≥ 0.

(cid:124)
l deﬁne a type structure on V .
The projections τl = PlP
(cid:124)
Intuitively, the outputs zl = fl(P
l w) are latent factors
computed from the inputs w such that each zl is indepen-
dent of the others – independence is enforced by the pro-
jections τl. Monotonic covariation of the functions gn with
respect to the factors zl plays the same role as positivity in
two-player games and Newton’s method.
Deﬁnition 5. Game (TV , {(cid:96)n}N
n=1) is strongly-typed if the
loss functions admit a simultaneous factorization whose
projections {τ l = PlP
Theorem 2. Strongly-typed games are safe.

l=1 commute with {πn}N

(cid:124)
l }L

n=1.

Proof. Commutativity implies there is a basis {ei}D
i=1 for
V that simultaneously diagonalizes the projections {πn}
and {τ l}. Express elements of V as (v1, . . . , vD) in the
basis. Safety then reduces to showing

(cid:104)πm(∇ (cid:96)m), ∇ (cid:96)n(cid:105) =

(cid:88)

∂gm
∂vi

·

∂gn
∂vi

≥ 0.

{i:πm(ei)(cid:54)=0}

Observe that ∂fk
∂vi
tions of orthogonal coordinates. It follows that

= 0 if k (cid:54)= l since fk and fl are func-

∂fl
∂vi

∂gm
∂vi

·

∂gn
∂vi

=

=

(cid:32) L
(cid:88)

k=1

L
(cid:88)

l=1

∂gm
∂fk

∂fk
∂vi

(cid:33)

(cid:32) L
(cid:88)

·

(cid:33)

∂gn
∂fl

∂fl
∂vi

∂gm
∂fl

∂gn
∂fl

(cid:18) ∂fl
∂vi

·

l=1
(cid:19)2

≥ 0

We provide two counter-examples to show that strongly-
typed games are distinct from potential games.
Example 5 (a strongly-typed game that is not a potential
game). Let (cid:96)1(x, y) = x1y1 + 2x2y2 and (cid:96)2(x, y) =
3x1y1 + 4x2y2. The block game with projections onto
x and y is strongly-typed but is not a weighted potential
game.
Example 6 (a potential game that
is not safe). Let
(cid:96)1(x, y) = xy and (cid:96)2(x, y) = xy − 9x, with projections
onto x and y. The game is a potential game but is not safe
because

(cid:104)π1(∇ (cid:96)1), ∇ (cid:96)2(cid:105) = (cid:104)(y, 0), (y − 9, x)(cid:105) = y2 − 9y

can be negative.

4. Quadratic Games

Given a collection of (D × D)-matrices {A(n)}N
n=1 and D-
vectors {b(n)} the corresponding quadratic game has loss
functions

(cid:96)n(w) =

w(cid:124)A(n)w + w(cid:124)b(n).

1
2

We assume the matrices A(n) are symmetric without loss
of generality.

4.1. Open quadratic games

In an open quadratic game, each player updates the entire
joint action.

Corollary 1. An open quadratic game is safe if there is
an orthogonal (D × D)-matrix P, diagonal matrices D(n)
such that D(m)D(n) ≥ 0, and D-vector b such that

since the gn’s co-vary monotonically.

A(n) = PD(n)P(cid:124)

and b(n) = A(n)b.

Strong-typing is a sufﬁcient but not necessary condition for
safety. More general deﬁnitions can be proposed according
to taste. Deﬁnition 5 is easy to check, covers the basic ex-
amples below, and incorporates the concrete intuition de-
veloped in the warmups.

3.4. Comparison with potential games

The proof of theorem 1 suggests that safe games are related
In our
to potential games (Monderer & Shapley, 1996).

We derive corollaries 1 and 2 from theorem 2. Alternate,
direct proofs are provided in appendix A4.

Proof. Let fi(x) = x( x
Then

2 − bi) and gn(z) = (cid:80)D

i=1 d(n)

i

· zi.

(cid:96)n(w) = gn

(cid:16)

(cid:17)
(cid:124)
(cid:124)
Dw)
1 w), . . . , fD(p
f1(p

,

where pi are the columns of P, is strongly-typed.

Strongly-Typed Agents are Guaranteed to Interact Safely

The Hessian of (cid:96)n is H(cid:96)n = A(n). The conditions of corol-
lary 1 can be reformulated as (i) the Hessians of the losses
commute H(cid:96)mH(cid:96)n = H(cid:96)n H(cid:96)m for all m and n, and (ii)
the Newton steps for the losses coincide (when the Hes-
sians are nonsingular):

= (A(n))−1A(n)(w − b) = w − b.

H−1
(cid:96)n
(cid:124)

(∇ (cid:96)n)
(cid:123)(cid:122)
(cid:125)
Newton step

Example: Disentangling latent factors. An important
problem in machine learning is disentangling latent factors
(Bengio, 2013). Basic methods for tackling the problem
include PCA, canonical correlation analysis (CCA) and in-
dependent component analysis (ICA). We show how the
factorization in corollary 1 can arise “in nature” as a vari-
ant of blind source separation.

Suppose a signal on D channels is recorded for T time-
points giving (D × T )-matrix X. Assume the observations
combine L independent latent signals: X = MS where S
is an (L × T )-matrix representing the latent signal and M
is a mixing matrix.

Blind source separation is concerned with recovering the
latent signals. The covariance of the signal is A = XX(cid:124).
Factorize A = PDP(cid:124) and let ˜S = P(cid:124)X. Although this
may not recover the original signal, i.e. ˜S (cid:54)= S in general,
it does disentangle X into uncorrelated factors:

˜S˜S(cid:124) = P(cid:124)XX(cid:124)P = D.

Finally, recall that ﬁnding the ﬁrst principal component can
be formulated as the constrained maximization problem:

argmax
{w:(cid:107)w(cid:107)2=1}

w(cid:124)Aw.

there
generated

are N sets of observations
Now suppose
X(1), . . . , X(N )
orthogonal
single
mixing matrix acting on different sets of (potentially
rescaled) latent signals: X(n) = PS(n). Finding the ﬁrst
principle components of the signals reduces to solving the
constrained optimization problems

by

a

(cid:40)

argmax
{w:(cid:107)w(cid:107)2=1}

w(cid:124)X(n)(X(n))(cid:124)w

(3)

(cid:41)N

n=1

Corollary 1 implies that (3) is a safe. Note the corollary im-
plies the optimization problems have compatible gradients,
not that they share a common solution. In general there are
many Nash equilibria, analogous to example 3.

Quadratic games and linear regression. The blind
source separation example assumes that the linear terms
b(n) in the loss are zero.
If the linear term is nonzero
then linear regression is a special case of minimizing the
quadratic loss. Safety then relates to searching for weights
that simultaneously solve linear regression problems on
multiple datasets.

4.2. Block Quadratic Games

The block quadratic game has losses as above; however
the action space decomposes into (w1, . . . , wN ) with cor-
responding projections. Block decompose the components
of the loss as








A(n) =

and b(n) =





A(n)
11
...
A(n)
N 1

· · · A(n)
1N
...
· · · A(n)
N N









b(n)
1
...
b(n)
N

.





Corollary 2. A block quadratic game is safe if there are:

(i) (D × D)-orthogonal P with Pmn = 0 for m (cid:54)= n;

(ii) (D × L) matrix R with Rn• diagonal for all n;

(iii) diagonal (L × L)-matrices D(n) with D(m)D(n) ≥ 0;

(iv) and a D-vector b

such that A(n) = PRD(n)R(cid:124)P(cid:124)

and

b(n) = A(n)b for all n.

The notation Pmn and R•n refers to blocks in the rows and
columns of P and columns of R.

l

l=1 d(n)

Proof. Let pi denote the columns of P and gn(z) =
(cid:80)L
· zl. Given l, construct Pl by concatenating the
columns pi of P for which the corresponding entries of Ril
are nonzero and let rl be the vector containing the nonzero
(cid:124)
entries of R•l. Deﬁne fl(xl) = r
l xl). Then
(cid:17)
(cid:124)
(cid:124)
Lw)
1 w), . . . , fL(P

2 − bl) · (r

(cid:96)n(w) = gn

l ( xl

f1(P

(cid:16)

(cid:124)

.

It is an exercise to check the game is strongly-typed.

Example: Disentangling latent factors. We continue
the discussion of blind source separation and safety. Sup-
pose that the mixing matrix decomposes into blocks

M =











M1•
...
MN •

The blocks generate multiple views on a single latent signal,
(Kakade & Foster, 2007; McWilliams et al., 2013; Benton
et al., 2017). The nth view is Mn•S.

As in the example in section 4.1, now suppose there are N
sets of observed signals generated from N sets of latent sig-
nals. Each agent attempts to ﬁnd the principal component
speciﬁc to its view on its set of observations. Corollary 2
implies that the problems

(cid:40)

argmax
{wn:(cid:107)wn(cid:107)2=1}

w(cid:124)X(n)(X(n))(cid:124)w

(cid:41)N

n=1

Strongly-Typed Agents are Guaranteed to Interact Safely

can be safely optimized using gradient descent if the mix-
ing matrix has the block form

Mn• = Pnn · Rn•

where Pnn is orthogonal and Rn• is diagonal.
In
other words, if the views are generated by rescaling and
changing-the-basis of the latent signals.

The open and block settings share a common theme: Safe
disentangling requires observed signals that are generated
by a single (structured) mixing process applied to (arbi-
trary) sets of independent latent signals. The same phe-
nomenon arises in multi-player games, resulting in tensor
decompositions that generalize ICA.

5. Multi-Player Games and Tensor-SVD

A classic N -player strategic game consists in ﬁnite action-
sets An and losses (cid:96)n : A = (cid:81)N
n=1 An → R. Enumerate
the elements of each set as An = [Dn], and encode the
losses as (D1, . . . , DN )-tensors

An[α1, . . . , αN ] := (cid:96)n(α1, . . . , αN ) where αn ∈ [Dn].

Given a collection of N such tensors, deﬁne the corre-
sponding multilinear game1 as

(cid:96)n(w1, . . . , wN ) = An ×1 w1 × · · · ×N wN
D1,...,DN(cid:88)

A[α1, . . . , αN ] · w1[α1] · · · wN [αN ].

:=

α1,...,αN =1

The classic example is when actions are drawn from the
Dn-simplex (cid:52)Dn = {wn ∈ RDn : (cid:80)Dn
α=1 wn[α] =
1 and wn[α] ≥ 0 for all α}.

We now recall the orthogonal tensor decomposition or ten-
sor SVD (Zhang & Golub, 2001; Chen & Saad, 2009). A
tensor admits a tensor-SVD if it can be written in the form

A =

dl · u1

l ⊗ · · · ⊗ uN

l = D ×1 U1 × · · · ×N UN

L
(cid:88)

l=1

where Un is a (Dn × L)-matrix with orthogonal columns
and D is a diagonal (L, . . . , L)-tensor.

Corollary 3. A multilinear game is safe if it admits a si-
multaneous tensor-SVD

A(n) = D(n) ×1 U1 × · · · ×N UN

Proof. Let gn(z) = (cid:80)L
l=1 d(n)
n xn. De-
ﬁne Pl as the (D × N )-matrix whose nth column is un
in
l
the block of rows corresponding to wn and zero elsewhere.
Then

l zl and fl(x) = (cid:81)

(cid:96)n(w) = gn

(cid:0)f1(P

(cid:124)
1 w), . . . , fL(P

(cid:124)

Lw)(cid:1)

and the game is strongly-typed.

Not all tensors admit a tensor-SVD. However, all tensors
do admit a higher-order SVD (de Lathauwer et al., 2000).
Section A5 explains why simultaneous HOSVD does not
guarantee safety and the stronger tensor-SVD is required.

Example: Disentangling latent factors Suppose S is a
latent signal with independent non-Gaussian coordinates.
We observe X = PS + (cid:15) where P is a (D × L) mixing
matrix and (cid:15) is Gaussian noise. By whitening the signal
as a preprocessing step, one can ensure the columns of P
are orthogonal. ICA recovers S from the cumulants of X,
see Hyv¨arinen et al. (2001). The main insight is that the
4th-order cumulant tensor admits a tensor-SVD:

A[i, j, k, l] = cum(xi, xj, xk, xl)
(cid:88)

PioPjpPkqPlr · cum(so, sp, sq, sr)

=

=

o,p,q,r
(cid:88)

r

PirPjrPkrPlr · kurt(sr)

since cum(so, sp, sq, sr) = 0 unless o = p = s = r be-
cause the signals are independent. The expression can be
written A = K×1P×2P×3P×4P where diagonal tensor
K speciﬁes the kurtosis of the latent signal. In other words,
computing the tensor-SVD recovers the mixing matrix and
allows to recover the latent signal up to basic symmetries.

Following the same prescription as the examples above, if
there are N sets of observations generated from N latent
signals by the same mixing matrix, then the resulting cu-
mulant tensors satisfy corollary 3.

6. Biologically Plausible Backpropagation

Our ultimate goal is to apply strong-typing to safely opti-
mize neural nets with multiple loss functions (Marblestone
et al., 2016). Doing so requires constructing variants of
backprop that allow the propagation of multiple error sig-
nals. First steps in this direction have been taken with bio-
logically plausible models of backprop that introduce addi-
tional degrees of freedom into the algorithm.

where the diagonals have the same sign coordinatewise.

1We use the n-mode product notation ×n, see de Lathauwer

et al. (2000).

Feedback alignment
is a recent algorithm with compa-
rable empirical performance to backprop. It is also more
biologically plausible since it loosens backprop’s require-
ment that forward- and back- propagating weights are sym-

Strongly-Typed Agents are Guaranteed to Interact Safely

metric (Lillicrap et al., 2016). The main theoretical result
of the paper, see their supplementary information, is
Theorem. Let δBP = W(cid:124)e denote the error backpropa-
gated one layer of the neural network. Under certain con-
ditions, the error signal computed by feedback alignment,
δF A = Be, satisﬁes

δF A = α · W†e where α > 0

and W† is the pseudoinverse of W.

Proof. See theorem 2 of Lillicrap et al. (2016).

Corollary 4. Under the same conditions, feedback align-
ment is safe.

Proof. We require to check (cid:104)δF A, δBP (cid:105) ≥ 0. Applying
the theorem obtains

(cid:104)δF A, δBP (cid:105) = α · (cid:104)W†e, W(cid:124)e(cid:105) = α · (cid:104)WW†e, e(cid:105).

Observe that WW† is an orthogonal projection by stan-
dard properties of the pseudoinverse so

(cid:104)δF A, δBP (cid:105) = α · (cid:104)WW†e, WW†e(cid:105) ≥ 0

as required.

In fact, Lillicrap et al. (2016) provide experimental and the-
oretical evidence that feedback alignment learns to align
the feedforward weights with the pseudoinverse of the
backconnections. In other words, they argue that feedback
alignment learns safe gradients.

Another variant of backprop is kickback, which loosens
backprop’s requirement that there are distinct forward- and
backward signals (Balduzzi et al., 2015). Kickback trun-
cates backprop’s error signals so that the network learns
from just the feedforward sweep together with scalar error
signals. One of the main results of Balduzzi et al. (2015) is
that kickback is safe, see section A6.

7. Conclusion

Backprop provides a general-purpose tool to train conﬁg-
urations of differentiable modules that share a single ob-
jective. However, effectively training populations of neural
networks on potentially conﬂicting tasks, such that they au-
tomatically exploit synergies and avoid damaging incom-
patibilities (such as unlearning old features that are not use-
ful on a new task) requires fundamentally new ideas.

A key piece of the puzzle is to develop type systems that
can be used to (i) guarantee when certain optimizations can
be safely performed jointly and (ii) ﬂag potential conﬂicts
so that the incompatible optimization problems can be sep-
arated. The paper provides a ﬁrst step in this direction.

From a different perspective, convex methods have played
an enormous role in optimization yet their relevance to
deep learning is limited. The approach to strong-typing
developed here is inspired by and extends certain features
of convexity. One of the goals of this paper is to carve
out some of the key concepts underlying convex geometry
and reassemble them into a more ﬂexible, but still power-
ful framework. The proposed deﬁnition of strong-typing
should be considered a ﬁrst and far from ﬁnal attempt.

A large class of natural examples is generated by imposing
strong-typing on simple quadratic and multilinear games.
It turns out that, in these settings, strong-typing yields
the same matrix and tensor decompositions that arise in
blind source separation and independent component anal-
ysis, where multiple latent signals are mixed by the same
structured process. An important future direction is to dis-
entangle nonlinear latent factors.

Strong-typing and safety in neural nets. We conclude
by discussing the relevance of the framework to neural net-
works. Firstly, neural nets and strong-typing have many of
the same ingredients: neural nets combine linear algebra
(matrix multiplications and convolutions) with monotonic
functions (sigmoids,
tanhs, rectiﬁers, and max-pooling
amongst others). Rectiﬁers and sigmoids have the addi-
tional feature that their outputs are always positive.

Secondly, there is a deeper connection between rectiﬁers
and strong-typing. Rectiﬁers are orthogonal projections
on weights: ρ(W(cid:124)x) zeroes out the columns wl of W for
(cid:124)
which w
l x ≤ 0. Rectiﬁers are more sophisticated projec-
tions than we have previously considered because they are
context-dependent. The columns that are zeroed out de-
pend on W and x: the rectiﬁer-projection takes W and x
as parameters, compare remarks 1 and 2 in the appendix.
Representation learning in rectiﬁer networks can thus be
recast as learning parameterized type structures. An inter-
esting future direction is to consider tensor-switching net-
works (Tsai et al., 2016), which decouple a neuron’s deci-
sion to activate from the information it passes along (for a
rectiﬁer, both depend on W(cid:124)x).

Finally, it has long been known that the brain does not use
backprop (Crick, 1989). One possibility is that backprop is
the optimal deep learning algorithm which, unfortunately,
evolution failed to stumble upon. Another is that there are
evolutionary advantages to not using backpropagation. For
example, it has been argued that the brain optimizes multi-
ple loss functions (Marblestone et al., 2016). Does jointly
optimizing or satisﬁcing multiple objectives require learn-
ing mechanisms with more degrees of freedom than back-
prop (Balduzzi et al., 2015; Lillicrap et al., 2016)? Safety
and strong-typing provide the tools needed to frame and
investigate the question.

Strongly-Typed Agents are Guaranteed to Interact Safely

Acknowledgements

I am grateful to Stephen Marsland and James Benn for use-
ful discussions.

References

Amari, S. Natural Gradient Works Efﬁciently in Learning. Neural

Comp, 10:251–276, 1998.

Amari, S. Information Geometry and Its Applications: Convex
In Nielsen, Frank (ed.),

Function and Dually Flat Manifold.
Emerging Trends in Visual Computing, 2009.

Amodei, Dario, Olah, Chris, Steinhardt, Jacob, Christiano, Paul,
Schulman, John, and Man´e, Dan. Concrete Problems in AI
Safety. In arXiv:1606.06565, 2016.

Balduzzi, D, Vanchinathan, H, and Buhmann, J. Kickback cuts
Backprop’s red-tape: Biologically plausible credit assignment
in neural networks. In AAAI, 2015.

Balduzzi, David. Grammars for Games: A Gradient-Based,
Game-Theoretic Framework for Optimization in Deep Learn-
ing. Frontiers in Robotics and AI, 2(39), 2016.

Balduzzi, David and Ghifary, Muhammad. Strongly-Typed Re-

current Neural Networks. In ICML, 2016.

Bengio, Yoshua. Deep Learning of Representations: Look-
In Dediu, Adrian-Horia, Mart´ın-Vide, Carlos,
ing Forward.
Mitkov, Ruslan, and Truthe, Bianca (eds.), Statistical Lan-
guage and Speech Processing. Springer, 2013.

Benton, Adrian, Khayrallah, Huda, Gujral, Biman, Reisinger,
Drew, Zhang, Sheng, and Arora, Raman. Deep Generalized
Canonical Correlation Analysis. In arXiv:1702.02519, 2017.

Berkenkamp, F, Moriconi, R, Schoellig, A, and Krause, A. Safe
learning of regions of attraction for uncertain, nonlinear sys-
tems with gaussian processes. In IEEE CDC, 2016.

Bubeck, S´ebastien. Convex Optimization: Algorithms and Com-
plexity. Foundations and Trends in Machine Learning, 8(3-4):
231–358, 2015.

Chen, Jie and Saad, Yousef. On the tensor SVD and the optimal
low rank orthogonal approximation of tensors. SIAM J. Matrix
Anal. Appl., 30(4):1709–1734, 2009.

Crick, Francis. The recent excitement about neural networks. Na-

ture, 337(12):129–132, 1989.

Daskalakis, Constantinos, Goldberg, Paul W, and Papadimitriou,
Christos. The Complexity of Computing a Nash Equilibrium.
SIAM J. Computing, 39(1):195–259, 2009.

Dauphin, Yann, Pascanu, Razvan, Gulcehre, Caglar, Cho,
Kyunghyun, Ganguli, Surya, and Bengio, Yoshua.
Identify-
ing and attacking the saddle point problem in high-dimensional
non-convex optimization. In NIPS, 2014.

de Lathauwer, Lieven, de Moor, Bart, and Vandewalle, Joos.
A multilinear singular value decomposition. SIAM J. Matrix
Anal. Appl., 21(4):1253–1278, 2000.

Fernando, C, Banarse, D, Blundell, C, Zwols, Y, Ha, D, Rusu, A,
Pritzel, A, and Wierstra, D. PathNet: Evolution Channels Gra-
dient Descent in Super Neural Networks. In arXiv:1701.08734,
2017.

Goodfellow, Ian J. NIPS 2016 Tutorial: Generative Adversarial

Networks. In arXiv:1701.00160, 2017.

Hinton, G and et al. Deep Neural Networks for Acoustic Mod-
eling in Speech Recognition: The Shared Views of Four Re-
search Groups. IEEE Signal Proc Magazine, 29:82–97, 2012.

Hyv¨arinen, Aapo, Karhunen, Juha, and Oja, Erkki. Independent

Component Analysis. John Wiley & Sons, 2001.

Kakade, Sham and Foster, Dean P. Multi-view Regression Via

Canonical Correlation Analysis. In COLT, 2007.

Krizhevsky, A, Sutskever, I, and Hinton, G E. Imagenet classiﬁ-
cation with deep convolutional neural networks. In Advances
in Neural Information Processing Systems (NIPS), 2012.

LeCun, Yann, Bengio, Yoshua, and Hinton, Geoffrey. Deep learn-

ing. Nature, 521:436–444, 2015.

Lillicrap, Timothy P, Cownden, Daniel, Tweed, Douglas B, and
Ackerman, Colin J. Random feedback weights support error
backpropagation for deep learning. Nature Communications, 7
(13276), 2016.

Marblestone, Adam H, Wayne, Greg, and Kording, Konrad P.
Towards an Integration of Deep Learning and Neuroscience.
Front. Comput. Neurosci., 10(94), 2016.

McWilliams, Brian, Balduzzi, David, and Buhmann, Joachim.
Correlated random features for fast semi-supervised learning.
In NIPS, 2013.

Mnih, Volodymyr, Kavukcuoglu, Koray, Silver, David, and et al.
Human-level control through deep reinforcement learning. Na-
ture, 518(7540):529–533, 02 2015.

Monderer, Dov and Shapley, Lloyd S. Potential Games. Games

and Economic Behavior, 14:124–143, 1996.

Nash, John F. Equilibrium Points in n-Person Games. Proc Natl

Nisan, Noam, Roughgarden, Tim, Tardos, ´Eva, and Vazirani, Vi-
jay (eds.). Algorithmic Game Theory, 2007. Cambridge Uni-
versity Press, Cambridge.

Rakhlin, Alexander and Sridharan, Karthik. Optimization, learn-
ing, and games with predictable sequences. In NIPS, 2013.

Raskutti, G and Mukherjee, S. The Information Geometry of Mir-
ror Descent. IEEE Trans. Inf. Theory, 61(3):1451–1457, 2015.

Silver, David, Huang, Aja, and et al. Mastering the game of go
with deep neural networks and tree search. Nature, 529(7587):
484–489, 01 2016.

Syrgkanis, Vasilis, Agarwal, Alekh, Luo, Haipeng, and Schapire,
Robert. Fast Convergence of Regularized Learning in Games.
In NIPS, 2015.

Tsai, Chuan-Yung, Saxe, Andrew, and Cox, David. Tensor

Switching Networks. In NIPS, 2016.

Cardelli, Luca. Type Systems. In Handbook of Computer Science

Acad Sci U S A, 36(1):48–49, 1950.

and Engineering. CRC Press, 1997.

Strongly-Typed Agents are Guaranteed to Interact Safely

Turchetta, Matteo, Berkenkamp, Felix, and Krause, Andreas. Safe
Exploration in Finite Markov Decision Processes with Gaus-
sian Processes. In NIPS, 2016.

von Neumann, John and Morgenstern, Oskar. Theory of Games
and Economic Behavior. Princeton University Press, Princeton
NJ, 1944.

Zhang, T, Kahn, G, Levine, S, and Abbeel, P. Learning deep con-
trol policies for autonomous aerial vehicles with mpc-guided
policy search. In ICRA, 2016.

Proof. We follow Amari (1998). The problem reduces to
the constrained minimization

argmin
{ξ:(cid:80) Gij (wt)ξiξj =1}

(cid:104)

(cid:96)(wt) + (cid:15) ∇ (cid:96)(wt)(cid:124)ξ

(cid:105)

which can be rewritten as

(cid:104)

argmin
ξ

∇ (cid:96)(wt)(cid:124)ξ − λξ(cid:124)G(wt)ξ

(cid:105)

Zhang, Tong and Golub, Gene H. Rank-one approximation to
higher order tensors. SIAM J. Matrix Anal. Appl., 23(2):534–
550, 2001.

with solution

ξt ∝ G−1(wt) ∇ (cid:96)(wt)

as required.

APPENDIX

A1. Proof of Theorem 1

For completeness we recall the notion of Nash equilibrium,
generalized to our setup:
Deﬁnition A1. The point w∗ ∈ H is a Nash equilibrium if
for all players n and for all w satisfying w∗ + πn(w) ∈ H
it holds that

Corollary A1. The natural gradient is safe.

The proof is obvious. We include it to highlight the role of
latent types, diagonalization and positivity.

Proof. We are required to show that

(cid:96)n(w∗) ≤ (cid:96)n(w∗ + πn(w)).

(cid:104)G−1(w) ∇ (cid:96)(w), ∇ (cid:96)(w)(cid:105) ≥ 0 for all w.

(A1)

This section completes theorem 1 when gradient descent
converges to the boundary of the feasible set. To ensure
actions stay in the feasible set we use gradient updates of
the form

The metric is symmetric positive deﬁnite, and so admits
factorization

G(wt) = P(w) · D(w) · P(cid:124)(w)

wt+1 = ProjH(wt − πρ(n)(ξt
ProjH(˜x) = argmin

(cid:107)x − ˜x(cid:107)2.

n)) where

x∈H

where P(w) is an orthogonal matrix and D(w) strictly
positive diagonal for all w. After setting ˜∇(cid:96)(w) :=
P(cid:124)(w) ∇ (cid:96)(w), the condition in (A1) can be rewritten as

the constraint set.

Proof. A point on the boundary of H is a critical point
of Φ if the gradient is zero or points perpendicularly
Since (cid:104)πm(∇ Φ), ∇ (cid:96)m(cid:105) ≥
out
αm(cid:107)πm(∇ (cid:96)m)(cid:107)2
2 ≥ 0 for all players m, it follows that
gradient descent by the players, with step sizes decaying as
1√
, will converge to a critical point of Φ. Critical points
T
of Φ are Nash equilibria of the game by convexity of the
losses as a function of their players’ actions.

A2. The natural gradient is safe

The natural gradient was introduced in Amari (1998) and
is widely used in machine learning.
Theorem. The direction of steepest descent at (cid:96)(wt) on
Riemannian manifold (Rn, G) is

ξt ∝ G−1(wt) · ∇ (cid:96)(wt).

The natural gradient is the direction G−1(wt) · ∇ (cid:96)(wt).

(cid:104)D−1(w) ˜∇(cid:96)(w), ˜∇(cid:96)(w)(cid:105) ≥ 0

which clearly holds.

Remark 1 (parametric types). The columns pi(w) of P(w)
deﬁne a parametric family of latent type systems τ i(w) =
(cid:124)
i (w) that is parametrized by w.
pi(w) · p

A3. Mirror descent is safe

We show that mirror descent is safe. The fact that mir-
ror descent is well-behaved is far from new; there is an
extensive literature analyzing its convergence properties
(Bubeck, 2015). Our purpose is to highlight the type struc-
tures underlying convex duality and mirror descent.

The approach generalizes the analysis of Newton’s method.
The role played by transform that diagonalizes the Hessian
in section 3.2 is taken over by the Legendre transform here.

Strongly-Typed Agents are Guaranteed to Interact Safely

Convex duality. The exposition closely follows Amari
(2009). Consider the manifold M = RD with coordinate
system w = (w1, . . . , wD). Let ψ : M → R be a twice-
differentiable strictly convex function. It follows that the
Hessian of ψ,

gij(w) = ∂i∂jψ(w)

is a positive deﬁnite matrix for all w which deﬁnes a Rie-
mannian metric on the manifold M . Concretely, the dis-
tance between inﬁnitesimally close points w and w + dw
is

ds2 =

gij(w)dwidwj.

(cid:88)

ij

Deﬁne the dual coordinate system

θ = ∇ ψ(w),

i.e. θi =

(w).

∂ψ
∂wi

Recall that the Legendre transform of ψ,

ψ∗(θ) = max

{w(cid:124)θ − ψ(w)},

w

satisﬁes the relation

ψ(w) + ψ∗(θ) − w(cid:124)θ = 0,

which allows to recover the original coordinates from the
dual system:

as required.

w = ∇ ψ∗(θ)

i.e. wi =

∂ψ∗
∂θi

(θ).

Deﬁne the dual metric

gij(θ) =

ψ∗(θ).

∂2
∂θi∂θj

Theorem. Given loss function (cid:96) and strictly convex twice
differentiable ψ, both deﬁned on M = RD, the mirror de-
scent step

wt+1 = argmin

w(cid:124) ∇ (cid:96)(wt) +

(cid:26)

w

(cid:27)
1
ηt Dψ(w, wt)

,

is equivalent to the natural gradient descent step

θt+1 = θt − ηt · (cid:2) ∇2 ψ∗(θt)(cid:3)−1

· ∇ (cid:96)(θt).

in the dual coordinate system.

Proof. We sketch the proof in Raskutti & Mukherjee
(2015), which should be consulted for details. Computing
the minimizer in mirror descent by differentiating shows
that the mirror descent update is equivalent, in dual coordi-
nates, to

θt+1 = θt − ηt · ∇w (cid:96)(∇ ψ∗(θt))

Applying the chain rule obtains

∇w (cid:96)(∇ ψ∗(θt)) = (cid:2)∇2 ψ∗(θt)(cid:3)−1

· ∇θ (cid:96)(∇ ψ∗(θt))

so that mirror descent can be rewritten as
θt+1 = θt − ηt · (cid:2)∇2 ψ∗(θt)(cid:3)−1

· ∇θ (cid:96)(∇ ψ∗(θt))

Corollary A2. If ψ is twice-differentiable and strictly con-
vex then mirror descent is safe.

Proof. Combine corollary A1 with the equivalence of mir-
ror descent and the natural gradient.

A4. Direct proofs of corollaries 1 and 2

Theorem. The metrics gij(w) and gij(θ) are inverse.
That is

Direct proof of corollary 1.

Proof. Safety requires

dθ = G(w)dw and dw = G−1(θ)dθ.

(cid:104)∇ (cid:96)n, ∇ (cid:96)m(cid:105) = (A(n)w−b(n))(cid:124)(A(m)w−b(m)) ≥ 0.

Proof. See Amari (2009).

Plugging in the assumptions yields

Remark 2 (parametric types). Convex duality can thus be
rephrased as a relationship between two parametric fami-
lies of types on the tangent spaces to the manifold that is
encoded in the Riemannian metric and its inverse.

which is positive by inspection.

Direct proof of corollary 2.

(cid:104)∇ (cid:96)n, ∇ (cid:96)m(cid:105) = (w − b)(cid:124)PD(n)D(m)P(cid:124)(w − b) ≥ 0

Mirror descent is safe. We show that mirror descent
is safe by applying convex duality following Raskutti &
Mukherjee (2015). Let ψ be a strictly convex twice dif-
ferentiable function. The Bregman divergence of ψ is
Dψ(v, w) = ψ(v) − ψ(w) − (cid:104)∇ ψ(w), v − w(cid:105).

Proof. The gradient and projected gradient are

∇ (cid:96)n = w(cid:124)A(n) + b(n) and

πn(∇ (cid:96)n) = w(cid:124)A(n)

•n + b(n)
n

After imposing b(n) = A(n)b, safety requires that

(b) ordering:

Strongly-Typed Agents are Guaranteed to Interact Safely

(w − b)(cid:124)A(m)

•m A(n)

m•(w − b) ≥ 0 for all w, m and n.

(cid:107)Sin=1(cid:107) ≥ (cid:107)Sin=2(cid:107) ≥ · · · ≥ (cid:107)Sin=In (cid:107) ≥ 0

Applying the remaining conditions and setting x =
R(cid:124)P(cid:124)(w − b) obtains

x(cid:124)D(m)R(cid:124)

•mRm•D(n)x ≥ 0

(cid:124)
•mRm•D(n)
Since Rm• is diagonal, it follows that D(m)R
is a product of diagonal matrices. The expression is posi-
tive since D(m)D(n) ≥ 0 by assumption.

A5. Higher-order SVD

Any N -tensor admits a higher-order SVD (HOSVD),
whereas not every tensor admits a tensor-SVD. In this sec-
tion we recall the concept of HOSVD and show why simul-
taneous HOSVD is not sufﬁcient to guarantee safety. The
section relies heavily on notation taken from de Lathauwer
et al. (2000) which the reader is encouraged to consult for
details and context.

Deﬁnition A2 (matricization). The matricization of ten-
sor A over its nth mode, denoted A(n) is an Dn ×
(Dn+1Dn+2 · · · DN D1D2 · · · Dn−1)-matrix that contains
the element A[α1, . . . , αN ] at the position with row num-
ber αn and column number

(αn+1 − 1)Dn+2Dn+3 · · · DN D1 · · · Dn−1
+(αn+2 − 1)Dn+3Dn+4 · · · DN D1 · · · Dn−1 + · · ·
+(αN − 1)D1D2 · · · Dn−1 + (α1 − 1)D2D3 · · · Dn−1
+(α2 − 1)D3D4 · · · Dn−1 + · · · + αn−1

Let us recall the notion of higher-order SVD (HOSVD)
from de Lathauwer et al. (2000).

Theorem. Every (I1, . . . , IN )-tensor A can be written as
a product

A = S ×1 U1 ×2 U2 · · · ×N UN

in which

1. Ui is a unitary (Ii × Ii) matrix

2. S is a (I1 × I2 · · · IN )-tensor of which the subtensors
Sin=α, obtained by ﬁxing the nth index to α have the
properties of

(a) all-orthogonality:

two subtensors Sin=α and
Sin=β are orthogonal for all possible values of
n, α and β subject to α (cid:54)= β:

for all possible values of n.

The Frobenius-norms (cid:107)Sin=i(cid:107), symbolized by σ(n)
are n-mode singular values of A and the vector U(n)
is an ith n-mode singular vector.

i

i

Proof. See de Lathauwer et al. (2000).

An important property of the HOSVD is as follows. Let
A = S ×1 U1 × · · · ×N UN be the HOSVD of A. Then
the matricization is

A(n) = UnΣn(Vn)(cid:124)

is an SVD of A(n), where the diagonal matrix Σn ∈
RDn×Dn and the columnwise orthonormal matrix Vn ∈
RDn+1Dn+2···DN D1D2···Dn−1×Dn are deﬁned as

Σn := diag(σn

1 , . . . , σn
Dn

),

(Vn)(cid:124) := ˜S(n)

(cid:0)Un+1 ⊗ · · · UN ⊗ U1 ⊗ · · · Un−1(cid:1)(cid:124)

where ˜Sn is a normalized version of the matricization S(n)
of S, with rows rescaled to unit-length: S(n) = Σn · ˜Sn.

A5.1. Discussion of safety and HOSVD

To somewhat reduce the proliferation of subscripts and su-
perscripts, we work with two tensors denoted A and B,
which stand in for the tensors of two players A(m) and
A(n) in an N -player game.
Lemma A1. Let A[wˆn] be the Dn-vector

A[wˆn] := A×1w1×· · ·×n−1wn−1×n+1wn+1×· · ·×N wN

where note the term wn is omitted from the expression, and
similarly for B. Then

(cid:104)πn ∇ (cid:96)A, ∇ (cid:96)B(cid:105) = A[wˆn](cid:124) · B[wˆn]

Proof. Direct computation.

Let
Lemma
(D1D2 · · · Dn−1Dn+1 · · · Dn)-vector given by

vec(wˆn)

A2.

denote

the

vec(wˆn) = vec(w1 ⊗ · · · ⊗ wn−1 ⊗ wn+1 ⊗ · · · ⊗ wN )

and suppose that the matricization has SVD A(n) =
UnΣn(Vn)(cid:124). Then A[wˆn] is the Dn-vector

A[wˆn] = UnΣn(Vn)(cid:124) vec(wˆn).

(cid:104)Sin=α, Sin=β(cid:105) = 0 when α (cid:54)= β

Proof. Direct computation.

Lemma A3.

A6. Kickback is safe

Strongly-Typed Agents are Guaranteed to Interact Safely

= vec(wˆn)(cid:124)V(n)

(cid:104)πn ∇ (cid:96)A, ∇ (cid:96)B(cid:105)
AΣn
B(Vn

A Σn

B)(cid:124) vec(wˆn).

Proof. By the above working,

= vec(wˆn)(cid:124)V(n)

A Σn

B(Vn

B)(cid:124) vec(wˆn).

(cid:104)πn ∇ (cid:96)A, ∇ (cid:96)B(cid:105)
BΣn

A)(cid:124)Un

A(Un

(Vn)(cid:124) := ˜S(n)

(cid:0)Un+1 ⊗ · · · UN ⊗ U1 ⊗ · · · Un−1(cid:1)(cid:124)

Recall that

so that

Kickback is a complementary algorithm to feedback align-
ment that is motivated by the observation that neurons com-
municate via a single kind of signal, spikes, rather than us-
ing the two kinds of signals (the feedforward sweep and
backpropagated errors) required by backprop (Balduzzi
et al., 2015).

Kickback is a truncated version of backprop that computes
gradient-estimates using the feedforward sweep together
with global error/reward signals. The error signals take the
form of a single scalar value broadcast to the entire net-
work, for example via neuromodulators. One of the main
results of the paper is that

Theorem. If neurons are coherent then kickback is safe.

Σn(Vn)(cid:124) = S(n)

(cid:0)Un+1 ⊗ · · · UN ⊗ U1 ⊗ · · · Un−1(cid:1)(cid:124)

Proof. See theorem 4 of Balduzzi et al. (2015).

Coherence is, essentially, a positivity condition on synap-
tic weights that ensures the gradient-estimates computed
by kickback have positive inner product with the gradients
computed by backprop.

A7. Comparison with Strongly-Typed RNNs

Typed linear algebra was proposed in Balduzzi & Ghifary
(2016) (STNN), which applied the framework to analyze
and simplify recurrent neural networks. The deﬁnition of
typed vector space in this paper is more general than in
STNN – it replaces an orthogonal basis with orthogonal
projections.

No formal deﬁnition of strong-typing was provided in
STNN. Informally, STNN stated: “We refer to architec-
tures as strongly-typed when they both (i) preserve the type
structure of their features and (ii) separate learned param-
eters from state-dependence”. The deﬁnition of strong-
typing in the main text, deﬁnition 5 is different from strong-
typing in STNN, although it draws on similar intuitions.
The settings are sufﬁciently disparate that no confusion
should result.

which we shorten to

Σn(Vn)(cid:124) = S(n)

(cid:16) ˜Uˆn(cid:17)(cid:124)

It follows that (cid:104)πn ∇ (cid:96)A, ∇ (cid:96)B(cid:105) equals

vec(wˆn)(cid:124) ˜Uˆn

(cid:124)
AS

(n)T(n)(Uˆn

B)(cid:124) vec(wˆn).

and the result follows.

We are ﬁnally in a position to explain why simultaneous
HOSVD is insufﬁcient to guarantee safety. That is, we are
in a position to explain why

A = S ×1 U1 ×2 U2 · · · ×N UN
B = T ×1 U1 ×2 U2 · · · ×N UN

does not guarantee (cid:104)π1(∇ (cid:96)A), ∇ (cid:96)B(cid:105) ≥ 0. Our strategy
for guaranteeing safety hinges on simultaneous diagonal-
ization. However, HOSVD does not guarantee that the core
S is diagonal. Instead, it introduces the condition of simul-
taneous orthogonality on subtensors of S.

Unfortunately, there is nothing to guarantee that the cores
S and T of two different tensors are “simultaneously all-
orthogonal” across the two tensors. In other words, there is
nothing to guarantee that the product of their matricizations

(cid:124)
(n)T(n)
S

is diagonal in general. A speciﬁc setting where this holds
is when the two tensors A and B admits a simultaneous
tensor-SVD. It is an open question whether the condition
can be guaranteed in a naturally-occurring more general
setting.

