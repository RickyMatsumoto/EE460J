Capacity Releasing Diffusion for Speed and Locality

Di Wang 1 Kimon Fountoulakis 2 Monika Henzinger 3 Michael W. Mahoney 2 Satish Rao 1

Abstract
Diffusions and related random walk procedures
are of central importance in many areas of ma-
chine learning, data analysis, and applied mathe-
matics. Because they spread mass agnostically at
each step in an iterative manner, they can some-
times spread mass “too aggressively,” thereby
failing to ﬁnd the “right” clusters. We introduce a
novel Capacity Releasing Diffusion (CRD) Pro-
cess, which is both faster and stays more lo-
cal than the classical spectral diffusion process.
As an application, we use our CRD Process to
develop an improved local algorithm for graph
clustering. Our local graph clustering method
can ﬁnd local clusters in a model of clustering
where one begins the CRD Process in a clus-
ter whose vertices are connected better internally
than externally by an O(log2 n) factor, where n
is the number of nodes in the cluster. Thus, our
CRD Process is the ﬁrst local graph clustering
algorithm that is not subject to the well-known
quadratic Cheeger barrier. Our result requires a
certain smoothness condition, which we expect
to be an artifact of our analysis. Our empirical
evaluation demonstrates improved results, in par-
ticular for realistic social graphs where there are
moderately good—but not very good—clusters.

1. Introduction

Diffusions and related random walk procedures are of cen-
tral importance in many areas of machine learning, data
analysis, and applied mathematics, perhaps most conspic-
uously in the area of spectral clustering (Cheeger, 1969;
Donath & Hoffman, 1973; von Luxburg, 2006; Shi & Ma-
lik, 2000), community detection in networks (Ng et al.,
2001; White & Smyth, 2005; Leskovec et al., 2009; Jeub
et al., 2015), so-called manifold learning (Belkin & Niyogi,

1EECS, UC Berkeley, Berkeley, CA, USA 2ICSI and Statis-
tics, UC Berkeley, Berkeley, CA, USA 3Computer Science, Uni-
versity of Vienna, Vienna, Austria. Correspondence to: Di Wang
<wangd@eecs.berkeley.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

2003; Mahoney et al., 2012), and PageRank-based spectral
ranking in web ranking (Page et al., 1999; Gleich, 2015).
Particularly relevant for our results are local/personalized
versions of PageRank (Jeh & Widom, 2003) and lo-
cal/distributed versions of spectral clustering (Spielman &
Teng, 2004; Andersen et al., 2006; Andersen & Peres,
2009). These latter algorithms can be used to ﬁnd provably-
good small-sized clusters in very large graphs without even
touching the entire graph; they have been implemented and
applied to billion-node graphs (Shun et al., 2016); and they
have been used to characterize the clustering and commu-
nity structure in a wide range of social and information net-
works (Leskovec et al., 2009; Jeub et al., 2015).

Somewhat more formally, we will use the term diffusion on
a graph to refer to a process that spreads mass among ver-
tices by sending mass along edges step by step according to
some rule. With this interpretation, classical spectral diffu-
sion spreads mass by distributing the mass on a given node
equally to the neighbors of that node in an iterative manner.
A well-known problem with spectral methods is that—due
to their close relationship with random walks—they some-
times spread mass “too aggressively,” and thereby they
don’t ﬁnd the “right” partition. In theory, this can be seen
with so-called Cockroach Graph (Guattery & Miller, 1998;
In practice, this is seen by the ex-
von Luxburg, 2006).
treme sensitivity of spectral methods to high-degree nodes
and other structural heterogeneities in real-world graphs
constructed from very noisy data (Leskovec et al., 2009;
Jeub et al., 2015). More generally, it is well-known that
spectral methods can be very sensitive to a small number
of random edges, e.g., in small-world graphs, that “short
circuit” very distant parts of the original graph, as well as
other noise properties in realistic data. Empirically, this
is well-known to be a particular problem when there are
moderately good—but not very good—clusters in the data,
a situation that is all too common in machine learning and
data analysis applications (Jeub et al., 2015).

Here, we introduce a novel Capacity Releasing Diffusion
(CRD) Process to address this problem. Our CRD Pro-
cess is a type of diffusion that spreads mass according to
a carefully-constructed push-relabel rule, using techniques
that are well-known from ﬂow-based graph algorithms, but
modiﬁed here to release the capacity of edges to transmit
mass. Our CRD Process has better properties with respect

Capacity Releasing Diffusion for Speed and Locality

to limiting the spread of mass inside local well-connected
clusters. It does so with improved running time properties.
We show that this yields improved local clustering algo-
rithms, both in worst-case theory and in empirical practice.

1.1. Capacity Releasing Diffusion (CRD)

We start by describing the generic CRD process in Fig-
ures 1 and 2, which lays down the dynamics of spreading
mass across the graph.
Importantly, this dynamical pro-
cess is independent of any particular task to which it may
be applied. Later (in Section 2) we also present a concrete
CRD algorithm for the speciﬁc task of local clustering that
exploits the dynamics of the generic CRD process1.

1. Begin with 2d(u) mass at a single (given) vertex u.

2. Repeatedly perform a CRD step, and then double the mass

at every vertex.

Figure 1. Generic Capacity Releasing Diffusion (CRD) Pro-
cess

The entire CRD process (Figure 1) repeatedly applies the
generic CRD inner process (which we call a CRD step), and
then it doubles the amount of mass at all vertices between
invocations. A CRD step starts with each vertex u having
mass m(u) ≤ 2d(u), where d(u) is the degree of u, and
spreads the mass so that at the end each vertex u has mass
m(u) ≤ d(u). Observe that, essentially, each CRD step

Each vertex v initially has mass m(v) ≤ 2d(v) and needs to
spread the mass so that m(v) ≤ d(v)∀v.

1. Each vertex v maintains a label, l(v), initially set to 0.

2. Each edge e maintains m(e), which is the mass moved
from u to v ,where m(v, u) = −m(u, v). We note that
both l(v) and m(u, v) are variables local to this inner
process, where m(v) evolves across calls to this process.

3. An edge, e = (u, v), is eligible with respect to the label-
ing if it is downhill: l(u) > l(v), and the mass m(u, v)
moved along (u, v) is less than l(u).

4. The excess of a vertex is ex(v) def= max(0, m(v) − d(v)).

The inner process continues as long as there is a vertex v with
ex(v) > 0; it either sends mass over an eligible edge incident
to v, or if there is none, then it increases l(v) by 1.

Figure 2. Generic CRD Inner Process.

spreads the mass to a region of roughly twice the volume

1The relation between the generic CRD process and the CRD
algorithm for local graph clustering is analogous to the relation
between local random walks and a local spectral graph partition-
ing algorithm such as that of Andersen et al. (2006).

comparing to the previous step.

The generic CRD inner process (Figure 2) implements a
modiﬁcation of the classic “push-relabel” algorithm (Gold-
berg & Tarjan, 1988; 2014) for routing a source-sink ﬂow.
The crucial property of our process (different from the stan-
dard push-relabel) is that edge capacity is made available to
the process slowly by releasing. That is, we only allow l(u)
units of mass to move across any edge (u, v), where l(u) is
the label (or height) maintained by the CRD inner process.
Thus, edge capacity is released to allow mass to cross the
edge as the label of the endpoint rises. As we will see, this
difference is critical to the theoretical and empirical perfor-
mance of the CRD algorithm.

1.2. Example: Classical Versus Capacity Releasing

To give insight into the differences between classical spec-
tral diffusion and our CRD Process, consider the graph in
Figure 3. There is a “cluster” B, which consists of k paths,
each of length l, joined at a common node u. There is one
edge from u to the rest of the graph, and we assume the
other endpoint v has very high degree such that the vast ma-
jority of the mass arriving there is absorbed by its neighbors
in B. While idealized, such an example is not completely
unrealistic (Leskovec et al., 2009; Jeub et al., 2015).

B

v

...

B

u

......

(cid:96)
· · ·
· · ·
· · ·

k

Figure 3. An example where Capacity Releasing Diffusion beats
classical spectral diffusion by Ω((cid:96)).

Consider ﬁrst classical spectral diffusion, with a random
walk starting from some vertex in B. This process requires
Ω((cid:96)2) steps to spread probability mass to a constant frac-
tion of the nodes on the paths, and in this many steps, the
expected number of times to visit u is Ω((cid:96)). Because of the
edge to v, each time we visit u, we have a Ω(1/k) chance
of leaving B. Thus, when (cid:96) is Ω(k), the random walk is
expected to leave B and never return, i.e., the classical dif-
fusion will leak out all the probability mass before even
spreading beyond a constant fraction of B.

Consider next our CRD Process, starting with mass at the
vertex u ∈ B (which would be a worst-case starting node in
B for CRD). Assume that at some point the mass is spread
along z neighboring vertices on each of the k paths. To
continue the spread to 2z vertices in the next CRD step, the
labels will be raised to (at most) 2z to allow the mass to
spread over the path of length 2z. This enables the spread
along the paths, but it only releases a capacity of 2z to the
exiting edge (u, v). Since in this call, a total of 2zk mass

Capacity Releasing Diffusion for Speed and Locality

is in the set B, at most 1/k of the mass escapes. After
log (cid:96) CRD steps, the mass is spread over all the k length-(cid:96)
paths, and only a (2 log (cid:96))/k fraction of the mass has es-
caped from B. Thus if (cid:96) = Ω(k), as before, a factor of
k/ log (cid:96) less mass has escaped from B with the CRD Pro-
cess than with the classical diffusion process.

Without the releasing, however, the mass escaping B would
be large, as even raising the label of vertex u to 1 would
allow an arbitrary amount of mass to leak out.

Finally, note that the (cid:96)2 mixing time makes spectral dif-
fusions a Ω((cid:96)) factor slower than CRD. This drawback of
spectral techniques can perhaps be resolved using sophis-
ticated methods such as evolving sets (Andersen & Peres,
2009), though it comes easily with CRD.

1.3. Our Main Results

We provide theoretical and empirical evidence that our
CRD algorithm is superior to classical diffusion methods
at ﬁnding clusters, with respect to noise tolerance, recov-
ery accuracy, cut conductance, and running time. Here
the cut conductance Φ(S) of a cut (S, ¯S) is Φ(S) :=
|E(S, ¯S)|
, where E(S, ¯S) denotes the set of
min(vol(S),vol(V \S))
edges between S and ¯S,2 and the volume vol(S) is the sum
of the degrees of the vertices in S. In all these measures, we
break the quadratic Cheeger barrier for classical diffusions
(explained below) while presenting a local algorithm (i.e.,
an algorithm whose running time depends on the volume
of the cluster found and not of the whole graph).

Our ﬁrst main result (Section 2) presents a CRD algorithm
and its running time. The CRD algorithm is a parameter-
ized specialization of the generic CRD Process, where we
limit the maximum label of vertices, as well as the max-
imum edge capacity. We prove that this specialization is
efﬁcient, in that it runs in time linear in the total mass and
the label limit, and it either succeeds in spreading the mass
or it leaves all unspread mass at nodes with high label. This
property is analogous to the ispoerimetric capacity control
provided by local spectral methods, and it is important for
locating cluster bottlenecks. We use this crucially in our
context to ﬁnd low conductance clusters.

Our second main result (Section 3) concerns the use of the
CRD algorithm to ﬁnd good local clusters in large graphs.
Our result posits the existence of a “good” cluster B, which
satisﬁes certain conditions (Assumption 1 and 2) that nat-
urally capture the notion of a local structure. The rather
weak Assumption 1 states that B’s internal connectivity
φS(B) (see Section 3 for deﬁnition) is a constant factor
better (i.e., larger) than the conductance φ(B). Assumption
2 states that we have a smoothness condition which needs

2Unless otherwise noted, when speaking of the conductance

of a cut S, we assume S to be the side of minimum volume.

that any subset T ⊂ B has polylog(vol(B)) times more
neighbors in B − T than in V − B. Under these conditions,
we can recover B starting from any vertex in B.

Both assumptions formalize the idea that the signal of the
local structure is stronger than the noise of the cluster by
some moderately large factor. More speciﬁcally, Assump-
tion 1 roughly says that the weakest signal of any subset
of B is a constant times stronger than the average noise of
B; and Assumption 2 roughly says the signal of any sub-
set is polylog(vol(B)) times stronger than the noise of the
subset.

We note that Assumption 1 is signiﬁcantly weaker than the
factor in Zhu et al. (2013), where it is shown how to localize
a cluster B such that φS(B) ≥ (cid:112)φ(B). Their condition
is considerably stricter than our condition on the ratio be-
tween φS(B) and φ(B), especially when φ(B) is small, as
is common. Their algorithm relies on proving that a clas-
sical diffusion starting at a typical node keeps most of its
mass inside of B. However, they do not need something
like our smoothness condition.

With the additional smoothness condition, we break the
dependence on (cid:112)φ(B) that is central to all approaches
using spectral diffusions, including Zhu et al. (2013), for
the ﬁrst time with a local algorithm.
In particular, com-
paring to Zhu et al. (2013), under their parameter settings
(but with the smoothness condition), we identify a cluster
with (cid:112)φ(B) times less error, and we have a 1/(cid:112)φ(B)
speedup in running time. This improvement is (up to a
log (cid:96)-factor) consistent with the behavior in the example of
the previous section where the improvement is k/ log (cid:96) =
O(1/((cid:112)1/φ(B) log (cid:96))) as φ(B) = 1/k(cid:96) and (cid:96) = Ω(k).

We note that with the additional smoothness condition, our
theoretical results hold for any starting node vs in B, in
contrast to prior spectral-based results which only work
when starting from a “good” node (where only a constant
fraction of the nodes in B are good). We expect the smooth-
ness condition to be an artifact of our analysis, i.e., similar
results actually hold when starting at good nodes in B, even
without this assumption.

Our third main result (Section 4) is an empirical illustration
of our method. We consider several social and informa-
tion networks studied previously that are particularly chal-
lenging for spectral methods. In particular, while graphs
that have upward-sloping NCPs (Network Community Pro-
ﬁles) have good small clusters (Leskovec et al., 2009; Jeub
et al., 2015), denser social networks with ﬂat NCPs do
not have any very-good conductance clusters of any size.
They do, however, often have moderately-good clusters,
but these are very difﬁcult for spectral methods to iden-
tify (Jeub et al., 2015). Our empirical results show that our
CRD-based local clustering algorithm is better able to iden-

Capacity Releasing Diffusion for Speed and Locality

tify and extract in a strongly local running time moderately
good quality clusters from several such social networks.

1.4. Previous Work: Low Conductance Cuts,
Diffusions, and Multicommodity Flow

Spectral algorithms for computing eigenvalues use some
variant of repeated matrix multiplication, which for graphs
is a type of classical diffusion. For the Laplacian of a graph,
the convergence rate is O(1/λ2), where λ2 is the second
smallest eigenvalue by of this matrix. The Lanczos method
improves this rate to O((cid:112)1/λ2) by cleverly and efﬁciently
combining different iterations of the diffusions. See, e.g.,
Orecchia et al. (2012) for more details on this.

One application of such a computation is to ﬁnd a low con-
ductance cut in a graph. The second eigenvector for G
can be used to ﬁnd a cut of conductance O( 1
) (Cheeger,
λ2
1969; Donath & Hoffman, 1973). Let φG be the mini-
mum conductance in the graph. In his work, Cheeger al-
ready observed that random-walk based diffusion can make
a Θ(1/
φG) error in estimating the conductance, infor-
mally known as the (quadratic) Cheeger barrier, and illus-
trated in our example. This, combined with the fact that
λ2 = O(1/φG), gives a spectral method to ﬁnd an O(φ1/2
G )
conductance cut in G.

√

φG

√

Spielman-Teng (2004) used local versions of diffusions
(i.e., those with small support) to compute recursive de-
compositions efﬁciently, and then they used locality to
produce linear time partitioning algorithms. Andersen,
Chung and Lang (2006) developed an improved version
that adjusts the standard diffusion by having mass set-
tled at vertices, resulting in signiﬁcantly improved bounds
to O(
φG log n) on the conductance of the returned cut
(B, ¯B) in time ˜O( vol(B)
). Allen-Zhu, Lattanzi and Mir-
rokni (2013) analyzed the behavior of the same algorithm
under certain well-connected conditions. The EvoCut algo-
rithm of Andersen and Peres (2009) improved the running
time of this method to ˜O( vol(B)
). As all these methods are
φG
based on spectral diffusion, their performance with respect
to conductance is subject to the Cheeger barrier. Other
processes have been proposed for random walks that mix
faster, e.g., non-backtracking random walks (Alon et al.,
2007). These too are subject to the Cheeger barrier asymp-
totically. Our result is the ﬁrst to break this barrier in any
broad setting, where classical spectral methods fail.

√

Multicommodity ﬂow based methods are able to ﬁnd clus-
ters of conductance O(φG log n) (Leighton & Rao, 1988),
bypassing the limit inherent in purely spectral methods. A
semideﬁnite programming approach, which can be viewed
as combining multicommodity ﬂow and spectral methods,
log n) (Arora et al.,
yields cuts of conductance O(φG
2009). These algorithms are very non-local, e.g., in the
sense that their running time depends on the size of the

√

whole graph, and it is not clear that they can be meaning-
fully localized. We do, however, use well-known ﬂow-
based ideas in our algorithm.
In particular, recall that
push-relabel and in general “shortest-path” based methods
have a celebrated history in algorithms (Goldberg & Tar-
jan, 2014). Using levels to release capacity, however, as we
do in our algorithm, is (to our knowledge) completely new.

2. Capacity Releasing Diffusion

In this section, we describe our algorithm which imple-
ments a speciﬁc version of the generic CRD Process. In
particular, it has some modiﬁcations for efﬁciency reasons,
and it terminates the diffusion when it ﬁnds a bottleneck
during the process. The algorithm iteratively calls a sub-
routine CRD-inner, which implements one CRD step.

For efﬁciency reasons, CRD-inner doesn’t necessarily
carry out a full CRD step, where a full CRD step means
every node u has at most d(u) mass at termination. In par-
ticular, CRD-inner only makes a certain amount of “effort”
(which is tuned by a parameter φ) to spread the mass, and if
there is a bottleneck in the form of a cut that requires “too
much effort” for the diffusion to get through, then CRD-
inner may leave excess mass on nodes, i.e., m(v) > d(v) at
termination. More speciﬁcally, given φ, CRD-inner guar-
antees to overcome any bottleneck of conductance Ω(φ),
i.e., if it doesn’t carry out a full CRD step, then it returns
a cut of conductance O(φ) as a certiﬁcate. We will discuss
CRD-inner with more detail in Section 2.2.

2.1. CRD Algorithm

Given a starting node vs, the CRD algorithm (Algorithm 1)
is essentially the CRD Process starting from vs, as de-
scribed in Figure 1. The algorithm takes as input a pa-
rameter φ, which is used to tune CRD-inner. Since CRD-
inner may stop short of a full CRD step due to a bottleneck,
we remove any excess mass remaining on nodes after call-
ing CRD-inner. Due to the excess removal, we may dis-
card mass as the algorithm proceeds. In particular, as we
start with 2d(vs) mass, and double the amount after every
CRD step, the amount of mass after the j-th doubling is
2d(vs) · 2j if we never remove excess. When the actual
amount of mass is signiﬁcantly smaller than 2d(vs) · 2j,
there must be a bottleneck (K, ¯K) during the last CRD
step, such that K contains a large fraction of the mass (and
of the excess) and such that CRD-inner cannot push any
more mass from K to ¯K. We terminate the CRD algorithm
when this happens, as the mass and, as we can show, thus
the volume of K must be large, while there are few edges
between K and ¯K. Thus K is a low-conductance cluster
around vs. Formally, the algorithm takes input parameters
τ and t, and it terminates either when the amount of mass
drops below τ (2d(vs) · 2j) after iteration j, or after itera-
tion t if the former never happens. It returns the mass on

Capacity Releasing Diffusion for Speed and Locality

.

.
.

Algorithm 1 CRD Algorithm(G, vs, φ, τ, t)

Initialization:
m(vs) = d(vs), m(v) = 0, ∀v (cid:54)= vs; j = 0.

. For j = 0, . . . , t
.
.
.

. m(v) ← 2m(v), ∀v
. Assertion: m(v) ≤ 2d(v), ∀v
. Call CRD-inner with G, m(·), φ, get cut Kj

(Kj empty if CRD-inner ﬁnishes full CRD step).

. m(v) ← min(m(v), d(v)), ∀v
v m(v) ≤ τ (2d(vs) · 2j)
.

If (cid:80)
. Return m(·), and K def= Kj. Terminate.

.

.
. End For
. Return m(·), K def= Kt.

the nodes (i.e., m(·)), as well as the cut K returned by the
last CRD-inner call in the former termination state.

The running time of our CRD algorithm is local (i.e., pro-
portional to the volume of the region it spreads mass to,
rather than the volume of the entire graph). In particular,
each CRD-inner call takes time linear in the amount of
mass, and as the amount of mass increases geometrically
before we terminate, the running time of the CRD algo-
rithm is dominated by the last CRD-inner call.

2.2. CRD Inner Procedure

Now we discuss the CRD-inner subroutine (Algorithm 2),
which aims to carry out one CRD step. In particular, each
node v has m(v) ≤ 2d(v) mass at the beginning, and
CRD-inner tries to spread the mass so each node v has
m(v) ≤ d(v) mass at the end. Not surprisingly, as the CRD
step draws intuition from ﬂow routing, our CRD-inner can
be viewed as a modiﬁcation of the classic push-relabel al-
gorithm.

As described in Figure 2, we maintain a label l(v) for
each node v, and the net mass being pushed along each
edge. Although the graph is undirected, we consider each
edge e = {u, v} as two directed arcs (u, v) and (v, u),
and we use m(u, v) to denote the net mass pushed from
u to v (during the current CRD-inner invocation). Un-
der this notation, we have m(u, v) = −m(v, u). We
denote |m(·)| def= (cid:80)
v m(v) as the total amount of mass,
ex(v) def= max(m(v) − d(v), 0) as the amount of excess on
v, and we let φ be the input parameter tuning the “effort”
made by CRD-inner (which will be clear shortly).

As noted earlier, to make CRD-inner efﬁcient, we deviate
from the generic CRD step. In particular, we make the fol-
lowing modiﬁcations:

1. The label of any node can be at most h =
3 log |m(·)|/φ. If v is raised to level h, but still has
excess mass, CRD-inner leaves the excess on v, and
won’t work on v any more. Formally, v is active if

l(v) < h and ex(v) > 0. We keep a list Q of all active
nodes, and terminate CRD-inner when Q is empty.
2. In addition to capacity releasing, the net mass along
any edge can be at most C = 1/φ. Formally, for an arc
(v, u), its effective capacity is ˆc(v, u) def= min(l(v), C),
and its residual capacity is rm(v, u) def= ˆc(v, u) −
m(v, u). The arc (v, u) is eligible iff l(v) > l(u)
(i.e., downhill) and rm(v, u) > 0. We only push mass
along eligible arcs.

3. We enforce m(v) ≤ 2d(v) for all v through the exe-
cution. This is assumed at the start, and we never push
mass to v if that would result in m(v) > 2d(v).

The parameter φ in the ﬁrst two modiﬁcations limits the
work done by CRD-inner, and it captures how hard CRD-
inner will try to carry out the full CRD step (e.g., when
h, C are inﬁnitely large, CRD-inner implements the full
CRD step). Given any φ, CRD-inner makes enough effort
by allowing nodes to have height up to h and by using the
above edge capacities to overcome bottlenecks of conduc-
tance Ω(φ) during the diffusion process. If it doesn’t ﬁnish
the full CRD step, then it returns a cut of conductance O(φ)
as certiﬁcate.

Another motivation of tuning with parameter φ is to keep
the diffusion local. Since CRD-inner doesn’t try to get
through low-conductance bottlenecks, the diffusion tends
to spread mass over well-connected region, instead of push-
ing mass out of a bottleneck. This guarantees that the work
performed is linear in the volume of the returned cluster,
i.e., that it is a strongly local algorithm, since only a small
fraction of mass can leak out of the cluster.

The third modiﬁcation guarantees when CRD-inner termi-
nates with a lot of excess on nodes, the excess won’t be
concentrated on a few nodes, as no node can have more
mass than twice its degree, and thus the cut returned must
contain a large region.

We have the following theorem for CRD-inner.

Theorem 1. Given G, m(·), and φ ∈ (0, 1], such that
|m(·)| ≤ vol(G), and ∀v : m(v) ≤ 2d(v) at the start,
CRD-inner terminates with one of the following cases:

1. CRD-inner ﬁnishes the full CRD step: ∀v : m(v) ≤

d(v).

2. There are nodes with excess, and we can ﬁnd a cut A
of conductance O(φ). Moreover, ∀v ∈ A : 2d(v) ≥
m(v) ≥ d(v), and ∀v ∈ ¯A : m(v) ≤ d(v).

The running time is O(|m(·)| log(|m(·)|)/φ).

Proof sketch. Let l(·) be the labels of nodes at termina-
tion. First note all nodes with excess must be on level h.

Capacity Releasing Diffusion for Speed and Locality

Algorithm 2 CRD-inner(G,m(·),φ)

φ

Initialization:
. ∀{v, u} ∈ E, m(u, v) = m(v, u) = 0; ∀v, l(v) = 0
. Q = {v|m(v) > d(v)}, h = 3 log |m(·)|

.
.
.
. While Q is not empty
.
.
.
.
.
.
.

. Let v be the lowest labeled node in Q.
. Push/Relabel(v).
.
.
.
. Else If Push/Relabel(v) increases l(v) by 1
.

If Push/Relabel(v) pushes mass along (v, u)
If v becomes in-active, remove v from Q
.
If u becomes active, add u to Q
.

If l(v) = h, remove v from Q.

.

If there is any eligible arc (v, u)
. Push(v, u).

Push/Relabel(v)
.
.
. Else
.

. Relabel(v).

Push(v, u)
. ψ = min (ex(v), rm(v, u), 2d(u) − m(u))
. Push ψ units of mass from v to u:

m(v, u) ← m(v, u) + ψ, m(u, v) ← m(u, v) − ψ;
m(v) ← m(v) − ψ, m(u) ← m(u) + ψ.

Relabel(v)
.

l(v) ← l(v) + 1.

Moreover, since we only push from a node v if it has ex-
cess (i.e., m(v) ≥ d(v)), once a node has at least d(v)
mass, it always has at least d(v) mass. Note further that
l(v) ≥ 1 if and only if ex(v) > 0 at some point during
the process. Thus, we know the following: l(v) = h ⇒
2d(v) ≥ m(v) ≥ d(v); h > l(v) ≥ 1 ⇒ m(v) = d(v);
l(v) = 0 ⇒ m(v) ≤ d(v).

Let Bi = {v|l(v) = i}. Since the total amount of mass
|m(·)| is at most the volume of the graph, if B0 = ∅ or
Bh = ∅, then we have case (1) of the theorem.

Otherwise, both Bh and B0 are non-empty. Let the level
cut Si = ∪h
j=iBj be the set of nodes with label at least i.
We have h level cuts Sh, . . . , S1, where vol(Sh) ≥ 1, and
Sj ⊆ Si if j > i. The conductance of these cuts, when
we go from Sh down to S1, lower bounds how much the
volume grows from Sh to S1. If all these cuts have Ω(φ)
conductance, by our choice of h, the volume of S1 will be
much larger than |m(·)|. This gives a contradiction, since
any node v ∈ S1 has m(v) ≥ d(v), and we don’t have
enough mass. It follows that at least one of the level cuts
has conductance O(φ).

As to the running time, the graph G is given implicitly,
and we only acess the list of edges of a node when it is
active. Each active node v has d(v) mass, and the total
amount of mass is |m(·)|, so the algorithm touches a region
of volume at most |m(·)|. Thus, the running time has linear
dependence on |m(·)|. Using an amortization argument one

can show that the total work of the subroutine (in the worst
case) is O(|m(·)|h) = O(|m(·)| log(|m(·)|)/φ).

3. Local Graph Clustering

In this section, we provide theoretical evidence that the
CRD algorithm can identify a good local cluster in a large
graph if there exists one around the starting node. We de-
ﬁne set conductance, φS(B) (or internal connectivity) of a
set B ⊂ V is the minimum conductance of any cut in the
induced subgraph on B.

Informally, for a “good” cluster B, any inside bottleneck
should have larger conductance than φ(B), and nodes in B
should be more connected to other nodes inside B than to
nodes outside. We capture the intuition formally as follows.

def= φS (B)

φ(B) ≥ Ω(1).
Assumption 1. σ1
Assumption 2. There exists σ2 ≥ Ω(1), such that any T ⊂
B with volB(T ) ≤ volB(B)/2 satisﬁes

|E(T, B \ T )|

|E(T, V \ B)| log vol(B) log

≥ σ2.

1
φS (B)

Following prior work in local clustering, we formulate the
goal as a promise problem, where we assume the exis-
tence of an unknown target good cluster B ⊂ V satisfy-
ing Assumption 1 and 2. In the context of local cluster-
ing, we also assume vol(B) ≤ vol(G)/2. Similar to prior
work, we assume the knowledge of a node vs ∈ B, and
rough estimates (i.e., within constant factor) of the value
of φS(B) and vol(B). We use the CRD algorithm with
vs as the starting node, φ = Θ(φS(B)), τ = 0.5, and
t = Θ(log vol(B)
d(vs) ). With the parameters we use, the algo-
rithm will terminate due to too much excess removed, i.e.,
|m(·)| ≤ τ (2d(vs) · 2j) after some iteration j. The region
where the diffusion spreads enough mass will be a good
approximation of B.
Theorem 2. Starting from any vs ∈ B, with the above
parameters, when the CRD algorithm terminates, if we let
S = {v|m(v) ≥ d(v)}, then we have:

1. vol(S \ B) ≤ O( 1
2. vol(B \ S) ≤ O( 1

σ ) · vol(B)
σ ) · vol(B)
where σ = min(σ1, σ2) ≥ Ω(1), with the σ1, σ2 from As-
sumption 1 and 2. The running time is O( vol(B) log vol(B)
).

φS (B)

The theorem states that the cluster recovered by the CRD
algorithm has both good (degree weighted) precision and
recall with respect to B; and that the stronger the “signal”
(relative to the “noise”), i.e., the larger σ1, σ2, the more
accurate our result approximates B.

If the goal is to minimize conductance, then we can run one
extra iteration of the CRD algorithm after termination with
a smaller value for φ (not necessarily Θ(φS(B)) as used in
previous iterations). In this case, we have the following.

Capacity Releasing Diffusion for Speed and Locality

Theorem 3. If we run the CRD algorithm for one extra
iteration, with φ ≥ Ω(φ(B)), then CRD-inner will end with
case (2) of Theorem 1. Let K be the cut returned. We have:

1. vol(K \ B) ≤ O( φ(B)

2. vol(B \ K) ≤ O( φ(B)

φ ) · vol(B)
φS (B) ) · vol(B)

3. φ(K) ≤ O(φ)

The running time is O( vol(B) log vol(B)

).

φ

Now we can search for the smallest φ that gives case (2) of
Theorem 1, which must give a cut of conductance within
an O(1) factor of the best we can hope for (i.e., φ(B)). If
we search with geometrically decreasing φ values, then the
running time is O(vol(B) log vol(B)/φ(B)).

Theorem 2 and 3 hold due to the particular ﬂow-based dy-
namics of the CRD algorithm, which tends to keep the dif-
fusion local, without leaking mass out of a bottleneck.

Formally, for each CRD step, we can bound the total
amount of mass that starts on nodes in B, and leaves B
at any point during the diffusion. We have the following
lemma, a sketch of the proof of which is given.

Lemma 1. In the j-th CRD step, let Mj be the total
amount of mass in B at the start, and let Lj be the amount
of mass that ever leaves B during the diffusion. Then
σ2 log vol(B) ) · Mj, when Mj ≤ volB(B)/2; and
Lj ≤ O(
Lj ≤ O( 1
σ1

) · Mj, when Mj ≥ volB(B)/2.

1

Proof sketch. We have two cases,
corresponding to
whether the diffusion already spread a lot of mass over B.

In the ﬁrst case, if Mj ≥ volB(B)/2, then we use the up-
per bound 1/φ that is enforced on the net mass over any
edge to limit the amount of mass that can leak out.
In
particular Lj ≤ O(vol(B)φ(B)/φS(B)), since there are
vol(B)φ(B) edges from B to ¯B, and φ = Θ(φS(B))
in CRD-inner. As Mj ≥ Ω(vol(B)), we have Lj ≤
O( 1
σ1

) · Mj.

The second case is when Mj ≤ volB(B)/2. In this case, a
combination of Assumption 2 and capacity releasing con-
trols the leakage of mass. Intuitively, there are still many
nodes in B to which the diffusion can spread mass. For
the nodes in B with excess on them, when they push their
excess, most of the downhill directions go to nodes inside
B. As a consequence of capacity releasing, only a small
fraction of mass will leak out.

Theorem 2 and 3 follow from straightforward analysis of
the total amount of leaked mass at termination. We sketch
the ideas for the proof of Theorem 2.
Proof sketch. Since we use φ = Θ(φS(B)) when we call
CRD-inner, the diffusion will be able to spread mass over
nodes inside B, since there is no bottleneck with conduc-
tance smaller than φS(B) in B.

Thus, before every node v in B has d(v) mass on it (in
which case we say v is saturated), there will be no excess
on nodes in B at the end of a CRD step. Consequently,
the amount of mass in B only decreases (compared to the
supposed 2d(vs) · 2j amount in the j-th CRD step) due to
mass leaving B.

As long as the total amount Mj of mass in B at the start
of a CRD step is less than volB(B)/2, the mass loss to ¯B
is at most a O(1/(σ2 log vol(B))) fraction of the mass in
B each CRD step. After O(log vol(B)) CRD steps, Mj
reaches vol(B)B/2, and only a O(1/σ2) fraction of mass
has left B so far. After O(1) more CRD steps, there will be
enough mass to saturate all nodes in B, and each of these
CRD steps looses at most a O(1/σ1) fraction of the mass
to ¯B. Thus we loose at most a O(1/σ) fraction of mass
before all nodes in B are saturated.

Once the diffusion has saturated all nodes in B,
the
amount of mass in B will be 2vol(B) at the start of ev-
ery subsequent CRD step. At most vol(B)φ(B)/φS(B) ≤
O(vol(B)/σ) mass can leave B, and nodes in B can hold
vol(B) mass, so there must be a lot of excess (in B) at the
end. Thus, the CRD algorithm will terminate in at most 2
more CRD steps, since the amount of mass almost stops
growing due to excess removal.

At termination, the amount of mass is Θ(vol(B)), and only
O(1/σ) fraction of the mass is in ¯B. Since S = {v|m(v) ≥
d(v)}, and the total mass outside is O(vol(B)/σ), we get
claim (1) of the theorem. In our simpliﬁed argument, all
nodes in B have saturated sinks (i.e., vol(B \ S) = 0) at
termination. We get the small loss in claim (2) when we
carry out the argument in more detail.

The amount of mass grows geometrically before the CRD
algorithm terminates, so the running time is dominated by
the last CRD step. The total amount of mass is O(vol(B))
in the last CRD step, and the running time follows Theo-
rem 1 with φ = Θ(φS(B)).
The proof of Theorem 3 is very similar to Theorem 2,
and the conductance guarantee follows directly from The-
orem 1. We leave the detailed proofs in the full version.

4. Empirical Illustration

We have compared the performance of the CRD algo-
rithm (Algorithm 1), the Andersen-Chung-Lang local spec-
tral algorithm (ACL) (2006), and the ﬂow-improve algo-
rithm (FlowImp) (Andersen & Lang, 2008). Given a start-
ing node vs and teleportation probability α, ACL is a lo-
cal algorithm that computes an approximate personalized
PageRank vector, which is then used to identify local struc-
ture via a sweep cut. FlowImp is a ﬂow-based algorithm
that takes as input a set of reference nodes and ﬁnds a clus-
ter around the given reference set with small conductance
value. Note that we only couple FlowImp with ACL. The

Capacity Releasing Diffusion for Speed and Locality

Table 1. Ground truth clusters

graph

feature

volume

nodes

cond.

.
p
o
H

e
c
i
R

.

m
i
S

e
t
a
g
l
o
C

217
2009
203
2009
2007
2009
2006
2007
2008
2009

10696
32454
43321
30858
14424
11845
62064
68381
62429
35369

200
886
403
607
281
277
556
588
640
638

0.26
0.19
0.46
0.33
0.47
0.1
0.48
0.41
0.29
0.11

reason is that, while FlowImp needs a very good reference
set as input to give meaningful results in our setting, it can
be used as a “clean up” step for spectral methods, since they
give good enough output. Note also that FlowImp has run-
ning time that depends on the volume of the entire graph,
as it optimizes a global objective, while our CRD algorithm
takes time linear in the volume of the local region explored.

We compare these methods on 5 datasets, one of which is
a synthetic grid graph. For the 4 real-world graphs, we
use the Facebook college graphs of John Hopkins (Hop.),
Rice, Simmons (Sim.), and Colgate, as introduced in Traud
et al. (2012). Each graph in the Facebook dataset comes
along with some features, e.g., “dorm 217,” and “class year
2009.” We consider a set of nodes with the same feature as
a “ground truth” cluster, e.g., students of year 2009. We ﬁl-
ter out very noisy features via some reasonable thresholds,
and we run our computations on the the remaining features.
The clusters of the features we use are shown in Table 1.

We ﬁlter bad clusters from all the ground truth clusters,
by setting reasonable thresholds on volume, conductance,
and gap (which is the ratio between the spectral gap of the
induced graph of cluster, and the cut conductance of the
cluster). In Table 1, we show the size and conductance of
the clusters of the features used in our experiments.

For the synthetic experiment, we measure performance by
conductance; the smaller the better. For real-world exper-
iments, we use precision and recall. We also compare to
ACLopt which “cheats” in the sense that it uses ground
truth to choose the parameter α with best F1-score (a com-
bination of precision and recall).

For the synthetic data, we use a grid graph of size 60 × 60.
We add noise to the grid by randomly connecting two ver-
tices. We illustrate the performance of the algorithms ver-
sus probability of random connection in Figure 4. The
range of probabilities was chosen consistent with theory.
As expected, CRD outperforms ACL in the intermediate
range, and the two method’s performances meet at the end-
points. One view of this is that the random connections
initially adds noise to the local structure and eventually de-
stroys it. CRD is more tolerant to this noise process.

Figure 4. Average results for 60 × 60 grid

Table 2. Results on Facebook graphs

feat.

mtr.

CRD

ACL

ACLopt

FlowImp

ID

s
n
i
k
p
o
H

e
c
i
R

e
t
a
g
l
o
C

s 2007
n
o
m
m
S

2009

i

217

2009

203

2009

2006

2007

2008

2009

Pr.
Re.
Pr.
Re.
Pr.
Re.
Pr.
Re.
Pr.
Re.
Pr.
Re.
Pr.
Re.
Pr.
Re.
Pr.
Re.
Pr.
Re.

0.92
0.95
0.95
0.97
0.43
0.8
0.92
0.98
0.5
0.5
0.96
0.99
0.43
0.53
0.52
0.57
0.94
0.96
0.97
0.98

0.87
0.94
0.92
0.95
0.32
0.9
0.25
0.99
0.49
0.75
0.95
0.99
0.41
0.68
0.47
0.71
0.61
0.95
0.93
0.98

0.87
0.94
0.91
0.95
0.32
0.9
0.25
0.99
0.49
0.75
0.95
0.99
0.41
0.69
0.47
0.72
0.64
0.95
0.93
0.98

0.92
0.89
0.96
0.96
0.33
0.87
0.92
0.99
0.26
0.99
0.96
0.99
0.22
1.0
0.24
1.0
0.95
0.97
0.98
0.99

See Table 2 for results for real-world data. We run algo-
rithms starting at each vertex in a random sample of half
the vertices in each cluster and report the median.

For clusters with good but not great conductance (e.g.,
Rice 2009, Colgate 2008), CDR outperforms ACL and has
nearly identical performance to FlowImp (which, recall, is
a global algorithm). This is a consequence of CDR avoid-
ing the trap of leaking mass out of the local structure, in
contrast to ACL, which leaks a large fraction of mass. For
clusters with great conductance, all methods perform very
well; and all methods perform poorly when the conduc-
tance of the clusters gets close to 0.5.

Here again, as with the synthetic data, we see that for high
conductance sets (which do not have good local structure)
and very good conductance sets (which have excellent lo-
cal structure), all methods perform similarly. In the inter-
mediate range, i.e., when there are moderately good but not
very good quality clusters, CDR shows distinct advantages,
as suggested by the theory.

Capacity Releasing Diffusion for Speed and Locality

Acknowledgements

SR and DW are supported by the National Science Foun-
dation under Grant CCF-1528174 and CCF-1535989. MM
and KF would like to thank the Army Research Ofﬁce
and the Defense Advanced Research Projects Agency for
partial support of this work. MH has received fund-
ing from the European Research Council under the Euro-
pean Union’s Seventh Framework Programme (FP/2007-
2013)/ERC Grant Agreement no. 340506.

References

Alon, Noga, Benjamini, Itai, Lubetzky, Eyal, and Sodin,
Sasha. Non-backtracking random walks mix faster.
Communications in Contemporary Mathematics, 9(04):
585–603, 2007.

Andersen, R. and Lang, K. An algorithm for improving

graph partitions. SODA 2008, pp. 651–660, 2008.

Andersen, Reid and Peres, Yuval. Finding sparse cuts lo-
cally using evolving sets. In STOC 2009, pp. 235–244,
2009.

Andersen, Reid, Chung, Fan, and Lang, Kevin. Local graph
partitioning using PageRank vectors. In FOCS 2006, pp.
475–486, 2006.

Arora, Sanjeev, Rao, Satish, and Vazirani, Umesh. Ex-
pander ﬂows, geometric embeddings and graph parti-
tioning. Journal of the ACM (JACM), 56(2):5, 2009.

Belkin, M. and Niyogi, P. Laplacian eigenmaps for dimen-
sionality reduction and data representation. Neural Com-
putation, 15(6):1373–1396, 2003.

Cheeger, Jeff. A lower bound for the smallest eigenvalue
of the Laplacian. In Proceedings of the Princeton con-
ference in honor of Professor S. Bochner, 1969.

Donath, William E and Hoffman, Alan J. Lower bounds
for the partitioning of graphs. IBM Journal of Research
and Development, 17(5):420–425, 1973.

Gleich, D. F. PageRank beyond the web. SIAM Review, 57

(3):321–363, 2015.

Goldberg, Andrew V and Tarjan, Robert E. A new ap-
proach to the maximum-ﬂow problem. Journal of the
ACM (JACM), 35(4):921–940, 1988.

Goldberg, Andrew V. and Tarjan, Robert Endre. Efﬁcient
maximum ﬂow algorithms. Commun. ACM, 57(8):82–
89, 2014.

Jeh, Glen and Widom, Jennifer. Scaling personalized web
search. In Proceedings of the 12th international confer-
ence on World Wide Web, pp. 271–279. ACM, 2003.

Jeub, L. G. S., Balachandran, P., Porter, M. A., Mucha, P. J.,
and Mahoney, M. W. Think locally, act locally: Detec-
tion of small, medium-sized, and large communities in
large networks. Physical Review E, 91:012821, 2015.

Leighton, Tom and Rao, Satish. An approximate max-
ﬂow min-cut theorem for uniform multicommodity ﬂow
problems with applications to approximation algorithms.
In FOCS, 1988, pp. 422–431. IEEE, 1988.

Leskovec, J., Lang, K.J., Dasgupta, A., and Mahoney,
M.W. Community structure in large networks: Natural
cluster sizes and the absence of large well-deﬁned clus-
ters. Internet Mathematics, 6(1):29–123, 2009.

Mahoney, M. W., Orecchia, L., and Vishnoi, N. K. A local
spectral method for graphs: with applications to improv-
ing graph partitions and exploring data graphs locally.
Journal of Machine Learning Research, 13:2339–2365,
2012.

Ng, A.Y., Jordan, M.I., and Weiss, Y. On spectral clus-
In NIPS ’01: Pro-
tering: Analysis and an algorithm.
ceedings of the 15th Annual Conference on Advances in
Neural Information Processing Systems, 2001.

Orecchia, Lorenzo, Sachdeva, Sushant, and Vishnoi,
Nisheeth K. Approximating the exponential, the Lanc-
zos method and an ˜O(m)-time spectral algorithm for
In STOC 2012, pp. 1141–1160.
balanced separator.
ACM, 2012.

Page, Lawrence, Brin, Sergey, Motwani, Rajeev, and Wino-
grad, Terry. The pagerank citation ranking: Bringing or-
der to the web. Technical report, Stanford InfoLab, 1999.

Shi, J. and Malik, J. Normalized cuts and image segmen-
tation. IEEE Transcations of Pattern Analysis and Ma-
chine Intelligence, 22(8):888–905, 2000.

Shun, J., Roosta-Khorasani, F., Fountoulakis, K., and Ma-
honey, M. W. Parallel local graph clustering. Proceed-
ings of the VLDB Endowment, 9(12):1041–1052, 2016.

Spielman, Daniel A. and Teng, Shang-Hua. Nearly-linear
time algorithms for graph partitioning, graph sparsiﬁca-
tion, and solving linear systems. In STOC 2004, pp. 81–
90, 2004.

Guattery, S. and Miller, G.L. On the quality of spectral
separators. SIAM Journal on Matrix Analysis and Appli-
cations, 19:701–719, 1998.

Traud, A. L., Mucha, P. J., and Porter, M. A. Social struc-
ture of facebook networks. Physica A: Statistical Me-
chanics and its Applications, 391(16):4165–4180, 2012.

Capacity Releasing Diffusion for Speed and Locality

von Luxburg, U. A tutorial on spectral clustering. Techni-
cal Report 149, Max Plank Institute for Biological Cy-
bernetics, August 2006.

White, S. and Smyth, P. A spectral clustering approach to
ﬁnding communities in graphs. In SDM ’05: Proceed-
ings of the 5th SIAM International Conference on Data
Mining, pp. 76–84, 2005.

Zhu, Zeyuan Allen, Lattanzi, Silvio, and Mirrokni, Va-
hab S. A local algorithm for ﬁnding well-connected clus-
ters. In ICML 2013, pp. 396–404, 2013.

